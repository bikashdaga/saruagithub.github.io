<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WangXue</title>
  
  <subtitle>1 笨笨的孩子慢慢学stay hungry stay foolish 2 武汉加油！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-31T02:32:42.114Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WangXue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分治递归思想</title>
    <link href="http://yoursite.com/2020/03/31/20200330%E5%88%86%E6%B2%BB%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2020/03/31/20200330%E5%88%86%E6%B2%BB%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/</id>
    <published>2020-03-31T01:37:21.000Z</published>
    <updated>2020-03-31T02:32:42.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分治递归思想"><a href="#分治递归思想" class="headerlink" title="分治递归思想"></a>分治递归思想</h3><p>为了解决一个给定的问题，算法一次或多次递归的调用自身以解决若干子问题，这些就是典型的分治法的思想。我们将原问题分解为几个规模较小但类似于原问题的子问题，从而递归的调用自身，最后合并这些子问题的解来建立原问题的解。</p><p>关键：1，分解原问题为相同结构的子问题。2，解决这些子问题。3，合并子问题的解。</p><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><h4 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h4><p>如果计算1 + 2 + … n ，可以用递归的方法来写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddFrom1ToN_Recursive</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n &lt;= <span class="number">0</span>?: <span class="number">0</span>:n + AddFrom1ToN_Recursive(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里递归比循环的时间复杂度更高，函数递归调用自身都要在内存栈中分配空间保存参数（如n到哪了），返回地址（函数的地址），临时变量（上一次计算得到的AddFrom1ToN_Recursive值）等等，因此空间和时间消耗较多。</p><p>更严重的话递归会带来调用栈溢出的问题，递归调用层级太多就有可能超出栈的容量。</p><h4 id="归并排序。"><a href="#归并排序。" class="headerlink" title="归并排序。"></a>归并排序。</h4><p><a href="[https://saruagithub.github.io/2020/03/10/20200309%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/](https://saruagithub.github.io/2020/03/10/20200309排序算法复习/">排序—归并排序</a>)</p><p>归并排序的详细复杂度分析见 《算法导论》P21，通过递归树分析，总代价是$cnlgn + cn$ (c表示求解规模为1的问题所需要的时间以及在分解步骤与合并步骤处理每个数组元素所需要的时间。)</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, 《算法导论》机械工业出版社 第三版（黑皮的，Thoms H Cormen…）</p><p>2，leecode网站</p><p>3，</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分治递归思想&quot;&gt;&lt;a href=&quot;#分治递归思想&quot; class=&quot;headerlink&quot; title=&quot;分治递归思想&quot;&gt;&lt;/a&gt;分治递归思想&lt;/h3&gt;&lt;p&gt;为了解决一个给定的问题，算法一次或多次递归的调用自身以解决若干子问题，这些就是典型的分治法的思想。我们将原问题分解为几个规模较小但类似于原问题的子问题，从而递归的调用自身，最后合并这些子问题的解来建立原问题的解。&lt;/p&gt;&lt;p&gt;关键：1，分解原问题为相同结构的子问题。2，解决这些子问题。3，合并子问题的解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>数组实现堆</title>
    <link href="http://yoursite.com/2020/03/28/20200328%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86/"/>
    <id>http://yoursite.com/2020/03/28/20200328%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86/</id>
    <published>2020-03-28T09:25:36.000Z</published>
    <updated>2020-03-28T10:08:59.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树，逐层而下，从左到右，结点的位置完全由其序号觉得，因此可以用数组来实现。</p><p>计算各结点下标的公式，其中$r$ 表示结点的下标，范围在0 ~ n-1 之间，n是二叉树结点的总数。</p><p>$Parent(r)= \lfloor (r-1)/2 \rfloor$ 向下取整，当$r≠0$时</p><p>$Leftchild(r)=2r+1$,当$2r+1&lt;n$时</p><a id="more"></a><p>$Rightchild(r)=2r+2$,当 $2r+2&lt;n$ 时</p><p>$Leftsibling()=r-1$,当r为偶数时</p><p>$Rightsibling()=r+1$ ,当r为奇数并且$r+1&lt;n$时</p><p><img src="/images/20200328Build_heap.jpg" alt="20200328Build_heap"></p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>完全二叉树的一个重要应用是最大堆和最小堆，最小堆就是儿子的值一定不小于父亲的值，树的节点从上到下，从左到右紧凑排列。这里给出最小堆的实现：</p><p>插入数值：在堆的末尾插入，然后不断向上提升，直到没有大小颠倒。</p><p>删除数值：首先把堆的最后一个节点的数值放到根上去，并且删除最后一个节点，然后不断向下交换直到没有大小颠倒为止。向下交换的时候如果2个儿子都比自己小，那么选择数值较小的儿子进行交换。</p><p>复杂度：建堆需要$\Theta(n)$ 的时间，但删除插入都和树深度成正比，时间复杂度是$\Theta(nlogn)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------- min heap --------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[MAX_N],sz=<span class="number">0</span>; <span class="comment">//sz is global variable, meaning the lengh of heap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//own node's num.</span></span><br><span class="line">    <span class="keyword">int</span> node_index = sz++;</span><br><span class="line">    <span class="keyword">while</span> (node_index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = (node_index<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">//i's parent</span></span><br><span class="line">        <span class="keyword">if</span> (heap[p] &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// sequence is ok</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// parent's value put down, node value go up</span></span><br><span class="line">        heap[node_index] = heap[p];</span><br><span class="line">        node_index = p;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[node_index] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heap_pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// min (root)</span></span><br><span class="line">    <span class="keyword">int</span> rec = heap[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// the new temp root value, get it for compare and move it</span></span><br><span class="line">    <span class="keyword">int</span> x = heap[--sz];</span><br><span class="line">    <span class="comment">//replace from the root</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt; sz) &#123;</span><br><span class="line">        <span class="comment">//compare the children value</span></span><br><span class="line">        <span class="keyword">int</span> a = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = i*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) &#123;</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sequence is right</span></span><br><span class="line">        <span class="keyword">if</span> (heap[a] &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// child's value go up</span></span><br><span class="line">        heap[i] = heap[a];</span><br><span class="line">        i=a;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = x;</span><br><span class="line">    <span class="keyword">return</span> rec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//push(3);</span></span><br><span class="line">    heap_push(<span class="number">9</span>);</span><br><span class="line">    heap_push(<span class="number">2</span>);</span><br><span class="line">    heap_push(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;heap[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pop:"</span>&lt;&lt;heap_pop()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pop:"</span>&lt;&lt;heap_pop()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ------ standard package is the max queue ------</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; qqueue;</span><br><span class="line">    qqueue.push(<span class="number">-9</span>);</span><br><span class="line">    qqueue.push(<span class="number">-2</span>);</span><br><span class="line">    qqueue.push(<span class="number">-6</span>);</span><br><span class="line">    <span class="comment">//loop until it is empty</span></span><br><span class="line">    <span class="keyword">while</span> (!qqueue.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span> * qqueue.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        qqueue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，《数据结构与算法分析》 Clifford A. Shaffer 等</p><p>2，《挑战程序设计》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;完全二叉树&quot;&gt;&lt;a href=&quot;#完全二叉树&quot; class=&quot;headerlink&quot; title=&quot;完全二叉树&quot;&gt;&lt;/a&gt;完全二叉树&lt;/h3&gt;&lt;p&gt;完全二叉树，逐层而下，从左到右，结点的位置完全由其序号觉得，因此可以用数组来实现。&lt;/p&gt;&lt;p&gt;计算各结点下标的公式，其中$r$ 表示结点的下标，范围在0 ~ n-1 之间，n是二叉树结点的总数。&lt;/p&gt;&lt;p&gt;$Parent(r)= \lfloor (r-1)/2 \rfloor$ 向下取整，当$r≠0$时&lt;/p&gt;&lt;p&gt;$Leftchild(r)=2r+1$,当$2r+1&amp;lt;n$时&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
      <category term="完全二叉树" scheme="http://yoursite.com/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>20200325word的xml无效而无法打开</title>
    <link href="http://yoursite.com/2020/03/26/20200325word%E7%9A%84xml%E6%97%A0%E6%95%88%E8%80%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"/>
    <id>http://yoursite.com/2020/03/26/20200325word%E7%9A%84xml%E6%97%A0%E6%95%88%E8%80%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/</id>
    <published>2020-03-26T01:07:58.000Z</published>
    <updated>2020-03-26T01:26:04.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>写论文生成word的时候出现了xml无效的问题。</p><p><img src="/images/20200325word_problem1.jpg" alt="20200325word_problem1"></p><p>将word文档原扩展名“docx”手动改为压缩文件扩展名“zip”，备份一个，然后用解压软件解压。用vscode编辑器或者其他的一些xml编辑器（如firstobject）打开解压文件夹下的word目录下的document.xml 文件。根据对xml错误提示进行更改。</p><a id="more"></a><p>我这里提示的错误是：起始标记“mc:Fallback”（偏移位置 1732371）在偏移位置 1733790缺少对应的结束标记。则将鼠标移动到 1733790个字节的位置，说明这里缺少了 ＜/mc:Fallback＞，注意英文输入。 </p><p>然后重复分析xml文档的缺失，直到没有任何问题。其中遇到了下图这个最后的问题，这个问题是直接缺了 ＜ /w:r＞这个标签，怎么分析的呢？是查找对比前面的几对Fallback的格式发现的缺失，这个就要好好对比一下了。</p><p><img src="/images/20200325word_problem2.jpg" alt="20200325word_problem2"></p><h3 id="重新打开"><a href="#重新打开" class="headerlink" title="重新打开"></a>重新打开</h3><p>最后将改完的xml替换原来的xml，再将“.zip”改回”.dcox“文档，再次打开word文件就可以打开了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;写论文生成word的时候出现了xml无效的问题。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/20200325word_problem1.jpg&quot; alt=&quot;20200325word_problem1&quot;&gt;&lt;/p&gt;&lt;p&gt;将word文档原扩展名“docx”手动改为压缩文件扩展名“zip”，备份一个，然后用解压软件解压。用vscode编辑器或者其他的一些xml编辑器（如firstobject）打开解压文件夹下的word目录下的document.xml 文件。根据对xml错误提示进行更改。&lt;/p&gt;
    
    </summary>
    
    
      <category term="配置" scheme="http://yoursite.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="word" scheme="http://yoursite.com/tags/word/"/>
    
  </entry>
  
  <entry>
    <title>Unsupervised Anomaly Detection via Variational Auto-Encoder for Seasonal KPIs in Web Applications (Donut model, Part Ⅱ)</title>
    <link href="http://yoursite.com/2020/03/14/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part2)/"/>
    <id>http://yoursite.com/2020/03/14/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part2)/</id>
    <published>2020-03-14T09:40:12.000Z</published>
    <updated>2020-03-15T00:29:36.966Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Evaluation实验"><a href="#Evaluation实验" class="headerlink" title="Evaluation实验"></a>Evaluation实验</h3><h4 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h4><p>我们从大型互联网上获得了18个维护良好的商业KPIs（时间跨度足以进行培训和评估），所有的KPIs间隔为1min。三个数据集 A B C 如图6的Table1。因此我们可以评估Donut在不同级别的噪声。 我们将每个数据集分为训练集 49%，验证集21%和测试集30%。</p><a id="more"></a><p><img src="/images/20200314Donut_Dataset.jpg" alt="20200314Donut_Dataset"></p><h4 id="Performance-Metric度量指标"><a href="#Performance-Metric度量指标" class="headerlink" title="Performance Metric度量指标"></a>Performance Metric度量指标</h4><p>评估中，完全忽略了所有算法在缺失点（“空”）的输出。本文所有评估的算法为每个点计算一个异常分数，选择一个阈值来进行决策：如果某个点的分数大于阈值，则应该触发警报。这样，异常检测就类似于分类问题，并且我们可以计算与每个阈值相对应的精度和召回率。给定所有可能的阈值，我们可以进一步计算AUC，即召回率的平均精度。或F分数，它是给定一个特定阈值的精度和召回率的谐平均值。我们还可能枚举所有阈值，获得所有F分数，并使用最佳F分数作为度量。给定最佳全局阈值，最好的F分数表示模型在特定测试集上的最佳性能。在实践中，最佳F分数与AUC基本一致，除了细微差异（见图8）。<strong>相比AUC我们更喜欢best F-score</strong>，因为在某个阈值上拥有出色的F分数比在大多数阈值上拥有高但不是那么出色的F分数更为重要。</p><p>简单评估策略：在实际应用中，操作员通常并不关心逐点度量。 如果延迟不太长，触发连续异常段中任何点的警报都是可接受的。 已经提出了一些用于异常检测的度量来适应这种偏好，例如，[22 NAB]，但是大多数度量没有被广泛接受，这可能是因为它们太复杂了。 相反，我们使用一种简单的策略：如果可以通过选定的阈值检测到真实异常段中的任何点，那么我们就说该段被正确检测了，并且将该段中的所有点都视为可以被此段检测到。 同时，异常段外的点将照常处理。 然后相应地计算精度，召回率，AUC，F-score和best F-score。 图7中说明了这种方法。alert delay = 警报分段中第一个点与第一个检测到的点之间的时间差。</p><p><img src="/images/20200314Metric.jpg" alt="20200314Metric"></p><h4 id="Experiment-启动"><a href="#Experiment-启动" class="headerlink" title="Experiment 启动"></a>Experiment 启动</h4><p>参数设置：我们设置窗口大小W = 120，即2h。W的选择受到两个因素的限制。 一方面，W太小将导致模型无法捕获模式，因为模型被期望识别出那些仅来自窗口的正常模式，（请参阅第5.1节）。 另一方面，W太大会增加过度拟合的风险，因为我们用没有权值共享的全连接层，因此模型参数的数量与W成正比。我们将B和C的潜在维度K设置为3，因为3维空间可以很容易地可视化以便分析。隐藏层的 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 和 $p_{\theta}(\mathbf{x} | \mathbf{z})$ 都选择作两个ReLU层，每个ReLU层具有100个单位，这使得变分和生成网络具有相等的大小。我们没有对隐藏网络的结构进行详尽的搜索。</p><p>其他超参： std 层的 $\epsilon = 10^{-4}$ ，injection ratio = $\lambda$ ,  MCMC 迭代次数M = 10， 蒙特卡洛积分的采样数量$L = 1024$ ，训练的batch size = 256，运行250 Epochs，优化器是 Adam[15]，初始学习率是 $10^{-3}$ ，每过10Epochs就将学习率折0.75，对隐藏层采用L2正则化其系数coefficient = $10^{-3}$。 我们按标准裁剪clip梯度，限制为10.0。 </p><p>标签说明：为了评估没有标签的Donut，我们将忽略所有标签。 对于偶有的标签，我们对训练和验证集的异常标签进行下采样，以使其包含10％的标记异常。 请注意，缺失点不会被下采样。 我们一直随机丢弃异常片段，其概率与每个片段的长度成正比，直到达到所需的下采样率。 我们使用这种方法，而不是随机丢弃单个异常点，因为KPI是时间序列，并且每个异常点都可能泄漏有关其邻近点的信息，从而导致性能被高估。 这样的下采样完成了10次，这使我们能够进行10个独立的重复实验。 对于每个数据集，总体而言，我们有三个版本：0％标签，10％标签和100％标签。</p><h4 id="总体性能"><a href="#总体性能" class="headerlink" title="总体性能"></a>总体性能</h4><p>我们比较AUC，best F-score和平均alert delay，与三种算法相比，如图8：</p><p><img src="/images/20200314compare_metric.jpg" alt="20200314compare_metric"></p><p>比较的算法：Opprentice[25]，VAE baselin[2] 基于VAE的异常检测不处理时间序列，因此我们按以下方法设置VAE基模型。 首先，VAE基模型具有与Donut相同的网络结构，如图4所示。其次，在图3中的所有技术中，仅使用“数据准备”步骤中的那些技术。 第三，正如[2]所建议的，我们从训练数据中排除所有包含标记异常或缺失点的窗口。 Donut-Prior算法，给定一个生成模型自然学习 $p(x)$ ，而在VAE $p(x)$ 被定义为 $\mathbb{E}_{\boldsymbol{p}_{\theta}(\mathbf{z})}\left[p_{\theta}(\mathbf{x} | \mathbf{z})\right]$ ，我们还评估了重建概率的先前部分 $\mathbb{E}_{p_{\theta}(\mathbf{z})}\left[\log p_{\theta}(\mathbf{x} | \mathbf{z})\right]$。 我们只需要先验的基模型，因此我们可以通过简单的蒙特卡洛积分来计算先验期望，而无需使用先进的技术来改善结果。</p><p>The best F-score of Donut is quite satisfactory in totally unsu- pervised case, ranges from 0.75 to 0.9, </p><p>Donut，Opprentice和VAE Baseline的平均警报延迟在所有数据集中都是可接受的</p><h4 id="Donut技术的效果"><a href="#Donut技术的效果" class="headerlink" title="Donut技术的效果"></a>Donut技术的效果</h4><p>我们提出的三种技术的各自的作用(1) M-ELBO (Eqn (3)), (2) missing data injection, and (3) MCMC imputation。我们通过这些技术的四种可能的组合展示了Donut的最佳F分数：</p><p><img src="/images/202003154Tech-BestF-score.jpg" alt="202003154Tech-BestF-score"></p><p>仅M-ELBO就能在VAE基模型上做出大部分改进。 它通过训练Donut来适应x中可能出现的异常点并在这种情况下产生所需的输出而起作用。尽管对于生成模型来说很自然（第5.2节），但仅使用正常数据来训练VAE以进行异常检测不是一个好习惯。</p><p>丢失数据注入是为增强M-ELBO的效果而设计的，实际上可以看作是一种数据增强方法。我们仅注入遗漏的点。由于缺少数据注入而导致的最佳F分数的提高不是很明显。注射会给训练带来额外的随机性，因此需要更大的训练时间。</p><p>MCMC imputation还旨在帮助Donut处理异常点。 尽管Donut仅在某些情况下使用MCMC获得了最佳F评分的显着改善，但它从未损害性能。 根据[32]，这应该是预期的结果。 因此，我们建议在检测中始终采用MCMC。</p><h4 id="分析K的影响。"><a href="#分析K的影响。" class="headerlink" title="分析K的影响。"></a>分析K的影响。</h4><p>$z$ 的维度 K很重要。K太小可能会导致拟合不足或次优平衡（请参见第5.4节）。 另一方面，K太大可能会导致重建概率无法找到好的后验概率（请参阅第5.1节）。 在完全不受监督的情况下很难选择一个好的K，因此我们将其留作未来的工作。</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>我们在此提出针对重建概率以及整个Donut算法的KDE（内核密度估计）解释。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Evaluation实验&quot;&gt;&lt;a href=&quot;#Evaluation实验&quot; class=&quot;headerlink&quot; title=&quot;Evaluation实验&quot;&gt;&lt;/a&gt;Evaluation实验&lt;/h3&gt;&lt;h4 id=&quot;Datasets&quot;&gt;&lt;a href=&quot;#Datasets&quot; class=&quot;headerlink&quot; title=&quot;Datasets&quot;&gt;&lt;/a&gt;Datasets&lt;/h4&gt;&lt;p&gt;我们从大型互联网上获得了18个维护良好的商业KPIs（时间跨度足以进行培训和评估），所有的KPIs间隔为1min。三个数据集 A B C 如图6的Table1。因此我们可以评估Donut在不同级别的噪声。 我们将每个数据集分为训练集 49%，验证集21%和测试集30%。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="AnomalyDetection" scheme="http://yoursite.com/tags/AnomalyDetection/"/>
    
  </entry>
  
  <entry>
    <title>Unsupervised Anomaly Detection via Variational Auto-Encoder for Seasonal KPIs in Web Applications (Donut model, Part I)</title>
    <link href="http://yoursite.com/2020/03/13/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part1)/"/>
    <id>http://yoursite.com/2020/03/13/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part1)/</id>
    <published>2020-03-13T02:54:13.000Z</published>
    <updated>2020-03-14T14:40:49.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ABS-amp-Intro"><a href="#ABS-amp-Intro" class="headerlink" title="ABS&amp;Intro"></a>ABS&amp;Intro</h3><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>大的互联网公司一般会密切监控KPIs。然而这些有不同模式不同数据质量的季节性KPIs的异常检测很有挑战，特别是无标签。本文中，我们提出了Donut，基于VAE（Variational Auto-Encoder 变分自动编码器）的无监督异常检测算法，其最佳F-score达到0.75 ~ 0.9。我们为Donut的重构提出了一种新颖的KDE解释，使其成为第一种基于VAE的异常检测算法，并且具有扎实的理论解释。</p><a id="more"></a><h4 id="KPIs时间序列数据"><a href="#KPIs时间序列数据" class="headerlink" title="KPIs时间序列数据"></a>KPIs时间序列数据</h4><p>度量指标如页面浏览量，在线用户数量，订单数量等等。在所有的这些KPIs里，本文主要关心一些商业相关的KPIs，这些受用户行为计划所影响，因此大致表现出有规律的季节性模式（如按天，按周等）。</p><p>检测KPI异常的相关文献【1, 2, 5– 8, 17, 18, 21, 23–27, 29, 31, 35, 36, 40, 41】 很丰富。现有的异常检测算法遭受算法挑选/参数调整的麻烦，严重依赖标签，性能不令人满意和/或缺乏理论基础。</p><h4 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h4><p>本文提出的Donut，基于VAE（代表性的深层生成模型）的无监督异常检测算法，伴有理论解释，可以无标签或偶尔提供的标签下学习。</p><p>本文贡献：</p><p>1，Donut里的三项技术：改进的ELBO，缺失数据注入进行训练以及为了检测的MCMC (imputation)借补法。使它大大超越了最新的监督类和基于VAE的异常检测算法。 对于来自顶级全球互联网公司的研究KPI，无监督Donut的最佳F-score在0.75到0.9之间。</p><p>2，在文献中，我们首次发现采用VAE（或一般而言的生成模型）进行异常检测需要对正常数据和异常数据进行训练，这与通常的直觉相反。</p><p>3，我们为Donut在z空间中提出了一种新颖的KDE解释，使其成为第一个基于VAE的具有可靠理论解释的异常检测算法。这种解释可能有益于异常检测中其他深度生成模型的设计。 我们发现了潜在z空间中的时间梯度效应，很好地说明了Donut在检测季节性KPI异常方面的出色性能。</p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><h4 id="KPIs的异常检测"><a href="#KPIs的异常检测" class="headerlink" title="KPIs的异常检测"></a>KPIs的异常检测</h4><p>商业KPIs一般由季节性，另一方面在每个重复周期中，KPI曲线的形状并不完全相同，因为用户行为可能会随着天变化。这里我们命名KPIs为“具有局部变化的季节性KPIs” （如图1）</p><p><img src="/images/20200313Donut_Figure_KPIs.jpg" alt="20200313Donut_Figure1"></p><p>另一类局部变化是随着日数增加的趋势，可以通过Holt-Winters [41]和时间序列分解[6]来确定。 除非正确处理了这些局部变化，否则异常检测算法可能无法正常工作。</p><p>除了季节性，局部变化variation，这些KPIs也有噪声noise。我们假设噪声独立，在每个点服从0均值高斯分布。高斯噪声的精确值是没有意义的，因此，我们仅关注这些噪声的统计数据，即噪声的方差。</p><p>现在我们可以将季节性KPI的“正常模式”形式化为两个组成部分的组合：（1）具有局部变化的季节性模式（2）高斯噪声的统计数据。</p><p>我们使用Anomaly表示不遵循正常模式的（突然的尖峰和骤降）数据点，abnormal表示Anomaly和缺失点。本文主要检测Anomalies。</p><p>由于操作员需要处理异常以进行故障排除/缓解，因此有些异常会被标上标签。 请注意，此类偶然标签对异常的覆盖范围与典型的监督学习算法所需要的相去甚远。</p><p>异常检测算法一般对$x_{t-T+1}, \ldots, x_{t}$ 计算$p\left(y_{t}=1 | x_{t-T+1}, \ldots, x_{t}\right)$ ，操作员只需选择阈值判断异常。</p><h4 id="2-3的Problem-Statement"><a href="#2-3的Problem-Statement" class="headerlink" title="2.3的Problem Statement"></a>2.3的Problem Statement</h4><p>（挪到前面来了）在我们的上下文中，尽管远不完整，但偶尔还是可以使用标签，应该以某种方式加以利用。本文的问题陈述如下：</p><p>我们致力于<u>基于深度生成模型且具有可靠理论解释的无监督异常检测算法，该算法可以利用偶尔可用的标签</u>。</p><h3 id="Previous-Work"><a href="#Previous-Work" class="headerlink" title="Previous Work"></a>Previous Work</h3><h4 id="传统统计模型"><a href="#传统统计模型" class="headerlink" title="传统统计模型"></a>传统统计模型</h4><p>许多基于传统统计模型的异常检测器（大多是时间序列模型）[6, 17, 18, 24, 26, 27, 31, 40, 41] 已经被提出来计算异常分数。由于这些算法通常对适用的KPI有基本的假设，需要涉及专家的参考才能为给定的KPI选择合适的检测器，然后基于训练数据去微调检测器参数。这些检测器的简单集合（例如多数表决[8]和归一化[35]）不能很好地起作用。</p><h4 id="监督集成方法"><a href="#监督集成方法" class="headerlink" title="监督集成方法"></a>监督集成方法</h4><p>为了规避传统统计异常检测器算法/参数调整的麻烦，提出了有监督的集成方法<strong>EGADS [21]和Opprentice [25]</strong>。 他们使用用户反馈作为标签并使用传统检测器输出的异常评分作为特征来训练异常分类器。 EGADS和Opprentice均显示出令人鼓舞的结果，但它们严重依赖于<strong>良好的标签</strong>（远远超过我们所积累的轶事标签），这在大规模应用中通常不可行。 此外，运行多个传统检测器以在检测期间提取特征会引入大量的计算成本，这是一个实际问题。</p><h4 id="无监督方法与深度生成模型"><a href="#无监督方法与深度生成模型" class="headerlink" title="无监督方法与深度生成模型"></a>无监督方法与深度生成模型</h4><p>最近采用无监督机器学习方法是个趋势。, e.g., one-class SVM [1, 7], clustering based methods [9] like K-Means [28] and GMM [23], KDE [29], and VAE [2] and VRNN [36].  </p><p>其理念是关注正常模式而不是异常：由于KPIs通常主要由正常数据组成，因此即使没有标签也可以轻松地训练模型。 粗略地说，它们都首先识别原始或某些潜在特征空间中的“正常”区域，然后通过测量观测值与正常区域的“距离”来计算异常分数。</p><p>沿着此方向，1，学习正常模式可以看作是学习训练数据的分布，这是生成模型的主题。2，最近在利用深度学习技术训练生成模型方面取得了巨大进展（例如<strong>GAN [13]和深度贝叶斯网络[4，39]</strong>）。后者属于深度生成模型家族，它采用图形graphical[30]模型框架和变分技术[3]，以VAE [16，32]为代表。 3，尽管深度生成模型在异常检测方面具有广阔的前景，但现有的基于VAE的异常检测方法[2]并非为KPIs（时间序列）设计，在我们的设置中效果不佳（请参见§4），并且没有 为其用于异常检测的深度生成模型的设计提供支持的理论基础（请参阅§5）4，简单地采用基于VRNN的更复杂的模型[36]在我们的实验中显示出训练时间长且性能差。5，[2]假定仅对干净数据进行训练，这在我们的上下文中是不可行的。</p><h3 id="变分自动编码器Variational-Auto-Encoder"><a href="#变分自动编码器Variational-Auto-Encoder" class="headerlink" title="变分自动编码器Variational Auto-Encoder"></a>变分自动编码器Variational Auto-Encoder</h3><p>由于VAE是深度贝叶斯网络的基本构建块，因此我们选择开始使用VAE。</p><p><img src="/images/20200313Donut_Figure2_VAE.jpg" alt="20200313Donut_Figure2_VAE"></p><h4 id="VAE的背景"><a href="#VAE的背景" class="headerlink" title="VAE的背景"></a>VAE的背景</h4><p>深度贝叶斯网络使用神经网络来表达变量之间的关系，因此它们不再局限于简单的分布族，因此可以轻松地应用于复杂的数据。 在训练和预测中经常采用变分推理技术[12]，这是由神经网络延伸出的解决后验分布的有效方法。</p><p>VAE是深度贝叶斯网络，它对两个随机变量（潜变量$z$和可见变量$x$）之间的关系进行建模。 为 $z$ 选择一个先验分布，它通常是多元单位高斯分布 $\mathcal{N}(\mathbf{0}, \mathbf{I})$ 。之后，从由参数为 $\theta$ 的神经网络提取出的 $p_{\theta}(\mathbf{x} | \mathbf{z})$ 中采样得到 $x$ 。$p_{\theta}(\mathbf{z} | \mathbf{x})$ 的准确形式由任务需求进行选择。真实的后验 $p_{\theta}(\mathbf{z} | \mathbf{x})$ 是无解析解的，但对于训练是必不可少的，并且通常对预测有用，因此变分推理技术可用于fit另外的神经网络，作为近似后验 $q_{\phi}(\mathbf{z} | \mathbf{x})$。该后验通常被假定为 $\mathcal{N}\left(\boldsymbol{\mu}_{\phi}(\mathbf{x}), \boldsymbol{\sigma}_{\phi}^{2}(\mathbf{x})\right)$ , $\boldsymbol{\mu}_{\phi}(\mathbf{x})$ 与 $\boldsymbol{\sigma}_{\phi}(\mathbf{x})$ 是由神经网络导出。（如图FIgure2）</p><p>SGVB [16, 32] 是一个伴随VAE一起用的变分推断算法，其中通过最大化变分下界evidence lower bound (ELBO Eqn1 ) 来联合训练近似后验模型和生成模型。</p><p>Equation 1:</p><script type="math/tex; mode=display">\begin{aligned} \log p_{\theta}(\mathbf{x}) & \geq \log p_{\theta}(\mathbf{x})-\operatorname{KL}\left[q_{\phi}(\mathbf{z} | \mathbf{x}) \| p_{\theta}(\mathbf{z} | \mathbf{x})\right] \\ &=\mathcal{L}(\mathbf{x}) \\ &=\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{x})+\log p_{\theta}(\mathbf{z} | \mathbf{x})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right] \\ &=\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{x}, \mathbf{z})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right] \\ &=\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{x} | \mathbf{z})+\log p_{\theta}(\mathbf{z})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right] \end{aligned}</script><p>蒙特卡洛积分常常被用于近似 Eqn 1 中的期望。如Eqn 2，$\mathbf{z}^{(l)}, l=1 \ldots L$ 是来自 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 的样例samples。整个本文中，我们都坚持使用这种方法。</p><p>Equation 2：</p><script type="math/tex; mode=display">\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}[f(\mathbf{z})] \approx \frac{1}{L} \sum_{l=1}^{L} f\left(\mathbf{z}^{(l)}\right)</script><h3 id="Architecture结构"><a href="#Architecture结构" class="headerlink" title="Architecture结构"></a>Architecture结构</h3><p>Donut的总体架构如图Figure3，三个关键技术是Modified ELBO，训练时的Missing Data Injection， 检测时的MCMC Imputation。</p><p><img src="/images/20200314Arch_Donut.jpg" alt="20200314Arch_Donut"></p><p><img src="/images/20200314Network_Donut.jpg" alt="20200314Network_Donut"></p><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p>VAE不是一个序列模型，因此我们在KPI上应用长度为 $w$ 的<strong>滑动窗口</strong>[34]。 对于每一个 $x_t$ 使用 $x_{t-W+1}, …, x_{t}$ 作为VAE的 $X$  向量。该滑动窗口由于其简单性而首先被采用，实际上却带来了重要而有益的结果。</p><p>Donut的总体网络结构如图4，其中有双线轮廓的组件 (e.g., Sliding Window x, W Dimensional at bottom left) 是我们的新设计，其余组件来自标准VAEs。先验 $p_{\theta}(z)$ 被选择为 $\mathcal{N}(\mathrm{0}, \mathrm{I})$ 。 x和z后验均选择为对角高斯 diagonal Gaussian：</p><script type="math/tex; mode=display">p_{\theta}(\mathbf{x} | \mathbf{z})=\mathcal{N}\left(\boldsymbol{\mu}_{\mathbf{x}}, \boldsymbol{\sigma}_{\mathbf{x}}^{2} \mathbf{I}\right)</script><script type="math/tex; mode=display">q_{\phi}(\mathbf{z} | \mathbf{x})=\mathcal{N}\left(\boldsymbol{\mu}_{\mathbf{z}}, \boldsymbol{\sigma}_{\mathbf{z}}^{2} \mathbf{I}\right)</script><p>这里的$\mu_x,\mu_z,\sigma_x,\sigma_z$ 是每个独立高斯组件的均值和标准差。 $z$ 是 K 维的。通过分离的隐藏层$f_{\phi}(\mathbf{x}) , f_{\theta}(\mathbf{z})$ ，从 $x$ 和 $z$ 隐藏特征被提取出来。然后从隐藏特征中得出x和z的高斯参数。 </p><p>均值是从线性层导出：</p><script type="math/tex; mode=display">\boldsymbol{\mu}_{\mathbf{X}}=\mathbf{W}_{\boldsymbol{\mu}_{\mathbf{X}}}^{\top} f_{\theta}(\mathbf{z})+\mathbf{b}_{\boldsymbol{\mu}_{\mathbf{X}}}</script><script type="math/tex; mode=display">\boldsymbol\mu_{z}=\mathbf{W}_{\mu_{z}}^{\top} f_{\phi}(\mathbf{x})+\mathbf{b}_{\mu_{z}}</script><p>标准差是从soft-plus层导出，加上一个非负小数 $\epsilon$ ：</p><script type="math/tex; mode=display">\sigma_{\mathrm{x}} = \text{SoftPlus} \left[\mathbf{W}_{\sigma_{x}}^{\top} f_{\phi}(\mathbf{x})+\mathbf{b}_{\sigma_{x}}\right]+\epsilon</script><script type="math/tex; mode=display">\sigma_{\mathrm{z}}=\text{SoftPlus} \left[\mathbf{W}_{\boldsymbol{\sigma}_{\mathbf{z}}}^{\top} f_{\phi}(\mathbf{z})+\mathbf{b}_{\boldsymbol{\sigma}_{\mathbf{z}}}\right]+\boldsymbol{\epsilon}</script><p>这里的 $\text{SoftPlus}[a] = log[exp(a) + 1]$ ，这里介绍的所有W-s和b-s是相应层的参数。 注意，将标量函数 $f(x)$ 应用于向量 $x$ 时，意味着将其应用于每个部分component。</p><p>我们以此种方式导出 $\sigma_x, \sigma_z$ 而非像其他人一样用线性层导出 $log_{\sigma_x}$ 有以下几个原因：我们关注的 KPIs 的局部变化非常小，以至于 $\sigma_x$ 和 $\sigma_z$ 可能变得非常接近于零，从而使 $log_{\sigma_x}$ 和$\log_{\sigma_z}$无界。 在计算高斯变量的可能性时，这将导致严重的数值问题。 因此，我们使用soft-plus和 $\epsilon$ 技巧来防止此类问题。</p><p>我们有意选择全连接层作为隐藏层的结构，从而使整体体系结构相当简单。 这是因为我们的目标是开发具有扎实的理论解释的基于VAE的异常检测算法，并且简单的网络结构无疑将使在复杂的“变分自动编码器”中分析内部行为更加容易。</p><h4 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h4><p>训练直接用SGVB[16] 算法去优化 ELBO (Eqn 1) ，由于[16]报告，当使用SGVB算法训练VAE时，一个样本已经足以计算ELBO，因此在训练期间让采样数$L = 1$。我们还按照SGVB的要求应用了重新参数化技巧：没有采样 $\mathbf{z} \sim \mathcal{N}\left(\boldsymbol{\mu}_{\mathbf{z}}, \boldsymbol{\sigma}_{\mathbf{z}}^{2} \mathbf{I}\right)$ ，专门的随机变量 $\xi \sim \mathcal{N}(0, \mathrm{I})$ 被采样，如此我们重写 $z$ 为 $\mathbf{z}(\boldsymbol{\xi})=\boldsymbol{\mu}_{\mathbf{z}}+\boldsymbol{\xi} \cdot \boldsymbol{\sigma}_{\mathbf{z}}$。$\xi$ 上的采样与参数 $\phi$ 无关，像VAE是普通神经网络一样，这使我们能够应用<strong>随机梯度下降</strong>。$x$ 的窗口在每个epoch之前都会随机打乱，这有利于随机梯度下降。 在每个mini-batch中要获取足够多的 $x$，这对于稳定训练至关重要，因为采样会引入额外的随机性。</p><p>对于某些给定的KPIs这里没有labels，可能会想用合成的值替换训练数据中的标记异常（如果有）和缺失点（已知）。先前的一些工作已经提出了填补缺失数据的方法，例如[37]，但是很难产生足够好地遵循“正常模式”的数据。重要的是，用另一种算法生成的数据训练生成模型是很荒谬的，因为生成模型的一个主要应用就是生成数据。 使用由比VAE更弱的算法估算的数据可能会降低性能。 因此，我们不会在训练VAE之前采用缺失数据插值imputation，而是选择简单地将缺失点填充为零（在图3中的数据准备步骤中），然后修改ELBO（以下简称M-ELBO）以排除异常和缺失点的影响（如图所示）。 如图3中的“训练”步骤。</p><p>更具体地，我们<strong>修改标准的ELBO</strong> （Eqn 1中）为 Eqn 3：</p><script type="math/tex; mode=display">\widetilde{\mathcal{L}}(\mathbf{x})=\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\sum_{w=1}^{W} \alpha_{w} \log p_{\theta}\left(x_{w} | \mathbf{z}\right)+\beta \log p_{\theta}(\mathbf{z})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right]</script><p>其中 $\alpha_w$ 定义为指示值 indicator，当$\alpha_w = 1$ 指示 $x_w$ 不是异常值或缺失值。$\alpha_w = 0$ 反之。$\beta$ 被定义为 $\left(\sum_{w=1}^{W} \alpha_{w}\right) / W$ 。请注意，当训练数据中没有标记的异常时，方程（3）仍然成立。$\alpha_w$ 直接排除了来自标记的异常和缺失点的 $p_{\theta}\left(x_{w} | \mathbf{z}\right)$ 的贡献，而缩放因子 $\beta$ 根据 $x$ 中正常点的比例缩小了 $p_{\theta}(\mathbf{z})$ 的贡献。这种修改使Donut能够正确地重建 $x$ 内的正常点，即使 $x$ 内的某些点异常。我们并没有收缩 $q_{\phi}(\mathbf{z} | \mathbf{x})$ ，因为下面两个考虑：不像 $p_{\theta}(\mathbf{z})$ 是生成模型 （即“正常模式”的模型）中的一部分，$q_{\phi}(\mathbf{z} | \mathbf{x})$ 仅仅描述了从x到z的映射，并未考虑“正常模式”。因此，似乎没有必要去掉 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 的贡献。另一个原因是 $\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right]$ 是 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 的熵。这个熵术语实际上在训练中还有其他作用（将在5.3节中讨论），因此最好保持不变。</p><p>进一步地，我们还在训练中引入了<strong>缺失数据注入</strong>：我们将 $λ$ 比例的正常点随机设置为零，就好像它们是缺失点一样。 缺失点更多，当给定异常 $x$ 时 ，会更频繁地训练Donut来重建正常点，从而增强了M-ELBO的效果。 该注入在每轮  epoch 之前完成，并且在Epoch 结束后恢复点。 图3中的Training步骤显示了这种丢失的数据注入。</p><h4 id="Detection"><a href="#Detection" class="headerlink" title="Detection"></a>Detection</h4><p>与仅为一个目的而设计的判别模型（例如，为仅计算分类概率 $p(y|x)$ 而设计的分类器）不同，像VAE这样的生成模型可以得出各种输出。 在异常检测的范围内，观察窗 $x$ 的可能性（即VAE中的 $p_{\theta}(\mathbf{x})$ ）是重要的输出，因为我们想知道给定的 $x$ 遵循正常模式的程度。可以采用蒙特卡洛方法来计算 $x$ 的概率密度 <script type="math/tex">p_{\theta}(\mathbf{x})=\mathbb{E}_{p_{\theta}(\mathbf{z})}\left[p_{\theta}(\mathbf{x} | \mathbf{z})\right]</script> 。尽管在理论上有很好的解释，但实际上，对先验样本进行采样实际上并不能很好地完成工作，如第4段所示</p><p>与其对先验进行采样，不如通过变分后验 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 来推导有用的输出。一种选择是计算出 $\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[p_{\theta}(\mathbf{x} | \mathbf{z})\right]$ 。尽管与 $p_{\theta}(\mathbf{x})$ 相似，它实际上不是一个定义很好的概率密度。另一种选择是计算在[2] 中采用的 $\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{x} | \mathbf{z})\right]$ ，称为“重建概率”。由于在异常检测中只关注异常评分的顺序而不是确切值，因此我们遵循[2]并使用后者。或者另一个可选项，如[36]所示，ELBO（等式Eqn 1）也可用于近似 $\log p_{\theta}(\mathbf{x})$。然而，在ELBO的另外一项  $\mathbb{E}_{q_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{z})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right]$  使其内部机制难以理解。 由于[36]中的实验不支持该可选方法的优越性，因此我们选择不使用它。</p><p>在检测期间，测试窗口$x$中的异常点和缺失点可能给映射的 $z$ 带来偏差，并进一步使重建概率不准确，这将在5.2节中讨论。 由于缺失点始终是已知的（称为“null”），我们有机会消除缺失点所带来的偏差。 我们选择采用经过训练的VAE的基于MCMC的缺失数据插入imputation技术，该技术由[32]提出。 同时，我们在检测之前不知道异常点的确切位置，因此无法对异常采用MCMC。</p><p>更具体地，测试 $x$ 被划分为观察部分和缺失部分，即 $\left(\mathbf{x}_{o}, \mathbf{x}_{m}\right)$。一个 $z$ 样例从 $q_{\phi}\left(\mathbf{z} | \mathbf{x}_{o}, \mathbf{x}_{m}\right)$ 中获取，然后一个重建样例 $\left(\mathbf{x}_{\boldsymbol{o}}^{\prime}, \mathbf{x}_{m}^{\prime}\right)$ 从 $p_{\theta}\left(\mathbf{x}_{\boldsymbol{o}}, \mathbf{x}_{m} | \mathbf{z}\right)$ 中获取得到。$\left(\mathbf{x}_{o}, \mathbf{x}_{m}\right)$ then由 $\left(\mathbf{x}_{\boldsymbol{o}}, \mathbf{x}_{m}^{\prime}\right)$ 替换，即观察点是固定的，缺失点被设置为新值。  这个过程迭代 M次，然后最终的 $\left(\mathbf{x}_{o}, \mathbf{x}_{m}^{\prime}\right)$ 被用来计算重建概率。在整个过程中，中间值$\mathbf{x}_{m}^{\prime}$会越来越接近正常值。给定足够大的M，可以减少偏差，并且可以获得更准确的重构概率。 MCMC方法在图5中说明，并在图3的“检测”步骤中显示。</p><p><img src="/images/20200314Figure5_MCMC.jpg" alt="20200314Figure5_MCMC"></p><p>MCMC之后，我们取z的L个样本通过蒙特卡洛积分来计算重构概率。 值得一提的是，尽管我们可以计算x的每个窗口中每个点的重建概率，但我们仅使用最后一个点的分数（即$x_t$ 在 $x_{t-T+1}, \ldots, x_{t}$），因为我们想要将在检测过程中尽快归纳异常 。后续文章中我们仍将使用矢量符号，它们与VAE的体系结构相对应。 尽管可以通过延迟决策并在不同时间考虑同一点的更多分数来提高检测性能，但我们将其留作将来的工作。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，Xu H, Chen W, Zhao N, et al. Unsupervised anomaly detection via variational auto-encoder for seasonal kpis in web applications[C]//Proceedings of the 2018 World Wide Web Conference. 2018: 187-196.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ABS-amp-Intro&quot;&gt;&lt;a href=&quot;#ABS-amp-Intro&quot; class=&quot;headerlink&quot; title=&quot;ABS&amp;amp;Intro&quot;&gt;&lt;/a&gt;ABS&amp;amp;Intro&lt;/h3&gt;&lt;h4 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h4&gt;&lt;p&gt;大的互联网公司一般会密切监控KPIs。然而这些有不同模式不同数据质量的季节性KPIs的异常检测很有挑战，特别是无标签。本文中，我们提出了Donut，基于VAE（Variational Auto-Encoder 变分自动编码器）的无监督异常检测算法，其最佳F-score达到0.75 ~ 0.9。我们为Donut的重构提出了一种新颖的KDE解释，使其成为第一种基于VAE的异常检测算法，并且具有扎实的理论解释。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="AnomalyDetection" scheme="http://yoursite.com/tags/AnomalyDetection/"/>
    
  </entry>
  
  <entry>
    <title>Computers&amp;Operations Research部分论文简读</title>
    <link href="http://yoursite.com/2020/03/10/20200310Computers&amp;Operations%20Research%E9%83%A8%E5%88%86%E8%AE%BA%E6%96%87%E7%AE%80%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/03/10/20200310Computers&amp;Operations%20Research%E9%83%A8%E5%88%86%E8%AE%BA%E6%96%87%E7%AE%80%E8%AF%BB/</id>
    <published>2020-03-10T01:58:02.000Z</published>
    <updated>2020-03-18T12:33:20.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Exact-and-heuristic-approaches-to-detect-failures-in-failed-k-out-of-n-systems"><a href="#Exact-and-heuristic-approaches-to-detect-failures-in-failed-k-out-of-n-systems" class="headerlink" title="Exact and heuristic approaches to detect failures in failed k-out-of-n systems"></a>Exact and heuristic approaches to detect failures in failed k-out-of-n systems</h2><h3 id="ABS-amp-Intro"><a href="#ABS-amp-Intro" class="headerlink" title="ABS&amp;Intro"></a>ABS&amp;Intro</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>本文考虑n个系统中k个故障了（表决系统），相应的测试每个组件是有成本的。另外，我们具有某些组件是故障的原因的先验概率信息。目标是以最小的预期成本去识别导致故障的那部分组件。</p><a id="more"></a><h4 id="本文工作"><a href="#本文工作" class="headerlink" title="本文工作"></a>本文工作</h4><p>提出了精确与近似的策略，在故障表决系统（k-out-of-n）中检测组件状态。我们提出两种整数规划编程公式，两种基于Markov决策过程（MDP）的新颖方法以及两种启发式算法。展示了精确式算法的限制以及启发式算法在随机产生的测试例子的有效性。尽管CPU时间更长，整数规划更灵活地整合更多约束 restriction，例如必要时进行测试优先级关系。数值结果表明，针对所提出的MDP模型进行动态编程是最有效的精确方法，在一小时内最多可解决12个组件。 针对小到中级测试实例，启发式算法的性能是对比精确式算法给的，并针对高级测试实例给出下限。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>系统越来越复杂，组件、感应器，子系统越来越多。为了系统更加可靠，系统中总会有冗余存在。当组件故障时，整个系统也可能fail，需要尽快恢复。两个主要问题：(1) 是否系统工作和失败（序列测试问题） (2) 故障原因（failure detection故障检测问题）。在这两种问题中，可行的解决方法可以被描述为二分决策树，目标是最小化期望成本。</p><p>difference区别：故障检测问题中测试结果的概率随着测试执行而变化。但在序列测试问题中则是不变的。另一个区别是，在故障检测问题中，输出是导致故障的一组组件，而在序列测试问题中，输出是系统正在运行或发生故障的信息以及该状态的证明。</p><h4 id="研究综述"><a href="#研究综述" class="headerlink" title="研究综述"></a>研究综述</h4><p>序列测试问题和故障检测问题：Chang 研究在序列测试的上下文中以最小的成本诊断电子晶体，并提供多项式时间的精确式算法。B K 提出了表决系统以在核反应堆子系统中提供冗余，以实现可靠的运行。W提出当测试不完美并且测试有优先限制时的启发式算法。Ba分析某些维护策略的长期平均成本。Gar蚁群优化算法用于计算机网络中的故障定位。</p><p>故障检测问题的灵异研究领域：离散搜索问题，旨在找到隐藏在N个盒子中的一个item，并且其预期成本最小。检查盒子会很昂贵，并且已知该item在盒子内的概率是先验的。K对搜索问题提出最优贪心算法，当仅可能出现假阳性结果时。W&amp;D考虑一个变体，当存在简单的优先级约束并且路径依赖关系由组活动定义时。</p><h4 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h4><p>1，我们引入和研究了k-out-of-n系统的故障检测问题，将文献中研究的n-out-of-n系统归纳了下来。</p><p>2，我们提供了四种精确的两种启发式方法来解决该问题，并提供了两种下限lower bound方案，用于在较大的情况下进行基准测试。</p><p>3，首次提出整数规划建模和马尔可夫决策过程来解决此类问题。</p><p>4，我们进行数值实验以评估不同方法的有效性。</p><p>（暂时了解背景和introduction，未读完）</p><h2 id="A-survey-of-models-and-algorithms-for-emergency-response-logistics-in-electric-distribution-systems-Part-I-Reliability-planning-with-fault-considerations"><a href="#A-survey-of-models-and-algorithms-for-emergency-response-logistics-in-electric-distribution-systems-Part-I-Reliability-planning-with-fault-considerations" class="headerlink" title="A survey of models and algorithms for emergency response logistics in electric distribution systems. Part I: Reliability planning with fault considerations"></a>A survey of models and algorithms for emergency response logistics in electric distribution systems. Part I: Reliability planning with fault considerations</h2><h3 id="ABS-amp-Intro-1"><a href="#ABS-amp-Intro-1" class="headerlink" title="ABS&amp;Intro"></a>ABS&amp;Intro</h3><p>配电系统的应急响应设计一系列在可靠性和应急计划级别的决策问题。这些操作包括故障诊断，故障定位，故障隔离，恢复和修复。本文回顾了针对与配电运行相关的故障考虑的可靠性规划问题的优化模型和解决方法。本文对确定配电变电站单故障容量，重新分配超负荷，配置配电系统，将地理区域划分为服务区域以及定位物料仓库和仓库的研究进行了调查。</p><p>规划应急响应的操作涉及许多决策问题，可以使用运筹学方法论来解决。 故障情况可能会导致配电系统服务中断的“极端”状态，从而降低服务质量并给电力公司造成经济损失。eg 2008年1月在中国中东部和南部地区的暴风雪使几个省的电线和电线杆倒塌，影响了中国近三分之二的土地，估计造成了100亿美元的直接经济损失。但应急分配响应研究少。</p><p>由于网络拓扑结构，操作能力和应用的操作设备等特性的差异，规划人员面临的问题非常复杂，并且因地而异。 在过去的二十年中，文献中已经出现了越来越多的运筹学应用程序用于应急分配响应。配电系统中涉及的大量组件，配电网络的复杂性以及公用事业运营这些网络的能力不断提高，所有这些都促使人们在配电公用事业的各个层面上使用优化技术。</p><h2 id="Application-of-Optimized-Machine-Learning-Techniques-for-Prediction-of-Occupational-Accidents"><a href="#Application-of-Optimized-Machine-Learning-Techniques-for-Prediction-of-Occupational-Accidents" class="headerlink" title="Application of Optimized Machine Learning Techniques for Prediction of Occupational Accidents"></a>Application of Optimized Machine Learning Techniques for Prediction of Occupational Accidents</h2><h3 id="ABS-amp-Intro-2"><a href="#ABS-amp-Intro-2" class="headerlink" title="ABS&amp;Intro"></a>ABS&amp;Intro</h3><p>机器学习在职业安全领域中预测事故的探索几乎是新的。但基于ML方法的算法在参数合理调整优化之前并不能得到最佳性能。更进一步，此外，仅选择高效的优化分类器可能无法满足总体决策目的，因为它无法解释事故发生背后的因素之间的相互关系。因此，除了预测之外，还需要从事故数据中提取决策规则。</p><p>考虑到上述问题，在这项研究中，使用职业事故数据occupational accident data，已优化的机器学习算法来已经被应用于预测事故后果，例如伤害，差错和财产损失。使用了两种流行的机器学习算法，即支持向量机（SVM）和人工神经网络（ANN），其参数通过两种强大的优化算法进行了优化，<strong>即遗传算法（GA）和粒子群优化（PSO）</strong>，以实现更高的准确性和鲁棒性。基于PSO的SVM具有最高的准确性和鲁棒性，优于其他算法。此外，<strong>通过将决策树C5.0算法与基于PSO的SVM模型相结合来提取规则</strong>。最后，提取了一组九个有用的规则，以识别造成伤害，near miss差错和财产损失案件的根本原因。提出了一个钢铁厂的案例研究case study，以揭示该方法的潜力和有效性。</p><p>简介：全球每年约有230万工人死于职业事故和疾病，其中包括约36万致命事故[1]。事故的根本原因是不安全的情况或不安全的行为，或两者兼有。造成事故的因素有很多。文献中有许多理论可以解释事故的因果关系。 Khanzode等 [5]解释了他们在事故背后的各种研究理论，例如事故倾向性理论[6]，多米诺骨牌理论[7]，伤害流行病学[8]，系统理论[9]，社会技术系统理论[10]和宏观人机工程学理论[11]。由于一系列事件或因果关系的存在，导致发生伤害事件。如果知道原因，则可以预测结果（即事故）。另外，预测模型将量化各种因果因素对事故发生的贡献。</p><p>ML用于预测模型很广泛。然而，ML技术用于职业事件分析还是有限的 limited biasis。至今，关于职业分析的研究展示了基于机器学习技术的预测能力[14]和解释能力[15]。这些方法基于事件报告中的历史数据或与员工进行的访谈，可确保它们在预测功能和影响事件结果的预测变量的重要性方面优于常规统计数据。</p><p>本文：</p><p>本研究的主要目标是使用机器学习技术（即SVM和ANN）开发预测模型，以预测职业事故的后果。 为了获得更好的精度，在分类器上采用了优化技术，即GA和PSO。 此外，基于PSO-SVM、结合决策树（C5.0）的分类器对伤害injury的发生提取规则。 次要目标包括使用卡方特征选择技术识别可归因于事件结果的相关变量。 分析结果显示了SVM分类器在预测以及规则提取目的方面的效用。</p><h3 id="文献综述"><a href="#文献综述" class="headerlink" title="文献综述"></a>文献综述</h3><p>在职业事件预测中，许多机器学习算法如SVM，ANN，Extreme Learning machine（极限学习机）与决策树等。在DT在事故分析中的应用中，通常使用C4.5，C5.0分类和回归树（CART）分析，卡方自动交互检测器（CHAID）等算法来预测职业事故。使用DT的主要目的是预测和解释数据中的定性和定量模式，从而对隐藏信息探索。 由于对属性分布或属性独立性假设的放宽，DTs已成功应用于医学[17]，社会科学[18]，业务管理[19]，建筑工程与管理[20]，过程等不同领域 工业[13]。</p><p>除了DTs，神经网络，贝叶斯分类器，自适应神经模糊推理系统（ANFIS），贝叶斯网络，支持向量机，extreme learning machine (ELM) 被用于不同的领域。eg：He等。试图通过使用ANN的后向算法（BA-ANN）和指数评估方法（EEM）的分类技术解决煤与瓦斯突发问题[24]。使用BAANN，针对响应变量（即煤和瓦斯突发）计算因子的权重。Yi等人他们收集了550份与工作，环境和个人有关的数据，并由ANN进行了分析，以预测建筑工地工人的感知劳累（RPE）等级。</p><p>以上机器学习方法都要调整参数。为了调整分类算法的参数，发现优化方法比其他技术（如手动调整或网格搜索）最有用。从其他领域的研究可以看出，为了提高SVM模型的准确性，可以考虑优化惩罚因子（c）和内核参数 r [27]。有许多优化技术用于这个目的像遗传算法（GA），粒子群优化（PSO），梯度下降法等[28]。其中，GA和PSO被认为是最优化分类器参数（例如SVM）以实现更高准确度的方法[29]。使用基于GA算法的反向传播神经网络（BPNN）的初始参数，网络拓扑，权重和阈值[30]。 </p><p>分类器不仅取决于参数，还取决于数据类型。数值属性比类别属性或纯文本属性有更多信息。事故领域中的大多数文献都使用数值数据或类别数据来分析事故场景。 对纯文本数据的分析仍未得到充分利用，因为从纯文本中提取模式是一项艰巨的任务。 叙事文本是预测事故的关键资源之一。 它提供了分析中有价值的附加信息以及其他类型的数据。如布朗所做的一个值得注意的贡献是使用与潜在狄利克雷分配（LDA）和随机森林[35]等其他技术相关的文本挖掘来分析铁路事故数据，以探索事故背后的主要因素。在道路事故分析中，Pereira等人进行了一项研究。使用交通事件报告的主题建模来实时提取信息以预测事件持续时间[40]。</p><p>从事故数据集中提取规则及其解释通常被认为是一种有效的方法。通常可以使用决策树（DT）或关联规则挖掘（ARM）方法获得规则。在一些职业事故研究中，DT已比ARM更多地用于规则提取和解释。当目标函数是离散值，属性值对可描述目标函数或对数据集进行噪声训练时，发现DT很有用。还尝试过带有SVM的DT算法，以将SVM决策的黑匣子变成透明且可理解的规则，这些规则可用作任何决策任务的第二意见。</p><h3 id="本文研究关键"><a href="#本文研究关键" class="headerlink" title="本文研究关键"></a>本文研究关键</h3><p>1，将文本数据与非文本数据用于事件预测</p><p>2，分类器的参数优化，以获得更好的预测准确率</p><p>3，少有基于SVM的规则提取用于事件发生的研究</p><h2 id="Application-of-SVM-and-ANN-for-intrusion-detection"><a href="#Application-of-SVM-and-ANN-for-intrusion-detection" class="headerlink" title="Application of SVM and ANN for intrusion detection"></a>Application of SVM and ANN for intrusion detection</h2><h3 id="ABS-amp-Intro-3"><a href="#ABS-amp-Intro-3" class="headerlink" title="ABS &amp; Intro"></a>ABS &amp; Intro</h3><p>两种数据挖掘技术，ANNs 人工神经网络和支持向量机。两种编码方式，，基于简单频率的方案和tf×idf方案，来检测潜在的系统入侵。我们的结果展示采用TF-IDF方案的SVM性能最佳，而基于简单频率方案的ANN表现最差。实验中使用的数据是麻省理工学院林肯实验室的DARPA 1998入侵检测评估计划的BSM审核数据。</p><p>简介：电子商务和最近的在线消费者热潮迫使对共享网络上的系统的基本计算机安全设计进行更改。 现在设计的系统具有更高的灵活性和更少的屏障安全性。 此外，随着计算机在金融上越来越普及给大众，它们也越来越以消费者为导向。 用户友好性和公共可访问性的结合，尽管对普通人有利，但不可避免地使交换的信息容易受到犯罪分子的攻击。 存储在内部数据仓库中的消费者信息，员工数据或知识产权受到外部攻击者和不满员工的威胁，他们可能会滥用访问权限谋取私利。由于软件应用程序中隐藏的弱点和错误bug，安全策略或防火墙很难阻止此类攻击。 此外，黑客不断发明新的攻击并通过Internet进行传播。</p><p> 入侵检测系统可以检测，识别并响应未经授权的或异常的活动，具有缓解或防止此类攻击的潜力。 因此，security breech是Internet社区日益关注的一个领域[2]。</p><p>大多数研究人员（请参见表1）使用简短的系统调用序列来表征程序行为。少部分使用系统调用的频率分布。与基于序列的编码技术相比，基于频率的编码技术所需的开销更少，基于序列的编码技术需要为每个程序构建一个文件（例如，必须为sendmail或lpr 1构建一个文件），并在每个时间帧检查攻击 。 基于频率的编码技术仅为每个进程而不是每个程序（一个进程可能包含多个程序）建立一个配置文件，并在该过程结束时检查攻击实例。 </p><p>在这项研究中，我们探索了应用人工神经网络（ANN）和支持向量机（SVM）预测基于基于频率的编码技术的攻击的可行性。使用ANN和SVM进行攻击检测的目的是从有限的训练数据中发展泛化能力。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，Yavuz T, Kundakcioglu O E, Ünlüyurt T. Exact and heuristic approaches to detect failures in failed k-out-of-n systems[J]. Computers &amp; Operations Research, 2019, 112: 104752.</p><p>2，A survey of models and algorithms for emergency response logistics in electric distribution systems. Part I: Reliability planning with fault considerations</p><p>3，Application of Optimized Machine Learning Techniques for Prediction of Occupational Accidents</p><p>4，Application of SVM and ANN for intrusion detection （Wun-Hwa Chen, Sheng-Hsun Hsu∗, Hwang-Pin Shen）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Exact-and-heuristic-approaches-to-detect-failures-in-failed-k-out-of-n-systems&quot;&gt;&lt;a href=&quot;#Exact-and-heuristic-approaches-to-detect-failures-in-failed-k-out-of-n-systems&quot; class=&quot;headerlink&quot; title=&quot;Exact and heuristic approaches to detect failures in failed k-out-of-n systems&quot;&gt;&lt;/a&gt;Exact and heuristic approaches to detect failures in failed k-out-of-n systems&lt;/h2&gt;&lt;h3 id=&quot;ABS-amp-Intro&quot;&gt;&lt;a href=&quot;#ABS-amp-Intro&quot; class=&quot;headerlink&quot; title=&quot;ABS&amp;amp;Intro&quot;&gt;&lt;/a&gt;ABS&amp;amp;Intro&lt;/h3&gt;&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;本文考虑n个系统中k个故障了（表决系统），相应的测试每个组件是有成本的。另外，我们具有某些组件是故障的原因的先验概率信息。目标是以最小的预期成本去识别导致故障的那部分组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="故障检测" scheme="http://yoursite.com/tags/%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B/"/>
    
      <category term="Operation Research" scheme="http://yoursite.com/tags/Operation-Research/"/>
    
  </entry>
  
  <entry>
    <title>排序算法复习</title>
    <link href="http://yoursite.com/2020/03/10/20200309%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/03/10/20200309%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-03-10T01:06:57.000Z</published>
    <updated>2020-03-28T10:11:00.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>排序算法在搜索中常用，因此非常重要。排序算法里包含了重要的分治的思想，就是在划分子问题上。归并排序将数据折半划分，快速排序将数据分成大数和小数部分，基数排序则每次都会按照关键码中的一个数字划分数据。</p><p>什么是稳定的排序：如果一种排序算法不会改变关键码值相同的记录的相对顺序，则称为稳定的。</p><h4 id="三种基本的排序算法"><a href="#三种基本的排序算法" class="headerlink" title="三种基本的排序算法"></a>三种基本的排序算法</h4><a id="more"></a><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>例子：每处理一次数据就把它和前面已经排序的子序列进行比较，再将它插入到前面的正确位置。算法里的Comp类要自己写，实现关键码比较大小，如int就直接比较大小，其他类别比较大小等等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inssort</span><span class="params">(E A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i; (j&gt;<span class="number">0</span>)&amp;&amp;(Comp::prior(A[j],A[j<span class="number">-1</span>])); j--)</span><br><span class="line">swap(A, j, j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(array)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(array)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> array[j] &lt; array[j<span class="number">-1</span>]:</span><br><span class="line">array[j],array[j<span class="number">-1</span>] = array[j<span class="number">-1</span>],array[j] <span class="comment"># change the elem</span></span><br></pre></td></tr></table></figure><p>这里最差的情况是每条记录都必须移动到最前面（如 array = [3,2,1,0])，空间复杂度由于并没有用其他临时数组，所以还是 $O(1)$，此时时间复杂度：</p><script type="math/tex; mode=display">\sum_{i=2}^n i \approx n^2/2 = \Theta(n^2)</script><p>最佳情况就是每条记录都已经是有序的了，进入内部for循环就退出，于是此时的时间代价是 $\Theta(n)$</p><p>平均情况根据逆置来判断，逆置的数值（即数组中位于一个给定值之前的比它大的值的数目）决定比较与交换的次数。平均情况下，在数组的前i-1条记录中有一半关键码值比第i条记录的关键码值大。平均情况下，时间代价是最差情况的一半 $\Theta(n^2/4)$， 是稳定排序。</p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>例子：气泡冒上来的过程。从最后开始，比较相邻的，如果前面的比它大则交换。就像气泡逐渐被推到数组的顶部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubsort</span><span class="params">(E A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;i; j--)</span><br><span class="line">      <span class="keyword">if</span>(Comp::prior(A[j],A[j<span class="number">-1</span>]))</span><br><span class="line">        swap(A,j,j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(array)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(array)<span class="number">-1</span>):</span><br><span class="line">flag = <span class="number">0</span>  <span class="comment"># trace the exchange times</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)<span class="number">-1</span>,i,<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> array[j] &lt; array[j<span class="number">-1</span>]:</span><br><span class="line">array[j], array[j - <span class="number">1</span>] = array[j - <span class="number">1</span>], array[j]</span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>):</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>内层的for循环比较次数总会是 i，因此最差时间代价是：$\sum_{i=1}^n i \approx n^2/2 = \Theta(n^2)$ ，平均也是类似插入排序$\Theta(n^2)$，它是稳定的排序。</p><p>修改冒泡排序以跟踪其执行的交换次数。 如果数组已经按排序顺序排列，并且冒泡排序不进行交换，则算法可以在经过一遍后终止。在最佳情况下复杂度是 $\Theta(n)$ 。</p><p>冒泡排序相对于大多数其他算法（甚至是快速排序，但不是插入排序）具有的唯一显着优势是，该算法内置了检测列表是否被有效排序的功能。</p><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>选择排序就是选择数组中第i小的记录，并把该记录放到数组的第i个位置上，只需一次交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selsort</span><span class="params">(E A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> lowindex = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;i ; j--)</span><br><span class="line">      <span class="keyword">if</span>(Comp::prior(A[j], A[lowindex]))</span><br><span class="line">        lowindex = j;</span><br><span class="line">    swap(A,i,lowindex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(array)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(array)<span class="number">-1</span>):</span><br><span class="line">lowindex = i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> array[j] &lt; array[lowindex]:</span><br><span class="line">lowindex = j</span><br><span class="line">array[i], array[lowindex] = array[lowindex], array[i]</span><br></pre></td></tr></table></figure><p>比较的次数是 $\Theta(n^2)$ ，但交换的次数比冒泡排序少很多，对于那些做交换花费时间多的问题是更好的。</p><h3 id="改进的排序"><a href="#改进的排序" class="headerlink" title="改进的排序"></a>改进的排序</h3><h4 id="shellsort"><a href="#shellsort" class="headerlink" title="shellsort"></a>shellsort</h4><p>它在不相邻的记录之间进行比较与交换。shell排序利用了插入排序的最佳时间代价特性。他将序列分成多个子序列，然后分别对子序列进行排序，最后将子序列组合起来。由于实现了元素的跳跃式移动，使排序效率提高。如下图：图中的增量序列就是8，4，2，1。最后一轮将是一次“正常的”插入排序，因为此时序列整体基本上有序，故用插入排序的复杂度相对较小。</p><p>shellsort增量选择3的时候，效果较好，平均运行时间复杂度是$\Theta(n^{1.5})$ 。 </p><p>相同的元素可能在各自的插入排序中移动， 是不稳定排序。在中等大小规模的数据上表现良好。</p><p><img src="/images/20200310shellsort.jpg" alt="20200310shellsort"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shellsort</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insort</span><span class="params">(E A[],<span class="keyword">int</span> n, <span class="keyword">int</span> increment)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=increment; i&lt;n; i+=increment) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; (j&gt;=increment)&amp;&amp;(A[j]&lt;A[j-increment]); j-=increment) &#123;</span><br><span class="line">            E temp = A[j];</span><br><span class="line">            A[j] = A[j-increment];</span><br><span class="line">            A[j-increment] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(E A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n/<span class="number">2</span>; i&gt;<span class="number">2</span>; i/=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            insort&lt;E&gt;(&amp;A[j], n-j, i);<span class="comment">//A[j] is the start address  偏移，巧妙</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insort&lt;E&gt;(A, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">16</span>] = &#123;<span class="number">59</span>,<span class="number">20</span>,<span class="number">17</span>,<span class="number">13</span>,<span class="number">28</span>,<span class="number">14</span>,<span class="number">23</span>,<span class="number">83</span>,<span class="number">36</span>,<span class="number">98</span>,<span class="number">11</span>,<span class="number">70</span>,<span class="number">65</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    shellsort&lt;<span class="keyword">int</span>&gt;(num, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n:num) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(array):</span><br><span class="line">n = len(<span class="built_in">array</span>)</span><br><span class="line">gap = n <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> i in range(gap,n):</span><br><span class="line">temp = <span class="built_in">array</span>[i]</span><br><span class="line">j = i</span><br><span class="line"><span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> <span class="built_in">array</span>[j-gap] &gt; temp:</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j-gap]</span><br><span class="line">j-=gap</span><br><span class="line"><span class="built_in">array</span>[j] = temp</span><br><span class="line">gap <span class="comment">//= 2</span></span><br></pre></td></tr></table></figure><h4 id="mergesort"><a href="#mergesort" class="headerlink" title="mergesort"></a>mergesort</h4><p>来源于分治的思想，在排序问题上分治的思想体现在把待排序的列表分成片段，先处理片段，然后将片段重组。</p><p>伪代码的提现其思想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List mergesort(List inlist)&#123;</span><br><span class="line">if(inlist.length() &lt;= 1) return inlist;</span><br><span class="line">List L1 = half of the list;</span><br><span class="line">List L2 = other half of the list;</span><br><span class="line">return mergesort(mergesort(L1),mergesort(L2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/20200310Merge-Sort.png" alt="20200310Merge-Sort"></p><p>当输入的待排序数据存储在链表中时，归并排序是一个很好的选择。</p><p>两个指针，最初分别为两个已经排序序列的起始位置。比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。重复直到某一指针达到序列尾，剩下的元素直接放入到合并的片段里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(E A[],E temp[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    mergesort&lt;E&gt;(A, temp, left, mid);</span><br><span class="line">    mergesort&lt;E&gt;(A, temp, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">//then merge, temp[] is the auxiliary array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=left; i&lt;=right; i++) &#123;</span><br><span class="line">        temp[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i1 = left;</span><br><span class="line">    <span class="keyword">int</span> i2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> curr=left; curr&lt;=right; curr++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i1 == mid+<span class="number">1</span>) A[curr] = temp[i2++]; <span class="comment">//left all &lt; right</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i2 &gt; right) A[curr] = temp[i1++]; <span class="comment">//right all &lt; left</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp[i1] &lt; temp[i2]) A[curr] = temp[i1++];<span class="comment">// smaller one is put into A</span></span><br><span class="line">        <span class="keyword">else</span> A[curr] = temp[i2++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">16</span>] = &#123;<span class="number">59</span>,<span class="number">20</span>,<span class="number">17</span>,<span class="number">13</span>,<span class="number">28</span>,<span class="number">14</span>,<span class="number">23</span>,<span class="number">83</span>,<span class="number">36</span>,<span class="number">98</span>,<span class="number">11</span>,<span class="number">70</span>,<span class="number">65</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    mergesort&lt;<span class="keyword">int</span>&gt;(num, temp, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n:num) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当被排序元素的数目是n时，递归的深度是$logn$ ，第一层递归是对长度为n的数组排序，下一层是对2个长度为n/2的子数组排序……，在所有$logn$ 层递归中，每一层都需要$\Theta(n)$ 时间代价，因此总时间代价都是$n log(n)$。</p><p>python版本代码可以参考<a href="https://www.geeksforgeeks.org/python-program-for-merge-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/python-program-for-merge-sort/</a></p><h4 id="quicksort"><a href="#quicksort" class="headerlink" title="quicksort"></a>quicksort</h4><p>快速排序不需要额外的空间，典型应用是Unix系统调用库里的qsort函数。快速排序选定一个轴值，数组在小于轴值的放在左边，大于的放在右边。这被称为数组的一个划分 partition。快速排序最差情况是当轴值每次都不能把数组划分得很好，下一次处理子问题规模只比原来的问题规模减少1，时间代价是$\Theta(n^2)$ ，最佳和平均复杂度是$\Theta(n logn)$ 。</p><p>快排为什么这么快？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>&amp; pivot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(A[++l] &gt; pivot); <span class="comment">//move the index</span></span><br><span class="line">        <span class="keyword">while</span>((l&lt;r) &amp;&amp; (A[--r] &lt; pivot));</span><br><span class="line">        swap(A,l,r);</span><br><span class="line">    &#125;<span class="keyword">while</span>(l&lt;r);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myqsort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = (i+j)/<span class="number">2</span>; <span class="comment">//这里可以写一个findpivot函数，三者取中（三个随机值的中间）</span></span><br><span class="line">    swap(A,pivotIndex,j);</span><br><span class="line">    <span class="keyword">int</span> k = partition(A,i<span class="number">-1</span>,j,A[j]); <span class="comment">//k is the start of the left half</span></span><br><span class="line">    swap(A,k,j);<span class="comment">// 轴值就在k位置，就是最终排序好的数组中的位置</span></span><br><span class="line">    myqsort(A,i,k<span class="number">-1</span>);</span><br><span class="line">    myqsort(A,k+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的改进可以从pivotIndex的设置，以及递归到一个较小的数组的时候采用插入排序（基本有序的小数组很适合）等。</p><p>Python版本：更清晰一点，把轴值设置为左边第一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(array, left, right)</span>:</span></span><br><span class="line"><span class="keyword">if</span> left &gt;= right:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">low = left</span><br><span class="line">high = right</span><br><span class="line">key = array[low]</span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line"><span class="keyword">while</span> left &lt; right <span class="keyword">and</span> array[right] &gt; key:</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line">array[left] = array[right]</span><br><span class="line"><span class="keyword">while</span> left &lt; right <span class="keyword">and</span> array[left] &lt;= key:</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">array[right] = array[left]</span><br><span class="line">array[right] = key</span><br><span class="line"></span><br><span class="line">quick_sort(array, low, left - <span class="number">1</span>)</span><br><span class="line">quick_sort(array, left + <span class="number">1</span>, high)</span><br></pre></td></tr></table></figure><h4 id="heapsort"><a href="#heapsort" class="headerlink" title="heapsort"></a>heapsort</h4><p>堆是一棵完全二叉树，可以用数组来实现。参考 <a href="[https://saruagithub.github.io/2020/03/28/20200328%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86/](https://saruagithub.github.io/2020/03/28/20200328数组实现堆/">数组实现堆</a>)</p><p>堆可以用来排序</p><p>计数排序</p><p>桶排序</p><p>基数排序</p><h3 id="内嵌算法"><a href="#内嵌算法" class="headerlink" title="内嵌算法"></a>内嵌算法</h3><h4 id="timsort"><a href="#timsort" class="headerlink" title="timsort"></a>timsort</h4><p>这是Python的内嵌排序算法。</p><p><img src="/Users/wangxue/gitpro/20191105MyBlog/saruagithub/source/images/20200310Allsort.jpg" alt="20200310Allsort"></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，《数据结构与算法分析》 Clifford A. Shaffer 等</p><p>2，<a href="[https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F](https://baike.baidu.com/item/希尔排序">百度百科</a>)</p><p>3， <a href="https://www.jiqizhixin.com/articles/2018-11-20-3" target="_blank" rel="noopener">机器之心 Timsort</a></p><p>4，<a href="https://www.geeksforgeeks.org/python-program-for-merge-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/python-program-for-merge-sort/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h3&gt;&lt;p&gt;排序算法在搜索中常用，因此非常重要。排序算法里包含了重要的分治的思想，就是在划分子问题上。归并排序将数据折半划分，快速排序将数据分成大数和小数部分，基数排序则每次都会按照关键码中的一个数字划分数据。&lt;/p&gt;&lt;p&gt;什么是稳定的排序：如果一种排序算法不会改变关键码值相同的记录的相对顺序，则称为稳定的。&lt;/p&gt;&lt;h4 id=&quot;三种基本的排序算法&quot;&gt;&lt;a href=&quot;#三种基本的排序算法&quot; class=&quot;headerlink&quot; title=&quot;三种基本的排序算法&quot;&gt;&lt;/a&gt;三种基本的排序算法&lt;/h4&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>DFS与BFS算法</title>
    <link href="http://yoursite.com/2020/02/28/20200228DFS%E4%B8%8EBFS%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/28/20200228DFS%E4%B8%8EBFS%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-28T08:15:28.000Z</published>
    <updated>2020-03-18T14:19:31.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>深度优先搜索从某个状态开始，不断的转移状态直到无法转移，然后回退到前一步的状态。执行的过程其实是跟栈有关，因为暂时没有执行的部分会被存放到堆栈里。直白点就是一条道走到黑，然后再逐步掉头，继续走到头。</p><p>一般要注意算法停止条件。迭代过程分析。</p><h3 id="2-DFS类题目"><a href="#2-DFS类题目" class="headerlink" title="2 DFS类题目"></a>2 DFS类题目</h3><h4 id="部分和问题"><a href="#部分和问题" class="headerlink" title="部分和问题"></a>部分和问题</h4><p>给定整数$a_{1}, a_{2}, \cdots, a_{n}$ ，判断能否可以从中选出若干数，使他们的和恰好为$k$</p><a id="more"></a><p>例如：输入 n = 4, a = {1,2,4,7} , k=13</p><p>Yes (13 = 2 + 4 + 7)</p><p>分析：首先要考虑所有数字的组合情况，判断组合的加和是否等于k，典型的搜索过程，用DFS。转移过程就是先一直往左到底，然后在倒回去一步走 dfs(i+1, sum+a[i])  加上a[i] 。</p><p>如下图，整个DFS的展开如黑色，红色是执行过程：</p><p><img src="/images/20200228Dfs1.jpg" alt="20200228_dfs1"></p><p>深度优先搜索就是从最开始的状态出发，遍历所有可以达到的状态。由此可以对所有的状态进行操作或者列举出所有的状态。DFS在设计的时候要考虑停止条件（i==n），搜索的结果变量 sum等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[max_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == n)</span><br><span class="line">        <span class="keyword">return</span> sum==k; <span class="comment">// all nums have been used</span></span><br><span class="line">    <span class="keyword">if</span>(dfs(i+<span class="number">1</span>, sum))  <span class="comment">//not add a[i]</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(dfs(i+<span class="number">1</span>, sum+a[i])) <span class="comment">// add a[i]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"input n:"</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dfs(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Yes!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="延伸-leecode39题"><a href="#延伸-leecode39题" class="headerlink" title="延伸 leecode39题"></a>延伸 leecode39题</h5><p>给定一个无重复元素的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的数字可以无限制重复被选取。（这里与上一题的不同在于数字可以重复选取，并且要存所有组合的结果）</p><p>分析：组合、搜索问题首先需要画出树形图，代码根据树形图写出来。</p><p>如输入: <code>candidates = [2, 3, 6, 7]</code>，<code>target = 7</code>，所求解集为: <code>[[7], [2, 2, 3]]</code>。</p><p>我自己的思路：首先k控制DFS的深度，sum判断每次加和结果，last存上一个candidate的值，从而在每次下一层的时候避免重复选择之前选过的小的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意last控制去重</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_addSum1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> k, <span class="keyword">int</span> sum, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        res.push_back(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &lt; last) <span class="keyword">break</span>;</span><br><span class="line">        v.push_back(candidates[i]);</span><br><span class="line">        dfs_addSum1(candidates,res,target,v,k+<span class="number">1</span>,sum+candidates[i],candidates[i]);</span><br><span class="line">        v.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum1(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    dfs_addSum1(candidates,res,target,v, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span> ); <span class="comment">// 0 means level, 0 is temp_sum, 0 is the last val</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种答案的思路是根据remain 从最开始的target减去candidate里的剩余数字。last变量这里很巧，这样每次就从比之前的数字更大的数字去选择。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_addSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v,<span class="keyword">int</span> remain, <span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    res.push_back(v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(remain &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = last; i &lt; candidates.<span class="built_in">size</span>(); i++)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    v.push_back(candidates[i]);</span><br><span class="line">    dfs_addSum(candidates,res,v, remain - candidates[i], i);</span><br><span class="line">    v.pop_back();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">  dfs_addSum(candidates,res,v,target, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h4><p>leecode17题：给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>对应关系如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; table&#123;</span><br><span class="line">    &#123;<span class="string">'0'</span>, <span class="string">" "</span>&#125;, &#123;<span class="string">'1'</span>,<span class="string">"*"</span>&#125;, &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;, &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;,&#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>如，给定输入”23”，输出是[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p><p>分析：根据数字，组合数字的字母，也是一个全部搜索的过程。停止条件是当字符串不断拼接直到长度与输入的数字个数一致。 变量有res （即最后输出），str变量用来存拼接字符，k控制深度。（另外两个参数digits与hash其实是相当于默认参数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res,<span class="built_in">string</span> str,<span class="built_in">string</span>&amp; digits,<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;&amp;hash, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// stop condition, str 不断拼接，直到与给的数字长度相同</span></span><br><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">size</span>() == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">        res.push_back(str);<span class="comment">//添加到结果里</span></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//递归深入完毕，退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> temp = hash[digits[k]];<span class="comment">//k代表每层</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> w:temp)&#123;</span><br><span class="line">        str += w; <span class="comment">// 添加一个字符</span></span><br><span class="line">        dfs(res, str, digits, hash, k+<span class="number">1</span>); <span class="comment">//继续向下搜索</span></span><br><span class="line">        str.pop_back();<span class="comment">//去掉末尾字符向上走（回溯）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits)&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; table&#123;</span><br><span class="line">    &#123;<span class="string">'0'</span>, <span class="string">" "</span>&#125;, &#123;<span class="string">'1'</span>,<span class="string">"*"</span>&#125;, &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;, &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;,&#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="string">""</span>) <span class="keyword">return</span> result;</span><br><span class="line">    dfs(result,<span class="string">""</span>,digits,table,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h4><p>leecode 22：给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。如n=3时，输出：[  “((()))”,  “(()())”,  “(())()”,  “()(())”,  “()()()”]</p><p>分析：全部组合的过程中，注意简单的条件剪枝。停止条件左括号个数 = n且右括号个数 = n。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝的条件为：左括号的数目一旦小于右括号的数目，以及，左括号的数目和右括号数目均小于n。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> str,<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; n || r &gt; n || r &gt; l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == n &amp;&amp; r==n) &#123; <span class="comment">//stop condition</span></span><br><span class="line">        res.push_back(str);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(res, str + <span class="string">'('</span>, l+<span class="number">1</span>, r, n);</span><br><span class="line">    dfs(res, str + <span class="string">')'</span>, l, r+<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    dfs(res, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// thanks a lot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组的所有子集"><a href="#数组的所有子集" class="headerlink" title="数组的所有子集"></a>数组的所有子集</h4><p>leecode 78给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res_temp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == nums.<span class="built_in">size</span>())  &#123;</span><br><span class="line">        res.push_back(res_temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不选</span></span><br><span class="line">    dfs_subsets(nums,res_temp,res,k+<span class="number">1</span>);</span><br><span class="line">    res_temp.push_back(nums[k]); <span class="comment">//选nums[k]</span></span><br><span class="line">    dfs_subsets(nums,res_temp,res,k+<span class="number">1</span>);</span><br><span class="line">    res_temp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res_temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    dfs_subsets(nums,res_temp,res,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图遍历的DFS"><a href="#图遍历的DFS" class="headerlink" title="图遍历的DFS"></a>图遍历的DFS</h3><p> 在图的遍历过程中，常用两种遍历算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graphTraverse</span><span class="params">(Graph* G)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G-&gt;n();v++) G-&gt;setMark(v, UNVISITED); <span class="comment">// n - nodes num</span></span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G-&gt;n();v++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G-&gt;getMark(v) == UNVISITED)</span><br><span class="line">doTraverse(G,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在搜索过程中，每当访问某个顶点V时，DFS会递归的访问它的所有未被访问的相邻节点。DFS将所有从顶点V出去的边存入栈中，从栈顶弹出一条边，根据这个边找到顶点V的一个相邻节点，这个顶点就是下一个要访问的顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph* G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">PreVisit(G,v); <span class="comment">//take appropriate action</span></span><br><span class="line">G-&gt;setMark(v, VISITED);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = G-&gt;first(v); w&lt;G-&gt;n(); w=G-&gt;next(v,w))</span><br><span class="line"><span class="keyword">if</span>(G-&gt;getMark(w) == UNVISITED)</span><br><span class="line">DFS(G,w); <span class="comment">// go deep to traverse</span></span><br><span class="line">PostVisit(G,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图遍历的BFS"><a href="#图遍历的BFS" class="headerlink" title="图遍历的BFS"></a>图遍历的BFS</h3><p>BFS  在进一步深入访问其他顶点之前，检查起点的所有相邻节点。用队列代替递归栈，BFS将逐层对各个节点进行访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph* G, <span class="keyword">int</span> start, Queue&lt;<span class="keyword">int</span>&gt;* Q)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v,w;</span><br><span class="line">Q-&gt;enqueue(start); <span class="comment">// initial node</span></span><br><span class="line">G-&gt;setMark(start,VISITED);</span><br><span class="line"><span class="keyword">while</span>(Q-&gt;length() != <span class="number">0</span>)&#123; <span class="comment">//process all vertices</span></span><br><span class="line">    v = Q-&gt;dequeue();</span><br><span class="line">    PreVisit(G,v);</span><br><span class="line">    <span class="keyword">for</span>(w=G-&gt;first(v); w&lt;G-&gt;n(); w = G-&gt;next(v,w))&#123;</span><br><span class="line">      <span class="keyword">if</span>(G-&gt;getMark(w) == UNVISITED)&#123;</span><br><span class="line">        G-&gt;getMark(w) == VISITED;</span><br><span class="line">        Q-&gt;enqueue(w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，leecode100经典 17,22题。</p><p>2，《挑战程序设计》</p><p>3,  《数据结构与算法分析 》 Clifford A. Shaffer</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h3&gt;&lt;p&gt;深度优先搜索从某个状态开始，不断的转移状态直到无法转移，然后回退到前一步的状态。执行的过程其实是跟栈有关，因为暂时没有执行的部分会被存放到堆栈里。直白点就是一条道走到黑，然后再逐步掉头，继续走到头。&lt;/p&gt;&lt;p&gt;一般要注意算法停止条件。迭代过程分析。&lt;/p&gt;&lt;h3 id=&quot;2-DFS类题目&quot;&gt;&lt;a href=&quot;#2-DFS类题目&quot; class=&quot;headerlink&quot; title=&quot;2 DFS类题目&quot;&gt;&lt;/a&gt;2 DFS类题目&lt;/h3&gt;&lt;h4 id=&quot;部分和问题&quot;&gt;&lt;a href=&quot;#部分和问题&quot; class=&quot;headerlink&quot; title=&quot;部分和问题&quot;&gt;&lt;/a&gt;部分和问题&lt;/h4&gt;&lt;p&gt;给定整数$a_{1}, a_{2}, \cdots, a_{n}$ ，判断能否可以从中选出若干数，使他们的和恰好为$k$&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS与BFS" scheme="http://yoursite.com/tags/DFS%E4%B8%8EBFS/"/>
    
  </entry>
  
  <entry>
    <title>字节算法岗面试记录</title>
    <link href="http://yoursite.com/2020/02/10/20200210%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E5%B2%97%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/02/10/20200210%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E5%B2%97%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2020-02-10T09:40:59.000Z</published>
    <updated>2020-03-19T01:09:42.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>面试官真的是很直接了，就出了道算法题。但整体来说这个面试官真的是超级好了啊，特别会引导，我觉得字节就是这点细节很好。</p><p>最大连续序列和。</p><p>如给一个Array： 1，-2，3，1，-1，5 。则是8 (3, 1, -1 , 5)</p><p>分析：设DP[k] 是表示以k结尾的最大的和。则递推公式为 DP[k] = max{DP[k-1] + A[k] ，A[k] }，要么是前一个连续和加上数组值（当前数组值为正），要么就是数组本身。这样最后只需要一遍遍历过去，找出以某个k结尾的最大和的那个DP值即为答案。</p><a id="more"></a><p>代入看：初始化DP[0] = 0 , DP[1] = max{1, 0} = 1 , DP[2] = max{-1, -2} = -1; ….</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSequenceSum</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> dp[length];</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+matrix[i], matrix[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// get the max</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i] &gt; res) res = dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的时间复杂度是O (n)，空间复杂度也是O(n)，面试官引导进行优化空间。</p><p>思路就是用变量存上一个dp[i-1] 与最大的 dp值，直接返回即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSequenceSum</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> dp[length];</span><br><span class="line">  <span class="keyword">int</span> dp_max = matrix[<span class="number">0</span>]; <span class="comment">// store the max</span></span><br><span class="line">  <span class="keyword">int</span> dp_last = matrix[<span class="number">0</span>]; <span class="comment">// store the dp[i-1]</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">    dp_last = <span class="built_in">max</span>(dp_last + matrx[i], matrix[i]);</span><br><span class="line">    <span class="keyword">if</span>(dp_last &gt; dp_max) dp_max = dp_last;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真的是有意思，我也没有刷完所有题，感觉自己思路还是有些慢，得再练哦。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的技术leader有点像个稍严厉的大父亲，而且涉及很广居然包括博弈论，我虽然是学了很多博弈论的数学模型（还记得当时的考试，复习得可费劲了，得理解所有的啥完美，完全博弈啥概念，还得计算的）。在此记录一些问题吧。</p><h4 id="1，优化问题"><a href="#1，优化问题" class="headerlink" title="1，优化问题"></a>1，优化问题</h4><p>出了个问题是在给定的CTR和CVR之下，让用户尽量久的停留（停留时间长）。考虑最优化，写优化和约束和拉格朗日法。</p><p>max: t</p><p>s.t. CTR+r CVR &gt; n</p><p>CTR和CVR的计算应该也是跟用户停留时间t有关的（现象上来看，用户停留时间越长，点击率和转化率可能越高），用最优化里的有约束的凸二次规划来看的话。</p><p>构建拉格朗日函数，对不等式约束引入拉格朗日乘子, $\alpha_i \geq 0$。</p><script type="math/tex; mode=display">L(t) = t - \alpha_i (CTR+r CVR - n)</script><p>当然这里根据CTR和CVR的计算公式展开。根据拉格朗日对偶像，原始问题的对偶问题是极小极大问题。对所有实数域上的优化问题都有其对偶问题。</p><script type="math/tex; mode=display">min_{\alpha_i} max_t  L(t)</script><p>这里应该是对偶可以求一个 upper bound的。我一开始莽撞写错了不等式约束，然后后面联想SVM才改。在复习一下（图中f ,g 不要求是凸的）：</p><p><img src="/images/20200211Dual.jpg" alt="20200211Dual"></p><h4 id="2，广告拍卖模型"><a href="#2，广告拍卖模型" class="headerlink" title="2，广告拍卖模型"></a>2，广告拍卖模型</h4><p>明拍（谁出的高就收谁的）和暗拍（相互不知道对方出价），各自的影响。</p><p>为什么拍卖？揭示信息并减少代理成本。当一个物品对买者的价值比卖者更清楚时，卖者一般不愿意首先提出价格，而采用拍卖方式获得可能的最高价格。</p><p>明拍：从最低价开始举牌逐渐升高。这里面可能涉及作弊问题，拍卖客户之间串通，以低价甚至是起拍底价成交的人，其他竞买人都不举牌与之竞争，再私下得到一些好处。</p><p>暗拍，是以出价最高的投标者获得拍卖品。并支付出价给卖者。（有一级密封拍卖，出价最高；二级密封拍卖，报价中的次高价）</p><h5 id="2-1-一级拍卖"><a href="#2-1-一级拍卖" class="headerlink" title="2.1 一级拍卖"></a>2.1 一级拍卖</h5><p>两个投标人，假设$b_i \geq 0$ 是投标人i的出价，$v_i$ 是拍卖品对投标人i的价值，可见$v_i$只有i自己知道（自己根据估计的真实价值进行出价，这个函数只与自己相关）。$v_i$ 独立地取自定义在区间$[0,1]$ 上的均匀分布函数。投标人i的效用（可以理解为我的收益）是：</p><script type="math/tex; mode=display">u_{i}\left(b_{i}, b_{j} ; v_{i}\right)=\left\{\begin{array}{cl}{v_{i}-b_{i},} & {\text { 如果 } b_{i}>b_{j}} \\ {\frac{1}{2}\left(v_{i}-b_{i}\right),} & {\text { 如果 } b_{i}=b_{j}} \\ {0,} & {\text { 如果 } b_{i}<b_{j}}\end{array}\right.</script><p>假设投标人i的出价 $b_i(v_i)$ 是其价值 $v_i$ 的严格递增可微函数，肯定不会$b_i ＞1 &gt; v_i$ 因为没人付比物品价值更高的出价。考虑对称的情况下出价策略 $b = b^{\star}(v)$ ，投标人i的预期支付是：</p><script type="math/tex; mode=display">u_{i}=(v-b) \operatorname{Pr} o b\left\{b_{j}<b\right\}</script><script type="math/tex; mode=display">\operatorname{Pr} o b\left\{b_{j}<b\right\}=\operatorname{Pr} o b\left\{b^{*}\left(v_{j}\right)<b\right\} = \operatorname{Pr} o b\left\{v_{j}<b^{*-1}(b) \equiv \Phi(b)\right\}=\Phi(b)</script><p>根据均匀分布有$k \in[0,1], \quad \operatorname{Pr} o b(\theta \leq k)=k$，即这里的$\Phi(b) = b^{*-1}(b)$ </p><p>投标人面对的问题就是：</p><script type="math/tex; mode=display">\max _{b} u_{i}=(v-b) \operatorname{Pr} o b\left\{b_{j}<b\right\}=(v-b) \Phi(b)</script><p>上面这个max最优化问题的一阶条件是：$-\Phi(b)+(v-b) \Phi^{\prime}(b)=0$</p><p>如果$b^{*}(\cdot)$ 是投标者i的最优策略，$\Phi(b)=v, then, v=(v-b) \frac{\mathrm{d} v}{\mathrm{d} b}$</p><script type="math/tex; mode=display">v \mathrm{d} b+b \mathrm{d} v=v \mathrm{d} v , \frac{\mathrm{d}(v b)}{\mathrm{d} v}=v</script><p>积分$vb = \frac{1}{2}v^2$ 求得 $b^{\star}=v / 2$，即是这个博弈的贝叶斯均衡。</p><p>当有n个投标人时，每个投标人的价值$v_i$ 定义在【0，1】区间上且独立同分布。投标人i的预期支付函数是：</p><script type="math/tex; mode=display">u_{i}=(v-b) \prod_{j \neq i} \operatorname{Pr} o b\left\{b_{j}<b\right\}=(v-b) \Phi^{n-1}(b)</script><script type="math/tex; mode=display">b^{\star}(v)=\frac{n-1}{n} v</script><p><strong>投标人越多，卖者能得到的价格就越高；当投标人数趋于无穷时，卖者几乎得到拍卖品价值的全部。因此，卖者希望更多的人加入竞标 。</strong></p><h5 id="2-2-二级拍卖"><a href="#2-2-二级拍卖" class="headerlink" title="2.2 二级拍卖"></a>2.2 二级拍卖</h5><p>如果投标者想赢得投标，则他的效用是：</p><script type="math/tex; mode=display">u_{i}=v_{i}-\max _{j \neq i} b_{j}</script><script type="math/tex; mode=display">b_{i}>\max _{j \neq i} b_{j}</script><p>对每个参与人来说，自己只需要比其他人好一点点就行。即以他的估价进行投标的策略$\left(b_{i}=v_{i}\right)$ 弱优于其他策略。记$r_{i} \equiv \max _{j \neq i} b_{j}$ 即第二大出价。</p><p>$when: r_i \leq v_i $，以$v_i$投标则投标者获得效用是： $v_i - r_i$ （理解为其他所有人的出价都稍微小于自己心中对物品的估价，这样才可能获得正效用。）</p><p>当$r_i \geq b_i$ ，投标者i获得效用是0。当 <script type="math/tex">v_i < r_i < b_i</script> 则投标者i具有效用是 $v_i - r_i &lt; 0$，若此时投标$v_i$ 则效用是0。</p><p>因此<strong>在二级密封价格拍卖中，投标者会以他们的估价进行投标</strong> 。</p><p>类比到互联网的广告拍卖里，其实也有广义第一价格GFP（实收价等于出价）和广义第二价格GSP（实收价等于第二出价），还有VGG竞价机制。</p><p>广义第一价格GFP（实收价等于出价）的影响，受广告主的出价影响，可能不稳定，可能高也坑可能低。GSP更能凸显出广告的真实价格。</p><h5 id="2-3，概率生成器。"><a href="#2-3，概率生成器。" class="headerlink" title="2.3，概率生成器。"></a>2.3，概率生成器。</h5><p>给一个不均分的硬币，投的正面概率是P（不是0.5），怎么用它来得到均匀（0.5）的结果。两次正面的概率是p，两次反面概率是（1-p）^2，一正一反的概率是 2p(1-p)，这里01、10的生成概率是相同的，基于此代表0，1来生成。</p><p>2020年1月23好不容易面完了二面，技术岗说后面HR联系，然后然后就没有然后了通知说岗位不匹配，就这样记录记录吧，每次面试都是一次学习总结的机会。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，肖条军 《决策与博弈论》</p><p>2，<a href="[https://wiki.mbalib.com/wiki/%E5%B0%81%E9%97%AD%E5%BC%8F%E6%8B%8D%E5%8D%96](https://wiki.mbalib.com/wiki/封闭式拍卖">封闭式拍卖</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h3&gt;&lt;p&gt;面试官真的是很直接了，就出了道算法题。但整体来说这个面试官真的是超级好了啊，特别会引导，我觉得字节就是这点细节很好。&lt;/p&gt;&lt;p&gt;最大连续序列和。&lt;/p&gt;&lt;p&gt;如给一个Array： 1，-2，3，1，-1，5 。则是8 (3, 1, -1 , 5)&lt;/p&gt;&lt;p&gt;分析：设DP[k] 是表示以k结尾的最大的和。则递推公式为 DP[k] = max{DP[k-1] + A[k] ，A[k] }，要么是前一个连续和加上数组值（当前数组值为正），要么就是数组本身。这样最后只需要一遍遍历过去，找出以某个k结尾的最大和的那个DP值即为答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="经历" scheme="http://yoursite.com/categories/%E7%BB%8F%E5%8E%86/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>异常检测方法</title>
    <link href="http://yoursite.com/2020/02/10/20191210%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/10/20191210%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95/</id>
    <published>2020-02-10T08:24:27.000Z</published>
    <updated>2020-03-18T10:01:59.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异常检测方法综述"><a href="#异常检测方法综述" class="headerlink" title="异常检测方法综述"></a>异常检测方法综述</h3><h4 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h4><p>有基于阈值的，还有对数据的分布做出假设，并找出假设下所定义的“异常”，因此往往会使用极值分析或者假设检验，概率密度函数值小于某个阈值的点判定为异常。 还有些多元模型，如计算多个事件指标之间期望的相关性等等。</p><h5 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h5><p>频率直方图， 点分布图</p><h5 id="高斯分布的-k-sigma"><a href="#高斯分布的-k-sigma" class="headerlink" title="高斯分布的 k-sigma"></a>高斯分布的 k-sigma</h5><p>概率密度函数为 $f(x)=\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}$</p><a id="more"></a><p>当点$X \notin ( { \mu } - 3 { \sigma } ,  { \mu } + 3  { \sigma } ) $ 则为异常，因为这个点出现的概率小于 1 - 99.74%。</p><p>延伸出滑动窗高斯模型，后续s表示为异常分数score：</p><script type="math/tex; mode=display">s =1-Q\left(\frac{\left|x_-\mu \right|}{\sigma}\right)</script><p>Q函数是标准正态分布的右尾函数：$Q(x)=\int_{x}^{\infty} \frac{1}{\sqrt{2 \pi}} e^{-\frac{t^{2}}{2}} d t$，Q函数又叫（标准正态分布的）互补累计分布函数，Q ( x )是正常(高斯)随机变量获得大于x标准差的值的概率。</p><h5 id="箱型图"><a href="#箱型图" class="headerlink" title="箱型图"></a>箱型图</h5><p><img src="/images/20191211BoxPlot.jpg" alt="20191211BoxPlot"></p><p>IQR (inter quartile range) = Q3 - Q1 ； 占据中心值周围50%数量的范围</p><p>LQR (lower quartile range) = median - Q1 ； IQR的下半部分</p><p>UQR (upper quartile range) = Q3 - median ； IQR的上半部分</p><p>若按3 σ来判断异常， 3 σ = 2.1 IQR，则异常在median的2.1 IQR之外，因此在Q1或者Q3再延伸1.5 IQR (3σ 之外)的点就很可能是outlier点了。</p><p>即$P &gt; Q3+1.5IQR$ or $P&lt; Q1 - 1.5IQR$</p><h5 id="假设检验类型"><a href="#假设检验类型" class="headerlink" title="假设检验类型"></a>假设检验类型</h5><p>如extreme studentized deviate（Grubb’s Test ）</p><p>提出假设H0:没有异常点，H1：至少有一个异常点。</p><p>根据样本的均值和标准差来计算最大 bias / standard deviation 比值。</p><script type="math/tex; mode=display">G=\frac{\max _{i=1, \ldots, N}\left|X_{i}-\bar{X}\right|}{s}</script><p>基于t-student分布定检出水平$\alpha$（置信概率$P=1- \alpha$）与检测次数$n$查找表格获得临界值$G_0$。当计算的$G&gt;G_0$则判断为异常点。</p><p>其他还有卡方检验（chi-square theory），Q_test等</p><h5 id="Skyline用到的几种统计方法（单时间序列的异常检测）"><a href="#Skyline用到的几种统计方法（单时间序列的异常检测）" class="headerlink" title="Skyline用到的几种统计方法（单时间序列的异常检测）"></a>Skyline用到的几种统计方法（单时间序列的异常检测）</h5><p><strong>median absolute deviation （MAD）</strong></p><p>计算数据的中位数，偏差 = 每个值-中位数，得到偏差中位数</p><script type="math/tex; mode=display">\mathrm{MAD}=\operatorname{median}\left(\left|X_{i}-\operatorname{median}(X)\right|\right)</script><p>MAD对数据集中的异常值比标准偏差更具弹性。在标准偏差中，与均值的距离的平方，较大的异常值会影响更大。可以通过判断一个点的偏差是否过于偏离MAD来判断异常。</p><p><strong>stddev_from_average</strong></p><p>时间序列最后三个点的 $(t - series.mean) &gt; 3 * series.std$</p><p>最新的三个数据点的平均值的绝对值减去移动平均值，大于三个平均值的标准偏差。</p><p><strong>least_squares</strong></p><p>根据最小二乘模型上，将最后三个数据点的平均值投影，大于三个sigma，则时间序列是异常的。</p><p><strong>Histogram-based</strong></p><p>如果最后三个数据点的平均值落入了带有少于n个其他数据点的直方图bin中。</p><p>统计学方法是可以用在时间序列上的，取最近的一时间段来进行统计计算。</p><h4 id="基于距离distanced-based"><a href="#基于距离distanced-based" class="headerlink" title="基于距离distanced-based"></a>基于距离distanced-based</h4><h5 id="直接定义距离"><a href="#直接定义距离" class="headerlink" title="直接定义距离"></a>直接定义距离</h5><p>假设：若一个数据点和大多数数据点距离很远，则这个对象就是异常。但这个方法不太适合稀疏数据集。</p><h5 id="KNN等基于邻居"><a href="#KNN等基于邻居" class="headerlink" title="KNN等基于邻居"></a>KNN等基于邻居</h5><p>简单的定义可以是：用数据对象与最近的K个点的距离之和。很明显，与K个最近点的距离之和越小，异常分越低；与K个最近点的距离之和越大，异常分越大。</p><script type="math/tex; mode=display">N C M(o, M)=\sum_{h \in k N N(o)} d i s t(o, h)</script><h5 id="聚类clustering"><a href="#聚类clustering" class="headerlink" title="聚类clustering"></a>聚类clustering</h5><h5 id="基于密度density"><a href="#基于密度density" class="headerlink" title="基于密度density"></a>基于密度density</h5><p>LOF方法：通过局部的数据密度来检测异常。显然，异常点所在空间的数据点少，密度低。</p><p>K邻近距离，在距离数据点 p 最近的几个点中，第 k 个最近的点跟点 p 之间的距离称为点 p 的 K-邻近距离，记为 k-distance (p) 。</p><p>可达距离：可达距离的定义跟K-邻近距离是相关的，给定参数k时， 数据点 p 到 数据点 o 的可达距离 reach-dist（p, o）为数据点 o 的K-邻近距离 和 数据点p与点o之间的直接距离的最大值。</p><script type="math/tex; mode=display">reachdist_k ( p , o ) =\max \{k-\text {distance}(o), d(p, o)\}</script><p>局部可达密度：基于可达距离的，对于数据点 p，那些跟点p的距离小于等于 k-distance（p）的数据点称为它的 k-nearest-neighbor，记为$N_{k}(p)$数据点 p 的局部可达密度为它与邻近的数据点的平均可达距离的倒数：</p><script type="math/tex; mode=display">lrd_{k}(p)=\frac{1}{\frac{\sum_{o \in N_{k}(p)} reachdist_{k} ( p , o ) }{\left|N_{k}(p)\right|}}</script><p>局部异常因子：用局部相对密度来定义的。数据点 p 的局部相对密度（局部异常因子）为点p的邻居们的平均局部可达密度跟数据点p的局部可达密度的比值。</p><script type="math/tex; mode=display">L O F_{k}(p)=\frac{\sum_{o \in N_{k}(p)} \frac{l r d(o)}{l r d(p)}}{\left|N_{k}(p)\right|}=\frac{\sum_{o \in N_{k}(p)} lrd(o)}{\left|N_{k}(p)\right|} / \operatorname{lr} d(p)</script><p>如果一个数据点跟其他点比较疏远的话，那么显然它的局部可达密度就小。判断异常点就是看它跟周围邻近的数据点的相对密度。如果数据点 p 的 LOF 得分在1附近，表明数据点p的局部密度跟它的邻居们差不多；如果数据点 p 的 LOF 得分小于1，表明数据点p处在一个相对密集的区域，不像是一个异常点；如果数据点 p 的 LOF 得分远大于1，表明数据点p跟其他点比较疏远，很有可能是一个异常点。</p><h5 id="ABOD基于角度"><a href="#ABOD基于角度" class="headerlink" title="ABOD基于角度"></a>ABOD基于角度</h5><h5 id="IsolationForest"><a href="#IsolationForest" class="headerlink" title="IsolationForest"></a>IsolationForest</h5><p>划分超平面来计算“孤立”一个样本所需的超平面数量。异常点所在空间中，所需要的划分次数更少。</p><p><strong>构造itree随机二叉树</strong>：</p><p>从全量数据中抽取一批样本，然后随机选择一个特征作为起始节点（bagging），并在该特征的最大值和最小值之间随机选择一个值，将样本中小于该取值的数据划到左分支，大于等于该取值的划到右分支。异常点一般都是非常稀有的，在iTree中会很快被划分到叶子节点。</p><p>x —— 要预测的样本</p><p>T.size —— iTree 的训练样本中同样落在 x 所在叶子节点的样本数。</p><p>e —— 数据 x 从 iTree 的根节点到叶节点过程中经过的边的数目</p><p>C(T.size) —— 修正值，二叉树的平均路径长度。</p><p>h(x) —— x在 iTree 中的路径长度：</p><script type="math/tex; mode=display">h ( x ) = e + C ( T . s i z e ) , C ( n ) = 2 H ( n - 1 ) - \left( \frac { 2 ( n - 1 ) } { n } \right), H ( k ) = \ln ( k ) + \xi</script><p>ψ —— 训练一棵itree的样本数</p><p>E(h(x))—— 数据x在多棵树上的路径长度均值</p><p>x在这棵树的异常指数是：</p><script type="math/tex; mode=display">s ( x , \psi ) = 2 ^ { \left( - \frac { E( h ( x ) ) } { c ( \psi ) } \right) }%</script><p>如果h(x)越小，则s(x,ψ)越接近1；越大，则s(x,ψ)越接近0.5。</p><p><strong>构造iforest</strong>：</p><p>随机采样一部分数据集去构造每一棵树，保证不同树之间的差异性，采样数据量ψ不需要等于n，可以远远小于n。</p><p><img src="/images/20200226iForest.jpg" alt="20200226iForest"></p><p>其他树方法变形：random cut forest、iForest、SCiForest、RRCF、改进的iForestASD方法，流数据异常检测帧等等。</p><h4 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a>回归模型</h4><p>1，自回归AR</p><script type="math/tex; mode=display">X_t = c + \sum_{i=1}^P \theta_{i}X_{t-i} + \varepsilon_t</script><p>其中$c$是常数项，$\theta_i$是自相关系数，$ \varepsilon_t$是随机误差项（平均数为0，标准差为$\sigma$的随机误差值，也称白噪声）。$X_t$的当前值是前几期的线性组合。$\theta_i$的变化将使得时间序列拥有不同的特征。</p><p>对于AR(1)而言：</p><p>当$\theta_1=0$, $X_t$相当于白噪声。</p><p>当$\theta_1=1, c=0$时，$X_t$相当于随机游走模型。</p><p>当$\theta_1=1, c\neq0$时，$X_t$相当于带漂移的随机游走模型。</p><p>当$\theta_1&lt;0$, $X_t$在正负值之间上下浮动。</p><p>P阶自回归模型的要求是时序数据具有平稳性，必须有自相关性（即自相关系数大于0.5），自回归只能适用于预测与自身前期相关的经济现象。</p><p>2，移动平均模型 MA</p><script type="math/tex; mode=display">X_{t}=c+\varepsilon_{t}+\sum_{i=1}^q \theta_i\varepsilon_{t-i}</script><p>移动平均模型MA(q)更关注自回归模型中的误差项的累加。每一个值都可以被认为是一个历史预测误差的加权移动平均值。</p><p>AR(1)可以用MA($\infty$) 表示：$y_{t}=\varepsilon_{t}+\phi_{1} \varepsilon_{t-1}+\phi_{1}^{2} \varepsilon_{t-2}+\phi_{1}^{3} \varepsilon_{t-3}+\cdots$</p><p>2.1 注意移动平均法和移动模型不同</p><p>移动平均法适用于即期预测。当产品需求既不快速增长也不快速下降，且不存在季节性因素时，移动平均法能有效地消除预测中的随机波动，非常有用的。移动平均法包括简单移动平均和加权移动平均。</p><p>简单移动平均：$X_t = \frac{\sum_{i=1}^n X_{t-i}}{n}$</p><p>加权移动平均：$X_t = \sum_{i=1}^n \theta_i X_{t-i}$ , 其中$\theta_i$是权重值，对近期的趋势反映较敏感，但不适合有季节性的数据。</p><p>根据同一个移动段内不同时间的数据对预测值的影响程度，分别给予不同的权数，然后再进行平均移动以预测未来值。</p><p>指数加权移动平均EWMA，指数移动平均EMA。</p><p>3，ARIMA模型</p><script type="math/tex; mode=display">y_{t}=\mu+\sum_{i=1}^{p} \gamma_{i} y_{t-i}+\epsilon_{t}+\sum_{i=1}^{q} \theta_{i} \epsilon_{t-i}</script><p>适合有季节性的数据</p><p>4，时间序列分解</p><p>STL季节性分解</p><p>论文：Online Conditional Outlier Detection in Nonstationary Time Series</p><p>STL分解（非参数分解方法）为三个要素：季节性、趋势、残差。 分析残差的偏差，然后引入残差阈值，这样就能得到一种异常检测得算法。</p><p>移动平均、指数平滑、ARMA、ARIMA</p><h4 id="2-4-线性模型（基于子空间subspace）"><a href="#2-4-线性模型（基于子空间subspace）" class="headerlink" title="2.4 线性模型（基于子空间subspace）"></a>2.4 线性模型（基于子空间subspace）</h4><p>主成分分析PCA</p><p>因子分析Factor Analysis</p><h4 id="2-3-机器学习"><a href="#2-3-机器学习" class="headerlink" title="2.3 机器学习"></a>2.3 机器学习</h4><p>分类模型（类别不平衡问题）</p><p>决策树</p><p>支持向量SVM </p><p>延伸出来的还有OneClass SVM，Support Vector Machine (SVM) with ant colony network[4]</p><p>随机森林等</p><p>Isolation Forest方法</p><p>GBDT方法 / XgBoost / Bagging等</p><p>Bayesiannetwork </p><h4 id="2-4-神经网络"><a href="#2-4-神经网络" class="headerlink" title="2.4 神经网络"></a>2.4 神经网络</h4><p>RNN、LSTM方法</p><p>论文：Anomaly detection in ECG time signals via deep long short-term memory networks</p><p>AutoEncoder</p><p>深度信念网络等</p><p>SOM自组织地图</p><p>HTM方法</p><p>频谱残差</p><h4 id="2-5-实时序列异常检测"><a href="#2-5-实时序列异常检测" class="headerlink" title="2.5 实时序列异常检测"></a>2.5 实时序列异常检测</h4><h5 id="2-5-1-NAB库有的"><a href="#2-5-1-NAB库有的" class="headerlink" title="2.5.1 NAB库有的"></a>2.5.1 NAB库有的</h5><p>期望相似性估计</p><h5 id="2-5-2-其他"><a href="#2-5-2-其他" class="headerlink" title="2.5.2 其他"></a>2.5.2 其他</h5><p>[4]里的Support Vector Machine (SVM) with ant colony network ，pcStream algorithm（stream clustering），random cut forest, </p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, “Everything you need to know about AIOps”, from <a href="https://www.moogsoft.com/resources/aiops/guide/everything-aiops/" target="_blank" rel="noopener">https://www.moogsoft.com/resources/aiops/guide/everything-aiops/</a> (retrieved as of Feb. 12, 2019)</p><p>2，<a href="https://github.com/yzhao062/pyod#gopalan2019pidforest" target="_blank" rel="noopener">https://github.com/yzhao062/pyod#gopalan2019pidforest</a> pyod异常检测库</p><p>3，<a href="https://github.com/etsy/skyline" target="_blank" rel="noopener">https://github.com/etsy/skyline</a> Skyline，一些统计方法</p><p>4，Habeeb R A A, Nasaruddin F, Gani A, et al. Real-time big data processing for anomaly detection: A Survey[J]. International Journal of Information Management, 2019, 45: 289-307.</p><p>5，<a href="https://otexts.com/fppcn/MA.html" target="_blank" rel="noopener">https://otexts.com/fppcn/MA.html</a> 预测方法与实践</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;异常检测方法综述&quot;&gt;&lt;a href=&quot;#异常检测方法综述&quot; class=&quot;headerlink&quot; title=&quot;异常检测方法综述&quot;&gt;&lt;/a&gt;异常检测方法综述&lt;/h3&gt;&lt;h4 id=&quot;统计方法&quot;&gt;&lt;a href=&quot;#统计方法&quot; class=&quot;headerlink&quot; title=&quot;统计方法&quot;&gt;&lt;/a&gt;统计方法&lt;/h4&gt;&lt;p&gt;有基于阈值的，还有对数据的分布做出假设，并找出假设下所定义的“异常”，因此往往会使用极值分析或者假设检验，概率密度函数值小于某个阈值的点判定为异常。 还有些多元模型，如计算多个事件指标之间期望的相关性等等。&lt;/p&gt;&lt;h5 id=&quot;看图&quot;&gt;&lt;a href=&quot;#看图&quot; class=&quot;headerlink&quot; title=&quot;看图&quot;&gt;&lt;/a&gt;看图&lt;/h5&gt;&lt;p&gt;频率直方图， 点分布图&lt;/p&gt;&lt;h5 id=&quot;高斯分布的-k-sigma&quot;&gt;&lt;a href=&quot;#高斯分布的-k-sigma&quot; class=&quot;headerlink&quot; title=&quot;高斯分布的 k-sigma&quot;&gt;&lt;/a&gt;高斯分布的 k-sigma&lt;/h5&gt;&lt;p&gt;概率密度函数为 $f(x)=\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}$&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="异常检测" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
  </entry>
  
  <entry>
    <title>DP算法</title>
    <link href="http://yoursite.com/2020/02/10/20200210DP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/10/20200210DP%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-10T03:04:11.000Z</published>
    <updated>2020-02-22T13:31:40.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-经典的背包问题"><a href="#1-经典的背包问题" class="headerlink" title="1 经典的背包问题"></a>1 经典的背包问题</h3><p>有n个重量和价值分别为$w_i,v_i$ 的物品，从这些物品中挑选出总重量不超过W的物品。求所有挑选方案中价值总和的最大值。</p><p>限制条件：</p><script type="math/tex; mode=display">1 \leqslant n \leqslant 100</script><script type="math/tex; mode=display">1 \leqslant w_{i}, v_{i} \leqslant 100</script><script type="math/tex; mode=display">1 \leqslant W \leqslant 10000</script><a id="more"></a><p>样例输入： n = 4, (w,v) = {(2,3) , (1,2), (3,4) , (2,2)} ,  w = 5 则输出是 7 （选 0、1、3号物品）</p><p>分析：</p><p>记 $dp[i+1][j]$ 是从前i个物品中挑选总重不超过j 的物品时总价值的最大值。于是有如下的递推式：</p><script type="math/tex; mode=display">dp[0]\lfloor j]=0</script><script type="math/tex; mode=display">dp[i+1] [j]=\left\{\begin{array}{ll}{d p[i][j]} & {(j<w[i])} \\ {\max (d p[i][j], d p[i][j-w[i]]+v[i])} & {(其他)}\end{array}\right.</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j&lt;w[i]) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = <span class="built_in">max</span>(dp[i][j],dp[i+<span class="number">1</span>][j-w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][W]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最长公共子序列"><a href="#2-最长公共子序列" class="headerlink" title="2 最长公共子序列"></a>2 最长公共子序列</h3><p>LCS问题是经典问题。给定两个字符串 $s_1s_2s_3…s_n$ 和 $t_1t_2…t_n$ 。求出这两个字符串的最长公共子序列的长度。</p><p>输入：n=4, m=4, s=”abcd”, t=”becd”</p><p>输出：3 （“bcd”）</p><p>定义 $d p[i][j]:= s_1…s_i和t_1…t_j$ 对应的LCS的长度。</p><p>由此$s_1…s_{i+1}和t_1…t_{j+1}$ 对应的公共子序列可能是几种情况：</p><p>第一，当$s_{i+1} = t_{j+1}$ 的时候，在$s_1…s_i和t_1…t_j$ 的公共子序列末尾追加上$s_{i+1}$</p><p>不等的时候，要么是$s_1…s_i和t_1…t_{j+1}$ 的序列的公共子序列，要么就是$s_1…s_{i+1}和t_1…t_j$</p><p>故递推公式是：</p><script type="math/tex; mode=display">d p[i+1][j+1]=\left\{\begin{array}{ll}{d p[i][j]+1} & {\left(s_{i+1}=t_{j+1}\right)} \\ {\max (d p[i][j+1], d p[i+1][j])} & {其他}\end{array}\right.</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input n,m</span></span><br><span class="line"><span class="keyword">char</span> s[MAX_N],t[MAX_N];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N+<span class="number">1</span>][MAX_N+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/20200211LCS_DP.jpg" alt="20200211LCS_DP"></p><h3 id="多重部分和"><a href="#多重部分和" class="headerlink" title="多重部分和"></a>多重部分和</h3><p>leecode39里这里暂时先不考虑将所有的可以加和的结果都存起来。我们先简单考虑能够通过给定的数组里的数，将和得到。下面的代码说明了能否通过这几个数字加和为target，是返回1，不是返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP[i+1][j] 表示用前i种数字加和成j， 需要前i-1种数字加和成 j，j-a[i], j - k *a[i]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[candidates.<span class="built_in">size</span>()+<span class="number">1</span>][target+<span class="number">1</span>]; <span class="comment">// 注意声明大小</span></span><br><span class="line">    <span class="comment">//init</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; candidates.<span class="built_in">size</span>()+<span class="number">1</span>; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k * candidates[i] &lt;= j; k++) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j - k*candidates[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[candidates.<span class="built_in">size</span>()][target]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test:  vector&lt;int&gt; candidates = &#123;2,3,6,7&#125;;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;combinationSum(candidates,11)&lt;&lt;endl; 是-1</span></span><br></pre></td></tr></table></figure><h3 id="4-leecode100-10-正则表达式匹配"><a href="#4-leecode100-10-正则表达式匹配" class="headerlink" title="4 leecode100-10 正则表达式匹配"></a>4 leecode100-10 正则表达式匹配</h3><p>给你一个字符串s 和一个字符规律 p，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; 匹配任意单个字符</span><br><span class="line">&apos;*&apos; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p>这里主要是考虑到星的匹配条件。$\operatorname{dp}[i][j]$ 是表示s的前i个能否被p的前j个匹配。</p><p>当$\mathrm{p}[\mathrm{j}]=\mathrm{s}[\mathrm{i}] 或 p[j] = “.”: \mathrm{dp}[\mathrm{i}][\mathrm{j}]=\operatorname{dp}[\mathrm{i}-1][\mathrm{j}-1]$</p><p>当$p[j] = “*”$ 时考虑两种情况：</p><script type="math/tex; mode=display">p[j-1] \quad !=s[i]: \operatorname{dp}[i][j]=\operatorname{dp}[i][j-2]</script><p>如 （ab, abc*）</p><script type="math/tex; mode=display">p[j-1]=s[i] \text { or } p[j-1]="."</script><script type="math/tex; mode=display">\operatorname{dp}[i-1][j] , \operatorname{dp}[i][j-1], \operatorname{dp}[i][j-2]</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// dp[i][j] means that s 的前i个能否被p的前j个匹配</span></span><br><span class="line">    <span class="keyword">int</span> sl = s.length();</span><br><span class="line">    <span class="keyword">int</span> pl = p.length();</span><br><span class="line">    <span class="keyword">if</span>(p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">int</span> dp[sl+<span class="number">1</span>][pl+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=sl; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=pl; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=pl; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j] == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j + <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// here's y axis should be i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sl; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pl; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[j]==<span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>]!=s[i] &amp;&amp; p[j - <span class="number">1</span>] != <span class="string">'.'</span>) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]; <span class="comment">//如果前一个元素不匹配且不为任意元素</span></span><br><span class="line">                <span class="keyword">else</span> dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j] || dp[i][j + <span class="number">1</span>] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sl][pl];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"mississippi"</span>;</span><br><span class="line">    <span class="built_in">string</span> p = <span class="string">"mis*is*p*."</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;isMatch(s,p)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-最长有效括号"><a href="#5-最长有效括号" class="headerlink" title="5 最长有效括号"></a>5 最长有效括号</h3><p>leecode100题的32题，给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。其实一看子序列长度就很像是DP题，那DP怎么定义的呢？一直觉得DP的定义找准真有点难。因为有时候定义不同，解法甚至就会不同。</p><p>DP[i] 以下标为i的字符结尾的最长有效子串长度。为什么这么定义，是因为i+1的字符是不是反括号 ) 决定了能否添加在最长子串的后面，要以i+1结尾的最长有效字符串则i+1一定是 )。以 ( 结尾的子字符串对应的 dp 数组位置上的值必定为 0 。所以说我们只需要更新 ) 在 dp 数组中对应位置的值。</p><p>1，$s[i] = ) 且 s[i-1]= ($  ，可以判断字符串类似”……()” ，那么dp[i] = dp[i-2] + 2; 这里dp[i-2] 是因为后两个字符一起判断的，加2，是因为（）的字符长度是2。</p><script type="math/tex; mode=display">\mathrm{dp}[i]=\mathrm{dp}[i-2]+2</script><p>2，$s[i] = ) 且 s[i-1] = )$ , 此时字符串类似 “…. ))” ，如果 $\mathrm{s}[i-\mathrm{dp}[i-1]-1]= ($ ，则：</p><script type="math/tex; mode=display">\mathrm{dp}[i]=\mathrm{dp}[i-1]+\mathrm{dp}[i-\mathrm{dp}[i-1]-2]+2</script><p>因为这个时候要考虑到如果倒数第二个 ) 是dp[i-1] 的最长子串的一部分。对于最后个 ) ，要匹配 dp[i-1] 最长子串的前面一个 ( 才是子串增加。而dp[i-1] 最长子串的前一个 ( 跟此时 dp[i] 的 ）匹配上了的话，就还得看 dp[i-1] 的前面是否还有以前的最长子串，就是$\mathrm{dp}[i-\mathrm{dp}[i-1]-2]$。减去2 则位置就在 $here(dp[i-1]的sub)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">""</span> || s==<span class="string">"("</span> || s==<span class="string">")"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//init</span></span><br><span class="line">    <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++) dp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//begin 注意边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">'('</span> )&#123;</span><br><span class="line">                dp[i] = (i&gt;=<span class="number">2</span>? dp[i<span class="number">-2</span>]:<span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]&gt;<span class="number">0</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//update the max</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; res) &#123;</span><br><span class="line">               res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s[i] == '(', dp[i] = 0</span></span><br><span class="line">        <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大连续序列和与接雨水"><a href="#最大连续序列和与接雨水" class="headerlink" title="最大连续序列和与接雨水"></a>最大连续序列和与接雨水</h3><p>如给一个 Array： 1，-2，3，1，-1，5 。则是 8 (3, 1, -1 , 5)</p><p>分析：设 DP [k] 是表示以 k 结尾的最大的和。则递推公式为 DP [k] = max {DP [k-1] + A [k] ，A [k] }，要么是前一个连续和加上数组值（当前数组值为正），要么就是数组本身。这样最后只需要一遍遍历过去，找出以某个 k 结尾的最大和的那个 DP 值即为答案。</p><p>leecode100-42题接雨水：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>第一个for循环找每个点的左侧最大高度 left[i] = max(left[i - 1], height[i - 1]);，</p><p>第二个for循环找每个点右侧的最大高度 right[i] = max(right[i + 1], height[i + 1]);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="built_in">min</span>(left[i], right[i]);</span><br><span class="line">  water += <span class="built_in">max</span>(<span class="number">0</span>, level - <span class="built_in">height</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，《挑战程序设计》 2.3 动态规划章节</p><p>2，leecode经典100题10题，32题，39题</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-经典的背包问题&quot;&gt;&lt;a href=&quot;#1-经典的背包问题&quot; class=&quot;headerlink&quot; title=&quot;1 经典的背包问题&quot;&gt;&lt;/a&gt;1 经典的背包问题&lt;/h3&gt;&lt;p&gt;有n个重量和价值分别为$w_i,v_i$ 的物品，从这些物品中挑选出总重量不超过W的物品。求所有挑选方案中价值总和的最大值。&lt;/p&gt;&lt;p&gt;限制条件：&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;1 \leqslant n \leqslant 100&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;1 \leqslant w_{i}, v_{i} \leqslant 100&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;1 \leqslant W \leqslant 10000&lt;/script&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>技术思考（常更）</title>
    <link href="http://yoursite.com/2020/02/07/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83%EF%BC%88%E5%B8%B8%E6%9B%B4%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/07/%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83%EF%BC%88%E5%B8%B8%E6%9B%B4%EF%BC%89/</id>
    <published>2020-02-07T13:07:25.000Z</published>
    <updated>2020-02-08T04:04:16.178Z</updated>
    
    <content type="html"><![CDATA[<p>2020-02-07</p><p>0，计算机科学。计算机可以是一个计算工具，代码只是为了实现一个计算。计算机本身也是一个机器设计的科学，里面有许多的机制与策略，为了让机器更快更有效率，更稳定，更易用，更易于扩展，更简洁易懂，更开放等等，这些是一种设计的科学和精神。</p><p>1，其实机器学习目前来看绝大多数基于概率统计，比如说贝叶斯分类，根据数据类别的分布去推测出新数据更可能属于哪个类别。深度学习则更多的时候是拟合非线性函数，在数学上看都是模型，建模建模是要根据实际问题和实际数据情况来的，所以才有了奥卡姆剃刀规则。其实我觉得底层其实是数学，看了越多论文越觉得一切皆数学，包括目前跨院接触的运筹经管。</p><a id="more"></a><p>2，运筹优化领域：其实在管科里这个应用十分广泛，毕竟本质是数学。始于线性规划（减少物料使用，减少费用这是目标，各种限制是约束条件），发展于各种决策甚至统计学习（线性回归SVM等优化函数）与深度学习（优化损失函数），更深的数学还有组合优化，多目标优化等等。我在想是否可以考虑一些运筹启发式的策略用于学习呢？比如说模拟退火？考虑一定的概率跳出当前解，重新搜索进行梯度优化？</p><p>3，在推荐领域，推荐的根本思想在于销售，销售除了考虑产品的性质，marketing，还有环境等等，联系起来其实数据特征、特征工程还有规则策略其实不就是为了解决这样的问题吗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020-02-07&lt;/p&gt;&lt;p&gt;0，计算机科学。计算机可以是一个计算工具，代码只是为了实现一个计算。计算机本身也是一个机器设计的科学，里面有许多的机制与策略，为了让机器更快更有效率，更稳定，更易用，更易于扩展，更简洁易懂，更开放等等，这些是一种设计的科学和精神。&lt;/p&gt;&lt;p&gt;1，其实机器学习目前来看绝大多数基于概率统计，比如说贝叶斯分类，根据数据类别的分布去推测出新数据更可能属于哪个类别。深度学习则更多的时候是拟合非线性函数，在数学上看都是模型，建模建模是要根据实际问题和实际数据情况来的，所以才有了奥卡姆剃刀规则。其实我觉得底层其实是数学，看了越多论文越觉得一切皆数学，包括目前跨院接触的运筹经管。&lt;/p&gt;
    
    </summary>
    
    
      <category term="经历" scheme="http://yoursite.com/categories/%E7%BB%8F%E5%8E%86/"/>
    
    
      <category term="IT行业" scheme="http://yoursite.com/tags/IT%E8%A1%8C%E4%B8%9A/"/>
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>20200205腾讯广告算法大赛——鱼佬方案</title>
    <link href="http://yoursite.com/2020/02/05/20200205%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B/"/>
    <id>http://yoursite.com/2020/02/05/20200205%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B/</id>
    <published>2020-02-05T08:42:07.000Z</published>
    <updated>2020-03-01T02:42:49.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-方案学习"><a href="#1-方案学习" class="headerlink" title="1 方案学习"></a>1 方案学习</h3><h4 id="1-1-赛题简介"><a href="#1-1-赛题简介" class="headerlink" title="1.1 赛题简介"></a>1.1 赛题简介</h4><p>题目：腾讯效果广告采用的是GSP（Generalized Second-Price）竞价机制，<strong>广告的实际曝光取决于广告的流量覆盖大小和在竞争广告中的相对竞争力水平</strong>。</p><p>其中广告的流量覆盖取决于广告的人群定向（匹配对应特征的用户数量）、广告素材尺寸（匹配的广告位）以及投放时段、预算等设置项。而影响广告竞争力的主要有出价、广告质量等因素（如pctr/pcvr等）， 以及对用户体验的控制策略。</p><a id="more"></a><p>通常来说， 基本竞争力可以用ecpm = 1000 <em> cpc_bid </em> pctr = 1000 <em> cpa_bid </em> pctr * pcvr (cpc, cpa分别代表按点击付费模式和按转化付费模式)。综上，前者决定广告能参与竞争的次数以及竞争对象，后者决定在每次竞争中的胜出概率。二者最终决定广告每天的曝光量。</p><p>本次竞赛将提供历史n天的曝光广告的数据（特定流量上采样）， 包括对应每次曝光的流量特征（用户属性和广告位等时空信息）以及曝光广告的设置和竞争力分数；测试集是新的一批广告设置（有完全新的广告id， 也有老的广告id修改了设置）。 </p><p>目标：预估测试集里这批广告的日曝光量。</p><h4 id="1-2-数据分析与清洗"><a href="#1-2-数据分析与清洗" class="headerlink" title="1.2 数据分析与清洗"></a>1.2 数据分析与清洗</h4><h5 id="查看数据与预处理："><a href="#查看数据与预处理：" class="headerlink" title="查看数据与预处理："></a>查看数据与预处理：</h5><p>数据集大小，数据类型，数据是否干净，标签类型，去重，离群点（散点图，删除），缺失情况（背后的意义，业务含义考虑填充），错误值（删除样本，均值或中位数替换等，标签里的错误值 剔除or 标签log化），各类别分布（均值情况，方差情况），大概可以构造的特征，特征之间是否冗余，时间信息。</p><h5 id="构造数据"><a href="#构造数据" class="headerlink" title="构造数据"></a>构造数据</h5><ol><li><p>将广告操作表中出价、定向人群、投放时段信息与广告静态表merge。</p></li><li><p>对日志数据中的广告id构造日曝光量得到新的数据集。</p></li><li><p>将data与广告静态表进行merge，并给缺失的投放时段填充-999</p></li></ol><h5 id="训练原始特征："><a href="#训练原始特征：" class="headerlink" title="训练原始特征："></a>训练原始特征：</h5><p>这些特征比较稳定：广告id，素材大小，广告行业id，商品类型，商品id，广告账户id；</p><p>广告账户id，出价 定点人群投放时间。</p><p>测试集也包含这些特征，然后构造好的广告id和标签数据与广告静态数据经行合并。</p><h4 id="1-3-特征工程"><a href="#1-3-特征工程" class="headerlink" title="1.3 特征工程"></a>1.3 特征工程</h4><h5 id="类别特征"><a href="#类别特征" class="headerlink" title="类别特征"></a>类别特征</h5><p>先处理可以转为自然编码，onehot编码</p><p>1，计数count统计（热度啥的，注意特殊值；计数排序 异常值不敏感；label占比的比例（过拟合问题，交叉验证处理）；</p><p>2，目标编码：出价的均值，点击率均值，或ecpm均值构造（新的广告ID的话，中位数填充）</p><p>3，交叉组合（类别与类别组合，粒度更细；类别和数值特征组合，这个类别出价的均价，平均点击率之类的）），可以nunique统计。</p><p>4，时序特征：前一两天的曝光值，出价情况等。时间序列考虑历史平均（d-1天的信息作为d天的特征）。</p><p>存在一个不存在的类别，缺失值的话用中位数或均值填充。</p><p>5，数值特征可以均值统计，最大最小，中位数等。</p><p>6，其他注意</p><p>细粒度的特征增强模型的刻画能力，粗粒度的特征保证模型的泛化能力。细粒度的特征对活跃用户比较好，可以更精细地刻画他的喜好，提供更个性化的商品排序；而粗粒度的特征是为了服务不活跃用户甚至是新用户，用大数据中总结出的一般规律来提供商品的排序。</p><p>为了避免过拟合，注意<strong>（5折）交叉统计</strong>构造特征。</p><p>CountVectorizer是属于常见的特征数值计算类，是一个文本特征提取方法。对于每一个训练文本，它只考虑每种词汇在该训练文本中出现的频率。对于多值特征，最方便的展开方式就是使用CountVectorizer。</p><h5 id="数值特征"><a href="#数值特征" class="headerlink" title="数值特征"></a>数值特征</h5><p>1，分桶：转为离散特征，就可以交叉组合。数值特征可以均值统计，最大最小，中位数等。</p><p>2，特征交叉：加减乘除等。根据业务出价 × 点击率 = ecpm 值。还可以类别与数值交叉。</p><h5 id="时间特征"><a href="#时间特征" class="headerlink" title="时间特征"></a>时间特征</h5><p>1，日期变量：年、月、周、日、小时、分钟等</p><p>2，时序相关特征：历史平均，历史曝光率，历史PCTR，滑动窗统计。d-1天的信息作为d天的特征，这种相近日期的数据相关性是非常大的。</p><p><img src="https://pic4.zhimg.com/80/v2-13ed138d221b38e7948060114a450907_720w.jpg" alt="img"></p><h5 id="特征筛选"><a href="#特征筛选" class="headerlink" title="特征筛选"></a>特征筛选</h5><p>1，过滤法：卡方检验 衡量x、y的相关性，相关系数来衡量特征间的相关性</p><p>2，封装法：逐个添加特征来判断效果好不好（前向，后向搜索），变好就选它，不适合特征太多的情况</p><p>3，嵌入法：基于学习模型的特征排序。如 树模型LightGBM可以返回特征的重要性，反映特征在训练过程中的分裂次数（越多，重要性越高），信息增益情况，按高低排序，阈值排序。</p><h5 id="一些trick"><a href="#一些trick" class="headerlink" title="一些trick"></a>一些trick</h5><p>1，模型与规则：比如历史平均来填充旧广告id的曝光量，新广告id曝光量用广告size、商品id等特征对应历史平均来填充。调整单调性。</p><p>2，目标编码防过拟合：进行目标编码的时候没有防过拟合处理，导致数据泄露。有效的办法是采用交叉验证的方式，比如我们将将样本划分为5份，对于其中每一份数据，我们都用另外4份数据来构造。</p><p><img src="https://pic4.zhimg.com/80/v2-3e624280c6761bda895810e3b9d9c3af_720w.jpg" alt="目标编码"></p><h4 id="1-4-模型训练与验证"><a href="#1-4-模型训练与验证" class="headerlink" title="1.4 模型训练与验证"></a>1.4 模型训练与验证</h4><p>Baseline：XGboost或LIghtGBM，对特征处理要求低，对类别和连续特征友好，缺失值不需要填充。</p><p>交叉验证：时序问题，为了避免数据泄露，常选择训练集最后一天进行线下验证，或者K-folds交叉验证。</p><p>模型融合：特征差异，样本差异（交叉验证中选择的样本是不一样的），模型差异（树模型，深度模型等）</p><p>训练过程融合：Bagging与Boosting</p><p>训练结果融合：投票法（类别），平均法（回归），Stacking</p><p>要不断尝试新idea，向优秀选手提问，赛后总结看优秀方案。</p><h3 id="2-源码阅读"><a href="#2-源码阅读" class="headerlink" title="2 源码阅读"></a>2 源码阅读</h3><p>数据处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pd.read_csv().sort_values() // 排序</span><br><span class="line">df[[<span class="string">'col'</span>]].astype(int) // 类型转换</span><br><span class="line">df.to_pickle() //pkl 存储更快</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------</span></span><br><span class="line"></span><br><span class="line">log=train_df</span><br><span class="line">tmp = pd.DataFrame(train_df.groupby([<span class="string">'aid'</span>,<span class="string">'request_day'</span>]).size()).reset_index()</span><br><span class="line">tmp.columns=[<span class="string">'aid'</span>,<span class="string">'request_day'</span>,<span class="string">'imp'</span>] <span class="comment"># 统计广告每天的出现次数，曝光量</span></span><br><span class="line">log=log.merge(tmp,on=[<span class="string">'aid'</span>,<span class="string">'request_day'</span>],how=<span class="string">'left'</span>)</span><br><span class="line">log[log[<span class="string">'request_day'</span>]&lt;<span class="number">17973</span>].to_pickle(<span class="string">'../data/user_log_dev.pkl'</span>) <span class="comment"># 构造验证集</span></span><br><span class="line">log.to_pickle(<span class="string">'../data/user_log_test.pkl'</span>) <span class="comment"># 构造的测试集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------------构造训练集</span></span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，<a href="https://algo.qq.com/application/home/rankinglist/rankingList.html" target="_blank" rel="noopener">https://algo.qq.com/application/home/rankinglist/rankingList.html</a> 腾讯算法大赛</p><p>2，<a href="https://zhuanlan.zhihu.com/p/63718151" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/63718151</a> 鱼佬知乎 <a href="https://zhuanlan.zhihu.com/p/73062485" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73062485</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-方案学习&quot;&gt;&lt;a href=&quot;#1-方案学习&quot; class=&quot;headerlink&quot; title=&quot;1 方案学习&quot;&gt;&lt;/a&gt;1 方案学习&lt;/h3&gt;&lt;h4 id=&quot;1-1-赛题简介&quot;&gt;&lt;a href=&quot;#1-1-赛题简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 赛题简介&quot;&gt;&lt;/a&gt;1.1 赛题简介&lt;/h4&gt;&lt;p&gt;题目：腾讯效果广告采用的是GSP（Generalized Second-Price）竞价机制，&lt;strong&gt;广告的实际曝光取决于广告的流量覆盖大小和在竞争广告中的相对竞争力水平&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;其中广告的流量覆盖取决于广告的人群定向（匹配对应特征的用户数量）、广告素材尺寸（匹配的广告位）以及投放时段、预算等设置项。而影响广告竞争力的主要有出价、广告质量等因素（如pctr/pcvr等）， 以及对用户体验的控制策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="推荐算法" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>20200204统计学之辛普森悖论</title>
    <link href="http://yoursite.com/2020/02/04/20200204%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%8B%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%82%96%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/02/04/20200204%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%8B%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%82%96%E8%AE%BA/</id>
    <published>2020-02-04T07:51:52.000Z</published>
    <updated>2020-02-04T09:02:15.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-例子引入"><a href="#1-例子引入" class="headerlink" title="1 例子引入"></a>1 例子引入</h3><p>医院A和医院B哪个更好？</p><p>医院A最近接收的1000个病人里，有900个活着，100个死了。</p><p>医院B最近接收的1000个病人里，有800个活着，200个死了。</p><p>粗略的看起来A的存活率更高，也许A更好。但是如果考虑更细致的重症病例存活情况呢？</p><div class="table-container"><table><thead><tr><th>病情</th><th>死亡</th><th>存活</th><th>总数</th><th>存活率</th></tr></thead><tbody><tr><td>严重</td><td>70</td><td>30</td><td>100</td><td>30%</td></tr><tr><td>不严重</td><td>30</td><td>870</td><td>900</td><td>96.7%</td></tr><tr><td>合计</td><td>100</td><td>900</td><td>1000</td><td>90%</td></tr></tbody></table></div><a id="more"></a><center> 医院A </center><div class="table-container"><table><thead><tr><th>病情</th><th>死亡</th><th>存活</th><th>总数</th><th>存活率</th></tr></thead><tbody><tr><td>严重</td><td>190</td><td>210</td><td>400</td><td>52.5%</td></tr><tr><td>不严重</td><td>10</td><td>590</td><td>600</td><td>98.3%</td></tr><tr><td>合计</td><td>200</td><td>800</td><td>1000</td><td>80%</td></tr></tbody></table></div><center> 医院B </center><p>这样来看是否B更好呢。</p><h3 id="2-统计学之辛普森悖论"><a href="#2-统计学之辛普森悖论" class="headerlink" title="2 统计学之辛普森悖论"></a>2 统计学之辛普森悖论</h3><p>这个例子就体现了统计学里的辛普森悖论（Simpson’s paradox）辛普森悖论最初是英国数学家爱德华·H·辛普森（Edward H. Simpson）在1951年发现的。</p><p><strong>辛普森悖论的不同解释：1，当你把数据拆开细看的时候，细节和整体趋势完全不同的现象。2，分组的数据点各自表现出某一个方向的相关性，在聚集时却表现出相反方向的相关性。</strong>说明数据不是绝对客观的。</p><p><img src="/images/20200204Data_SimpsonParadox.jpg" alt="20200204Data_SimpsonParadox"></p><p>从统计学家的观点来看，出现辛普森悖论的原因是因为这些数据中潜藏着一个魔鬼——潜在变量。比如在上面这个例子里，潜在变量就是病情严重程度不同的病人的占比。</p><p>我们能做的，就是仔细地研究分析各种影响因素。需要选择将数据分组或将它们聚合在一起。这似乎很简单，但我们如何决定做哪个？答案是<strong>学会思考因果关系</strong>：数据如何生成，基于此，哪些因素会影响我们未展示的结果？</p><p>仅有数据还不够。数据绝不是纯粹客观的，特别是当我们只看到最终的图表时，我们必须考虑是否明白整个事件。</p><p>为了避免辛普森悖论出现，就需要斟酌个别分组的权重，以一定的系数去消除以分组资料基数差异所造成的影响，同时必需了解该情境是否存在其他潜在要因而综合考虑。</p><h3 id="3-思考"><a href="#3-思考" class="headerlink" title="3 思考"></a>3 思考</h3><p>这个跟推荐系统里的隐变量很相似啊。直接数据只是用户表现（浏览数据，点击结果），而内在的隐变量则代表了同一类用户的行为习惯，其中不也是有因果关系的存在嘛。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1， <a href="https://zhuanlan.zhihu.com/p/47867414" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47867414</a> 机器之心 辛普森悖论</p><p>2，公众号“把科学带回家”</p><p>3， <a href="[https://wiki.mbalib.com/wiki/%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%82%96%E8%AE%BA](https://wiki.mbalib.com/wiki/辛普森悖论">MBA智库 辛普森悖论</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-例子引入&quot;&gt;&lt;a href=&quot;#1-例子引入&quot; class=&quot;headerlink&quot; title=&quot;1 例子引入&quot;&gt;&lt;/a&gt;1 例子引入&lt;/h3&gt;&lt;p&gt;医院A和医院B哪个更好？&lt;/p&gt;&lt;p&gt;医院A最近接收的1000个病人里，有900个活着，100个死了。&lt;/p&gt;&lt;p&gt;医院B最近接收的1000个病人里，有800个活着，200个死了。&lt;/p&gt;&lt;p&gt;粗略的看起来A的存活率更高，也许A更好。但是如果考虑更细致的重症病例存活情况呢？&lt;/p&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;病情&lt;/th&gt;
&lt;th&gt;死亡&lt;/th&gt;
&lt;th&gt;存活&lt;/th&gt;
&lt;th&gt;总数&lt;/th&gt;
&lt;th&gt;存活率&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;严重&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;30%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不严重&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;870&lt;/td&gt;
&lt;td&gt;900&lt;/td&gt;
&lt;td&gt;96.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;合计&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;900&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;90%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="统计学" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="统计学" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>点云的三种可视化方法</title>
    <link href="http://yoursite.com/2020/01/16/20200116%E7%82%B9%E4%BA%91%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/16/20200116%E7%82%B9%E4%BA%91%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95/</id>
    <published>2020-01-16T08:48:20.000Z</published>
    <updated>2020-01-19T11:58:51.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-点云介绍"><a href="#1-点云介绍" class="headerlink" title="1 点云介绍"></a>1 点云介绍</h3><p>点云数据是来自斯坦福大学的HDF5格式数据。HDF5 格式是用于存储和分发科学数据的一种多对象文件格式。可以用 HDFView 打开文件，查看数据。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www = &apos;https://shapenet.cs.stanford.edu/media/modelnet40_ply_hdf5_2048.zip</span><br></pre></td></tr></table></figure><a id="more"></a><p>点云还有PLY格式：PLY 文件格式是 Stanford 大学开发的一套三维 mesh 模型数据格式，图形学领域最初很多模型都是基于此格式，我使用了此格式的点云物体文件进行了部分物体的参考和对比。</p><p>点云还有PCD格式：一种新的 3D 点云数据文件格式，是当初为了解决某些不支持 PCL 为 3D点云处理进行的文件扩展。他的文件头部具有固定格式，必须用 ASCII 编码，包含标题、对点云数据的某些属性的声明。PCD 文件可以使用 PCL 库里的 PCL_Viewer 打开，从而直接查看到点云的三维图像。</p><p>MAC上的PCL_Viewer需要装PCL库，当时配置的一些问题记录在博客里了。<a href="[https://saruagithub.github.io/2019/03/27/PCL%E5%9C%A8Mac%E4%B8%8A%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/](https://saruagithub.github.io/2019/03/27/PCL在Mac上环境问题/">PCL 在 Mac 上环境问题</a></p><h3 id="2-可视化方法"><a href="#2-可视化方法" class="headerlink" title="2 可视化方法"></a>2 可视化方法</h3><h4 id="2-1-Matplotlib方法"><a href="#2-1-Matplotlib方法" class="headerlink" title="2.1 Matplotlib方法"></a>2.1 Matplotlib方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">'3d'</span>)</span><br><span class="line"><span class="comment"># point_range = range(0, points.shape[0], skip) # skip points to prevent crash</span></span><br><span class="line">point_range = range(<span class="number">0</span>, points.shape[<span class="number">0</span>])</span><br><span class="line">ax.scatter(points[point_range, <span class="number">0</span>],   <span class="comment"># x</span></span><br><span class="line">           points[point_range, <span class="number">1</span>],   <span class="comment"># y</span></span><br><span class="line">           points[point_range, <span class="number">2</span>],   <span class="comment"># z</span></span><br><span class="line">           c=points[point_range, <span class="number">2</span>], <span class="comment"># height data for color</span></span><br><span class="line">           cmap=<span class="string">'spectral'</span>,</span><br><span class="line">           marker=<span class="string">"x"</span>)</span><br><span class="line">ax.axis(<span class="string">'scaled'</span>)  <span class="comment"># &#123;equal, scaled&#125;</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/images/20200116MatPlotLib_PointCloud.jpg" alt="20200116MatPlotLib_PointCloud"></p><h4 id="2-2-PCD格式转化用PCL-Viewer可视化"><a href="#2-2-PCD格式转化用PCL-Viewer可视化" class="headerlink" title="2.2 PCD格式转化用PCL_Viewer可视化"></a>2.2 PCD格式转化用PCL_Viewer可视化</h4><p>对 HDF5 格式的数据进行了重写为 PCD 文件格式，主要 就是将数据写入的时候需要满足 PCD 文件顶头部分的特定格式。 PCL_viewer 是可视化点云文件的 PCL 工具，它需要用到 PCL 库里的 vtk 库进 行可视化。 </p><p>详情见我的github项目里 <a href="https://github.com/saruagithub/PointCloudClassification_keras" target="_blank" rel="noopener">点云分类</a> 的H5toPcd.py。</p><h4 id="2-3-Three-js-网页可视化"><a href="#2-3-Three-js-网页可视化" class="headerlink" title="2.3 Three.js 网页可视化"></a>2.3 Three.js 网页可视化</h4><p>首先构建一个场景，遍历添加 3D 点云的所有 点到场景里，并给点赋值颜色 RGB 值和材质，其实场景就是物体的一个容器。然后设置好相机，相机的角度决定了场景中某一角度的 3D 点云物体的图像。相机对 旋转的点云拍照，从而渲染显示在页面上即可看到可视化的点云物体了。最后设置 好渲染器。使用渲染器的 render(scene, camera)函数，设置渲染器的像素和页面元 素大小，渲染器将相机拍到的图形渲染显示在页面的元素内，从而在页面中可以看到图像。 </p><p>详情见github项目 <a href="https://github.com/saruagithub/PointCloudUpload" target="_blank" rel="noopener">点云分类网页展示</a> 的draw2.html</p><p><img src="/images/20200116Three_PointCloud.jpg" alt="20200116Three_PointCloud"></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li><p>普林斯顿大学 Modelnet 官网，<a href="http://modelnet.cs.princeton.edu/" target="_blank" rel="noopener">http://modelnet.cs.princeton.edu/</a> 2018 Princeton Vision &amp; </p><p>Robotics Labs ‒ Department of Computer Science </p></li><li><p>PCL 官网，<a href="http://www.pointclouds.org/about/#open" target="_blank" rel="noopener">http://www.pointclouds.org/about/#open</a> 2018/5/23 </p></li><li><p>Three.js 官网 <a href="https://threejs.org/" target="_blank" rel="noopener">https://threejs.org/</a> 2018/5/23 </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-点云介绍&quot;&gt;&lt;a href=&quot;#1-点云介绍&quot; class=&quot;headerlink&quot; title=&quot;1 点云介绍&quot;&gt;&lt;/a&gt;1 点云介绍&lt;/h3&gt;&lt;p&gt;点云数据是来自斯坦福大学的HDF5格式数据。HDF5 格式是用于存储和分发科学数据的一种多对象文件格式。可以用 HDFView 打开文件，查看数据。 &lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;www = &amp;apos;https://shapenet.cs.stanford.edu/media/modelnet40_ply_hdf5_2048.zip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="可视化" scheme="http://yoursite.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="三维点云" scheme="http://yoursite.com/tags/%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91/"/>
    
      <category term="可视化" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>二分查找算法</title>
    <link href="http://yoursite.com/2020/01/13/20200113%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/13/20200113%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-13T14:13:32.000Z</published>
    <updated>2020-02-20T15:03:38.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本二分查找"><a href="#基本二分查找" class="headerlink" title="基本二分查找"></a>基本二分查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return index of target</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>, high = length<span class="number">-1</span>, middle = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == numbers[middle]) <span class="keyword">return</span> middle;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; numbers[middle]) high = middle - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> low = middle + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>二分查找的时间复杂度是 $O(logn)$</p><p>二分查找里的边界条件有不同的写法，当 while 循环的条件中是 &lt;=时，在[low, high] 的闭区间上查找。</p><p>基于二分查找的题目很多，但基本很多情况都是给排序好的数组之类的进行查找。</p><h3 id="翻转排序数组"><a href="#翻转排序数组" class="headerlink" title="翻转排序数组"></a>翻转排序数组</h3><p>leecode100-33：假设按照升序排序的数组在预先未知的某个点上进行了旋转。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// find it</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left side is ASE</span></span><br><span class="line">        <span class="keyword">if</span> (nums[start] &lt;= nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[start] &lt;= target &amp;&amp; nums[mid] &gt; target) <span class="built_in">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// right ride is ASE</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target&lt; nums[start]) start = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leecode34-二分查找第一与最后位置"><a href="#leecode34-二分查找第一与最后位置" class="headerlink" title="leecode34 二分查找第一与最后位置"></a>leecode34 二分查找第一与最后位置</h3><p>在排序数组中查找元素的第一个和最后一个位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchRange_left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, <span class="built_in">end</span>=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="built_in">end</span> = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">end</span> = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左侧边界start的含义，nums中小于target的元素有几个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchRange_left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, <span class="built_in">end</span>=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="built_in">end</span> = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">end</span> = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// target 比所有数都大</span></span><br><span class="line">    <span class="keyword">return</span> nums[start] == target ? start : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchRange_right_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="built_in">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">end</span><span class="number">-1</span>] == target ? (<span class="built_in">end</span><span class="number">-1</span>) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SwordToOffer-二维数组的查找"><a href="#SwordToOffer-二维数组的查找" class="headerlink" title="SwordToOffer 二维数组的查找"></a>SwordToOffer 二维数组的查找</h3><p>书P47，每次选取数组的右上角元素，如果目标值较小，就逐渐往左下走。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P47 题目s4，二维数组查找数字</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_num</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (matrix != <span class="literal">nullptr</span> &amp;&amp; rows&gt;<span class="number">0</span> &amp;&amp; columns&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = columns - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; rows &amp;&amp; col &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row * columns + col] == number) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row * columns + col] &gt; number) --col;</span><br><span class="line">            <span class="keyword">else</span> ++row;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本二分查找&quot;&gt;&lt;a href=&quot;#基本二分查找&quot; class=&quot;headerlink&quot; title=&quot;基本二分查找&quot;&gt;&lt;/a&gt;基本二分查找&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// return index of target&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numbers[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; target)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; low = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, high = length&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, middle = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(low &amp;lt;= high)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    middle = (low + high) / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(target == numbers[middle]) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; middle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(target &amp;lt; numbers[middle]) high = middle - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; low = middle + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="SwordToOffer" scheme="http://yoursite.com/tags/SwordToOffer/"/>
    
  </entry>
  
  <entry>
    <title>剑指OfferP41与哈希散列</title>
    <link href="http://yoursite.com/2020/01/12/20200112%E5%89%91%E6%8C%87OfferP41/"/>
    <id>http://yoursite.com/2020/01/12/20200112%E5%89%91%E6%8C%87OfferP41/</id>
    <published>2020-01-12T13:44:52.000Z</published>
    <updated>2020-01-13T09:09:30.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><p>思路1：排序，然后比较当前个与下一个是否相同，相同则为重复元素。</p><p>思路2：一遍遍历，hash表将数组元素存起来，每次判断是否在hash里出现过。t:O(n)，space: O(n)</p><p>思路3：题目限制得比较死，数字在0~n-1的范围。所以可以采取书中的特殊交换解法。交换有限次即可找到，因此time O(n)。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution2</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; duplicate2(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; duplication;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mmap;</span><br><span class="line">    <span class="keyword">if</span> (numbers==<span class="literal">nullptr</span> || length&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> duplication;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        <span class="comment">// 可以去除这个限制了</span></span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> duplication;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mmap.<span class="built_in">find</span>(numbers[i]) != mmap.<span class="built_in">end</span>() ) &#123;</span><br><span class="line">            duplication.push_back(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mmap[i] = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> duplication;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// solution 3</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; duplicate(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; duplication;</span><br><span class="line">    <span class="comment">// Boundary conditions</span></span><br><span class="line">    <span class="keyword">if</span> (numbers==<span class="literal">nullptr</span> || length &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> duplication;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> duplication;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (numbers[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[numbers[i]]) &#123;</span><br><span class="line">                duplication.push_back(numbers[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//swap num[i] and num[num[i]]</span></span><br><span class="line">            swap(numbers[i], numbers[numbers[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> duplication;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 测试输出重复的数字 the duplicate num</span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">7</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; duplication;</span><br><span class="line">    duplication = duplicate(num, <span class="keyword">sizeof</span>(num)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:duplication) <span class="built_in">cout</span>&lt;&lt;item&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我修改了下，直接返回vector重复的数字。</p><h3 id="hash原理"><a href="#hash原理" class="headerlink" title="hash原理"></a>hash原理</h3><h4 id="hash原理-1"><a href="#hash原理-1" class="headerlink" title="hash原理"></a>hash原理</h4><p>根据关键码值直接访问表。如可以把关键码值映射到数组中的位置来访问记录，这个就是散列。把关键码值映射到位置的函数称为散列函数，用h表示。存放记录的数组称为散列表 HT。散列表中的第一个位置称为槽 slot，HT中槽的数目用M表示。$i = h(K)$ 是表中满足 $0 \leq h(K) &lt; M$ 的一个槽，记录在HT[i] 的关键码值与K相等。</p><p>散列方法不适合多条记录有相同关键码的应用程序。散列方法一般不适合范围检索。适合的是精确查找。有吗？那条记录是关键码值K呢？应用：主存的检索，磁盘的检索，组织存储在磁盘上的大型数据库。</p><p>适用情况，记录关键码值的范围很大，并且把记录存储在一个槽数目相对较少的表中。</p><p>散列函数：一般来说希望选择的散列函数能把记录以相同的概率分布到散列表的所有槽中。但是在一般情况下，根据关键码值的分布来选择散列 函数。</p><p>一些常见的散列函数：取余、平方取中法，字符串散列函数，折叠方法——ASCII码累加起来 % M（散列表长）</p><h4 id="开散列方法——单链方法"><a href="#开散列方法——单链方法" class="headerlink" title="开散列方法——单链方法"></a>开散列方法——单链方法</h4><p>冲突解决方法之开散列方法。</p><p>《数据结构与算法分析》P212，最简单的形式是：把散列表中的每个槽定义为一个链表的表头，散列到一个槽的所有记录都放到这个槽的链表内。链表中的记录可以按照插入次序排列，按照关键码值次序排列，按照访问频率次序排列等等。</p><p>适用于主存中。</p><h4 id="闭散列方法——开地址方法"><a href="#闭散列方法——开地址方法" class="headerlink" title="闭散列方法——开地址方法"></a>闭散列方法——开地址方法</h4><p>把所有记录直接存储到散列表中。每条关键码值标记为$k_R$ ，记录R有一个基槽，就是$h(k_R)$ ，即由散列函数计算出来的槽。如果要插入一条记录R，另一条记录占据了R的基槽，就把R存储在表的其他槽内。</p><p>桶式散列。把散列表中的槽分成多个桶。先进入桶中的槽，再进入溢出槽里。散列函数把记录在各个桶之间平均分布，使得进入溢出桶的记录尽可能少。</p><p>适用于磁盘的散列表。可以把桶的大小设置为磁盘块的大小。</p><h6 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h6><p>当基槽被占用时，在散列表中找到一个空槽，冲突策略就到达这个组中的下一个槽。如果这个槽也被占用了，就找下一个空槽。探测序列由探测函数P生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> hashdict&lt;Key,E&gt;::hashInsert(<span class="keyword">const</span> Key&amp;k, <span class="keyword">const</span> E&amp;e)&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">home</span>; <span class="comment">// home position for k</span></span><br><span class="line">  <span class="keyword">int</span> pos = <span class="built_in">home</span> = h(k); <span class="comment">//Init proble sequence</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; EMPTYKEY!=(HT[pos]).key(); i++)&#123;</span><br><span class="line">    pos = (<span class="built_in">home</span> + p(k,i) % M); <span class="comment">// probe</span></span><br><span class="line">    Assert(k != (HT[pos]).key(), <span class="string">"Duplication not allowed!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  KVpair&lt;Key,E&gt; temp(k,e);</span><br><span class="line">  HT[pos] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第i次对P调用，返回第i次要用到的偏移量。</p><p>探测函数：线性探测，避免聚集可P(k,i) = ci</p><p>好的探测序列是在回到基槽之前，把散列表的所有槽都走一遍。理想的探测函数应该在探查序列中随机的从未走过的槽中选择下一个位置，即探查序列应当是散列表位置的随机排列。如伪随机探查。$( h(K) + r_i ) mod M$, $r_i$ 是1到M-1之间的数的随机排列。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组中重复的数字&quot;&gt;&lt;a href=&quot;#数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;数组中重复的数字&quot;&gt;&lt;/a&gt;数组中重复的数字&lt;/h3&gt;&lt;p&gt;思路1：排序，然后比较当前个与下一个是否相同，相同则为重复元素。&lt;/p&gt;&lt;p&gt;思路2：一遍遍历，hash表将数组元素存起来，每次判断是否在hash里出现过。t:O(n)，space: O(n)&lt;/p&gt;&lt;p&gt;思路3：题目限制得比较死，数字在0~n-1的范围。所以可以采取书中的特殊交换解法。交换有限次即可找到，因此time O(n)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="SwordToOffer" scheme="http://yoursite.com/tags/SwordToOffer/"/>
    
  </entry>
  
  <entry>
    <title>20180915pointnet论文3——TensorFlow源码阅读</title>
    <link href="http://yoursite.com/2020/01/11/20180915pointnet%E8%AE%BA%E6%96%873%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/01/11/20180915pointnet%E8%AE%BA%E6%96%873%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2020-01-11T12:59:40.000Z</published>
    <updated>2020-02-03T09:56:20.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h3><p>根目录下：</p><p>train.py用于点云分类训练</p><p>provider.py 用于点云的数据预处理（旋转，抖动等）</p><p>evaluate用于评估训练结果。</p><p>其他目录：<strong>data</strong>目录下存放用于训练的样例文件h5，test_files与train_files中列举的用于训练及测试的文件路径。<strong>log</strong> 存放的是训练结果，默认情况下只存放最近一次训练结果。<strong>models</strong>存放的是模型文件，pointnet_cls.py（POINTNET）和pointnet_cls_basic.py（baseline模型）中的MLP是分类模型结构。pointnet_seg.py是点云分割模型网络；transform_nets.py为原始点云对称变换以及特征变换，即论文中的T-net网络。</p><a id="more"></a><h3 id="1，数据预处理provider"><a href="#1，数据预处理provider" class="headerlink" title="1，数据预处理provider"></a>1，数据预处理provider</h3><p>前面下载数据以及后面的hdf5格式加载数据就略过了。说一说数据预处理部分干了些什么。</p><p>1，shuffle_data函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle_data</span><span class="params">(data, labels)</span>:</span></span><br><span class="line">    idx = np.arange(len(labels))</span><br><span class="line">    np.random.shuffle(idx)</span><br><span class="line">    <span class="keyword">return</span> data[idx, ...], labels[idx], idx</span><br></pre></td></tr></table></figure><p>根据labels的长度创建idx下标集合，对下标集合随机打乱，返回打乱的数据data[idx,…] 和labels[idx]。</p><p>2，随机旋转点云rotate_point_cloud（参数batch_data）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate_point_cloud</span><span class="params">(batch_data)</span>:</span></span><br><span class="line">    rotated_data = np.zeros(batch_data.shape, dtype=np.float32)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(batch_data.shape[<span class="number">0</span>]):</span><br><span class="line">        rotation_angle = np.random.uniform() * <span class="number">2</span> * np.pi</span><br><span class="line">        cosval = np.cos(rotation_angle)</span><br><span class="line">        sinval = np.sin(rotation_angle)</span><br><span class="line">        rotation_matrix = np.array([[cosval, <span class="number">0</span>, sinval],</span><br><span class="line">                                    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                                    [-sinval, <span class="number">0</span>, cosval]])</span><br><span class="line">        shape_pc = batch_data[k, ...]</span><br><span class="line">        rotated_data[k, ...] = np.dot(shape_pc.reshape((<span class="number">-1</span>, <span class="number">3</span>)), rotation_matrix)</span><br><span class="line">    <span class="keyword">return</span> rotated_data</span><br></pre></td></tr></table></figure><p>遍历这批点云物体batch_data.shape[0] 即B的大小。</p><p>旋转角度是随机生成的，乘以2$\pi$ ，即使角度多大都没关系，反正按角度算。</p><p>计算cos和sin值。</p><p>注意此处的旋转矩阵。原一个点云物体k的大小的n*3与旋转矩阵做点积。其实就是物体逆时针旋转那么多角度。对这一批点云物体都做这一个随机旋转角度值。</p><script type="math/tex; mode=display">\left[\begin{array}{lll}{cosval} & {0} & {sinval} \\ {0} & {1} & {0} \\ {-sinval} & {0} & {cosval}\end{array}\right]</script><p>rotate_point_cloud_by_angle旋转也是同理，不过是指定角度旋转。角度作为参赛输入函数。</p><p>3，jitter_point_cloud随机抖动点云</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jitter_point_cloud</span><span class="params">(batch_data, sigma=<span class="number">0.01</span>, clip=<span class="number">0.05</span>)</span>:</span></span><br><span class="line">    B, N, C = batch_data.shape</span><br><span class="line">    <span class="keyword">assert</span>(clip &gt; <span class="number">0</span>)</span><br><span class="line">    jittered_data = np.clip(sigma * np.random.randn(B, N, C), <span class="number">-1</span>*clip, clip)</span><br><span class="line">    jittered_data += batch_data</span><br><span class="line">    <span class="keyword">return</span> jittered_data</span><br></pre></td></tr></table></figure><p>sigma = 0.01， clip = 0.05</p><p>sigma <em> sigma </em> np.random.randn(B, N, C) 是均值为sigma的正态分布数据，大小是$B\times N \times C$</p><p>将这些数值切割到-0.05到0.05之间，并与原始点云的坐标数据相加。</p><p>相当于给点云数据加微小的噪声，增强数据有助于模型的泛化性。</p><h3 id="2，基础模型baseline"><a href="#2，基础模型baseline" class="headerlink" title="2，基础模型baseline"></a>2，基础模型baseline</h3><p>pointnet_cla_basic.py 函数。就是不看T-net的网络部分。</p><p><img src="/images/20180914pointnet.jpg" alt="20180914pointnet"></p><p>placeholder_inputs() 根据点云物体一批大小，以及每个点云物体的点的数目声明变量占位。</p><p>get_model() 输入大小BxNx3, 输出Bx40 （这个是40个类别分类向量</p><p>其中input_image的shape是$B \times N \times 3 \times 1$ ， 而输出大小是$B \times 40$ 因为物体是40个类别。</p><p>然后就是点云的卷积网络多层感知层MLP，卷积层的卷积核个数为64，大小是$1 \times 3$ ，步长是 $1 \times 1$，padding = valid 不补0，激活函数是Relu。 这几个参数，其中卷积核个数为64表示卷积中输出滤波器filter的数量，$1 \times 3$  的卷积核大小是因为坐标为xyz。卷积核就会在训练过程中逐步得到一些与点云物体的特殊的特征点。</p><p><img src="/images/20200114POINTNET_CNN.png" alt="20200114POINTNET_CNN"></p><p><center>卷积图，输入是2048 × 3，输出其实有64个特征地图，其实就是论文图中的 n × 64</center><br>同理，后续的卷积核大小都是(1,1)，步长也是(1,1) 都是为了挑选这些特征点（信息点，有趣点），即局部感知，可以想这个网络只是把每个点连接起来而已。</p><p>然后经过5个卷积层之后，采用了最大池化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxPooling2D(pool_size=(NUM_POINT,<span class="number">1</span>),strides=[<span class="number">2</span>,<span class="number">2</span>],padding=<span class="string">'valid'</span>)</span><br></pre></td></tr></table></figure><p>最大池化采用大小为(2,2) 将特征地图缩小一半，并提取关键信息点。同时这里的最大池化将特征点起了对称作用，最后将全局的特征进行聚合。</p><script type="math/tex; mode=display">f\left(\left\{x_{1}, \ldots, x_{n}\right\}\right) \approx g\left(h\left(x_{1}\right), \ldots, h\left(x_{n}\right)\right)</script><script type="math/tex; mode=display">f: 2^{\mathrm{R}^{N}} \rightarrow \mathbb{R}, h \quad: \mathbb{R}^{N} \rightarrow \mathbb{R}^{K}</script><p>g是一个对称函数，即maxpool；h是卷积网络；下图中的$\gamma$ 是拟合分类函数（即全连接层逼近复杂函数）。</p><p><img src="/images/20200114POINTNET_pic.jpg" alt="20200114POINTNET_pic"></p><p>最后的三个全连接网络，大小分别是512，256，40。最后的40输出类别。激活函数为softmax输出概率，哪个概率大则输出就是哪个类别的物体。全连接网络好理解，就是对特征点汇总为全局描述符，最后用于分类。</p><h3 id="3，POINTNET网络"><a href="#3，POINTNET网络" class="headerlink" title="3，POINTNET网络"></a>3，POINTNET网络</h3><p>T-Net的作用：我们期望通过网络学习到的表征（特征）对于这些仿射变换是不变的。</p><h4 id="3-1-Input-Transform网络"><a href="#3-1-Input-Transform网络" class="headerlink" title="3.1 Input Transform网络"></a>3.1 Input Transform网络</h4><h5 id="3-1-1-论文原理"><a href="#3-1-1-论文原理" class="headerlink" title="3.1.1 论文原理"></a>3.1.1 论文原理</h5><p>我们通过<strong>微型网络（图2中的T-net）预测仿射变换矩阵</strong>，将该变换直接应用于输入点的坐标。</p><h5 id="3-1-2-源码"><a href="#3-1-2-源码" class="headerlink" title="3.1.2 源码"></a>3.1.2 源码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform = input_transform_net(point_cloud, is_training, bn_decay, K=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这个T-net网络也是一个类似前面的baseline模型。这里point_cloud的输入大小是(B = 32, N = 2048, 3) 。然后分别由三个卷积层，大小是64（卷积核大小1×3），128（1×1），1024（1×1），一个最大池化层，两个全连接网络组成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">'transform_XYZ'</span>) <span class="keyword">as</span> sc:</span><br><span class="line">    <span class="keyword">assert</span>(K==<span class="number">3</span>)</span><br><span class="line">    weights = tf.get_variable(<span class="string">'weights'</span>, [<span class="number">256</span>, <span class="number">3</span>*K],</span><br><span class="line">                              initializer=tf.constant_initializer(<span class="number">0.0</span>),</span><br><span class="line">                              dtype=tf.float32)</span><br><span class="line">    biases = tf.get_variable(<span class="string">'biases'</span>, [<span class="number">3</span>*K],</span><br><span class="line">                             initializer=tf.constant_initializer(<span class="number">0.0</span>),</span><br><span class="line">                             dtype=tf.float32)</span><br><span class="line">    biases += tf.constant([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], dtype=tf.float32)</span><br><span class="line">    transform = tf.matmul(net, weights)</span><br><span class="line">    transform = tf.nn.bias_add(transform, biases)</span><br><span class="line"></span><br><span class="line">transform = tf.reshape(transform, [batch_size, <span class="number">3</span>, K])</span><br><span class="line"><span class="keyword">return</span> transform</span><br></pre></td></tr></table></figure><p>初始化weights是(256, 9) 大小，biases大小是(9,)，biases初始化加常量。transform将net网络即卷积网络（大小是 n × 256，n是个点）于权重（大小是 256 × 9）相乘。</p><p>input transform是对空间中点云进行调整，直观上理解是旋转出一个更有利于分类或分割的角度，比如把物体转到正面。</p><h4 id="3-2-Feature-Transform网络"><a href="#3-2-Feature-Transform网络" class="headerlink" title="3.2 Feature Transform网络"></a>3.2 Feature Transform网络</h4><h5 id="3-2-1-论文原理"><a href="#3-2-1-论文原理" class="headerlink" title="3.2.1 论文原理"></a>3.2.1 论文原理</h5><p>可以在点特征（point features）上插入另一个对齐网络，并预测一个特征转换矩阵以对齐来自不同输入点云（point clouds）的特征。由于特征空间中的变换矩阵具有比空间变换矩阵高（much higher）的维数，这大大增加了优化的难度。 因此，我们在softmax训练损失中添加了一个正则化项。</p><p> 我们约束特征变换矩阵使其接近正交矩阵：</p><script type="math/tex; mode=display">L_{r e g}=\left\|I-A A^{T}\right\|_{F}^{2}</script><p>$A$ 是特征对齐矩阵（由a mini-network T-net预测的），正交变换将不会丢失输入中的信息，因此是需要的。 我们发现通过添加正则项，优化变得更加稳定，并且我们的模型获得了更好的性能。</p><p>正交变换是线性变换的一种，它从实内积空间V映射到V自身，且保证变换前后内积不变。对一个由空间投射到同一空间的线性转换，如果转换后的向量长度与转换前的长度相同，则为正交变换。这里正交变换矩阵其实就是用于点云做仿射变换的。</p><h5 id="3-1-3-源码"><a href="#3-1-3-源码" class="headerlink" title="3.1.3 源码"></a>3.1.3 源码</h5><p>1，网络部分</p><p>第二次feature transform是对提取出的64维特征进行对齐，即在特征层面对点云进行变换。</p><p>2，损失函数部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_loss</span><span class="params">(pred, label, end_points, reg_weight=<span class="number">0.001</span>)</span>:</span></span><br><span class="line">    <span class="string">""" pred: B*NUM_CLASSES,</span></span><br><span class="line"><span class="string">        label: B, """</span></span><br><span class="line">    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=pred, labels=label)</span><br><span class="line">    classify_loss = tf.reduce_mean(loss)</span><br><span class="line">    tf.summary.scalar(<span class="string">'classify loss'</span>, classify_loss)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Enforce the transformation as orthogonal matrix</span></span><br><span class="line">    transform = end_points[<span class="string">'transform'</span>] <span class="comment"># BxKxK</span></span><br><span class="line">    K = transform.get_shape()[<span class="number">1</span>].value</span><br><span class="line">    mat_diff = tf.matmul(transform, tf.transpose(transform, perm=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line">    mat_diff -= tf.constant(np.eye(K), dtype=tf.float32)</span><br><span class="line">    mat_diff_loss = tf.nn.l2_loss(mat_diff) </span><br><span class="line">    tf.summary.scalar(<span class="string">'mat loss'</span>, mat_diff_loss)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> classify_loss + mat_diff_loss * reg_weight</span><br></pre></td></tr></table></figure><p>损失函数部分由两部分构成，一部分是交叉熵损失，一部分就是正则化项。</p><p>这里Transform的大小是（32,64,64）就是特征转换矩阵，把它与它的转置矩阵相乘$AA^T$。然后与对角矩阵相减 $AA^T - I$ 使这个损失变小。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, 开源代码 <a href="https://github.com/charlesq34/pointnet" target="_blank" rel="noopener">https://github.com/charlesq34/pointnet</a></p><p>2，1*1 的卷积核 <a href="https://zhuanlan.zhihu.com/p/40050371" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40050371</a></p><p>3，卷积神经网络 <a href="https://zhuanlan.zhihu.com/p/47184529" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47184529</a></p><p>4，点云POINTNET解读 <a href="https://blog.csdn.net/tumi678/article/details/80499998" target="_blank" rel="noopener">https://blog.csdn.net/tumi678/article/details/80499998</a></p><p>5，损失函数 <a href="https://blog.csdn.net/mao_xiao_feng/article/details/53382790" target="_blank" rel="noopener">https://blog.csdn.net/mao_xiao_feng/article/details/53382790</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目录说明&quot;&gt;&lt;a href=&quot;#目录说明&quot; class=&quot;headerlink&quot; title=&quot;目录说明&quot;&gt;&lt;/a&gt;目录说明&lt;/h3&gt;&lt;p&gt;根目录下：&lt;/p&gt;&lt;p&gt;train.py用于点云分类训练&lt;/p&gt;&lt;p&gt;provider.py 用于点云的数据预处理（旋转，抖动等）&lt;/p&gt;&lt;p&gt;evaluate用于评估训练结果。&lt;/p&gt;&lt;p&gt;其他目录：&lt;strong&gt;data&lt;/strong&gt;目录下存放用于训练的样例文件h5，test_files与train_files中列举的用于训练及测试的文件路径。&lt;strong&gt;log&lt;/strong&gt; 存放的是训练结果，默认情况下只存放最近一次训练结果。&lt;strong&gt;models&lt;/strong&gt;存放的是模型文件，pointnet_cls.py（POINTNET）和pointnet_cls_basic.py（baseline模型）中的MLP是分类模型结构。pointnet_seg.py是点云分割模型网络；transform_nets.py为原始点云对称变换以及特征变换，即论文中的T-net网络。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="三维点云" scheme="http://yoursite.com/tags/%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>20180915pointnet论文2——实验部分</title>
    <link href="http://yoursite.com/2020/01/11/20180915pointnet%E8%AE%BA%E6%96%872/"/>
    <id>http://yoursite.com/2020/01/11/20180915pointnet%E8%AE%BA%E6%96%872/</id>
    <published>2020-01-11T02:35:05.000Z</published>
    <updated>2020-01-14T15:43:49.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-论文中实验"><a href="#1-论文中实验" class="headerlink" title="1 论文中实验"></a>1 论文中实验</h3><h4 id="1-1-点云分类classification"><a href="#1-1-点云分类classification" class="headerlink" title="1.1 点云分类classification"></a>1.1 点云分类classification</h4><p>数据集：ModelNet40，12311CAD模型，40个类别，9843个训练，2468测试。</p><p>我们根据网格区域对网格表面上的1024个点进行统一采样，并将其标准化为单位球体。</p><p>数据增强：1，沿上轴随机旋转对象（随机旋转 or 旋转某一角度）。2，通过具有零均值和0.02标准偏差的高斯噪声使每个点的位置抖动来动态地增加点云。</p><a id="more"></a><p>对比实验，table1中SPH[11]，3DShapeNets[28]，VoxNet[17]，Subvolume[18]，LFD[28]，MVCNN[23]（这个的平均每个类别的准确率达到了90.1%，很好诶）与我们的基模型（卷积+最大池化+全连接），PointNet（总体分类准确率89.2 %）的分类准确率比较。</p><p>比MVCNN的效果差可能原因是：认为这是由于可以通过渲染图像捕获的精细几何细节的丢失。</p><h4 id="1-2-点云零件分割"><a href="#1-2-点云零件分割" class="headerlink" title="1.2 点云零件分割"></a>1.2 点云零件分割</h4><p>3D对象零件分割零件分割是一项具有挑战性的细粒度3D识别任务。</p><p>数据集：对来自[29]的ShapeNet零件数据集进行评估，该数据集包含16个类别的16,881个形状，总共标注了50个零件。</p><p>我们将零件分割公式化为每个点的分类问题。 评估指标是按点计算。 对于类别C（如杯子）的每个形状S（杯柄与内杯），要计算形状S的mIoU：<strong>如果groundtruth（真实标记）和预测点的并集为空，则将零件IoU计为1</strong>。然后，我们对类别C中所有零件类型的IoU进行平均，以得到该形状的mIoU。 要计算类别的mIoU，我们对该类别中所有形状的mIoU取平均值。</p><p>Table2，我们报告每个类别，并表示IoU（％）得分。 我们观察到平均IoU改善了2.3％，我们的网络在大多数类别中都超过了基本方法。</p><h4 id="1-3-场景语义分割"><a href="#1-3-场景语义分割" class="headerlink" title="1.3 场景语义分割"></a>1.3 场景语义分割</h4><p>零件分割网络扩展到场景语义分割。其中点标签成为语义对象类（semantic object class），而不是对象零件标签（object part label）。</p><p>数据集：斯坦福3D语义分割数据集上进行了实验[1]。 数据集包含来自6个区域（包括271个房间）的Matterport扫描仪的3D扫描。 扫描中来自13个类别（椅子，桌子，地板，墙壁等，加上混乱）的每个点都有语义标签进行标注。</p><p>为了准备训练数据，首先按房间来划分points，然后将房间采样为面积为1m x 1m的块。我们训练PointNet的分割segmentation版本以预测每个块中的每个点类。</p><p>在训练时，我们会在每个飞行块中随机抽取4096个点。在测试时，我们对所有方面进行测试。我们将我们的方法与使用手工制作的点特征的基线进行比较。基线提取相同的9-dim局部特征和三个附加特征：局部点密度，局部曲率和法线。我们使用标准的MLP作为分类器。结果显示在表3中，其中我们的PointNet方法明显优于基线方法。</p><h3 id="2-我的理解"><a href="#2-我的理解" class="headerlink" title="2 我的理解"></a>2 我的理解</h3><p>1，卷积的过程</p><p>如何对点进行卷积，提取关键点（信息点）</p><p>在卷积的时候，把点云看做是（2048,3,1）的一张灰度图来进行卷积计算。但第一步的卷积核大小是(1,3)  是对点进行计算，提取他的特征点。后续的卷积卷积核也是(1,1)的，也是提取一些关键点。</p><p><img src="/images/20200114POINTNET_CNN.png" alt="20200114POINTNET_CNN"></p><p>2，对称函数 max pool的作用</p><p>解决无序性问题（为什么可以解决无序性）</p><p>原生的PointNet就是这样一种g函数。使用multi-layer perceptron (MLP) 和 max pooling 来建模g函数。</p><p>3，相邻点的交互信息必须考虑进去（通过共享的MLP或者2D卷积解决）：解决相邻点之间的关联信息问题？</p><p>4，网络结构中的T-net作用</p><p>论文中指的是将输入点和特征进行对齐、适用于刚性or仿射变换。</p><p>通过<strong>微型网络（图2中的T-net）预测仿射变换矩阵</strong>（仿射变换前是直线，仿射变换后还是直线，直线比例保持不变。），并将该变换直接应用于输入点的坐标。why？</p><p>其中的正则化项？ 我们约束特征变换矩阵使其接近正交矩阵？</p><p>避免n! 排列</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-论文中实验&quot;&gt;&lt;a href=&quot;#1-论文中实验&quot; class=&quot;headerlink&quot; title=&quot;1 论文中实验&quot;&gt;&lt;/a&gt;1 论文中实验&lt;/h3&gt;&lt;h4 id=&quot;1-1-点云分类classification&quot;&gt;&lt;a href=&quot;#1-1-点云分类classification&quot; class=&quot;headerlink&quot; title=&quot;1.1 点云分类classification&quot;&gt;&lt;/a&gt;1.1 点云分类classification&lt;/h4&gt;&lt;p&gt;数据集：ModelNet40，12311CAD模型，40个类别，9843个训练，2468测试。&lt;/p&gt;&lt;p&gt;我们根据网格区域对网格表面上的1024个点进行统一采样，并将其标准化为单位球体。&lt;/p&gt;&lt;p&gt;数据增强：1，沿上轴随机旋转对象（随机旋转 or 旋转某一角度）。2，通过具有零均值和0.02标准偏差的高斯噪声使每个点的位置抖动来动态地增加点云。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="三维点云" scheme="http://yoursite.com/tags/%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>20180914pointnet论文1——论文部分</title>
    <link href="http://yoursite.com/2020/01/08/20180914pointnet%E8%AE%BA%E6%96%871/"/>
    <id>http://yoursite.com/2020/01/08/20180914pointnet%E8%AE%BA%E6%96%871/</id>
    <published>2020-01-08T12:26:29.000Z</published>
    <updated>2020-01-15T14:05:32.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Abs-amp-Intro"><a href="#1-Abs-amp-Intro" class="headerlink" title="1 Abs &amp; Intro"></a>1 Abs &amp; Intro</h3><p>点云是一种重要的几何数据结构（自动驾驶的数据），由于不规则性许多研究者之前用3D体素网络 voxel grids（体积CNN：[28、17、18]是在体素化形状上应用3D卷积神经网络的先驱。由于数据稀疏性和3D卷积的计算成本，体积表示受到其分辨率的限制。）或图片集合（将点云数据投影到二维平面，扩展性以及提取特征的表示能力的限制。）来进行识别，但这使得数据变庞大，引入了量化伪像，这些伪像会掩盖数据的自然不变性。</p><a id="more"></a><p>本文设计了一种新颖的神经网络，直接输入点云，该网络很好地考虑了输入中点的排列不变性（点云是无序向量集。）。POINTNET可以用于分类，零件分割，场景语义分割等。典型的卷积体系结构需要高度规则的输入数据格式，例如图像网格或3D体素，以执行权重共享和其他内核优化。点云是简单统一的结构，避免了网格的组合不规则性和复杂性，因此更易于学习。但是，PointNet仍然必须尊重这样一个事实，即点云只是一组点，因此其成员的排列是不变的，因此在网络计算中必须具有一定的对称性。</p><p><strong>（核心原理）我们方法的关键是使用一个简单的对称函数，即最大池化max pool。 网络有效地学习了一组最优标准，它选择了点云的有趣点或信息点，并对选择它们的原因进行了编码。</strong> 网络的最终全连接层将这些学习的最优值汇总到整个描述符的全局描述符中（如上所述）（形状分类），或用于预测每个点云的类别标签（形状分割）。我们的网络<strong>学会了通过稀疏的一组关键点来总结输入点云，根据可视化，这些关键点大致对应于对象的骨架。</strong></p><p>我们的输入格式易应用于刚性或仿射变换，因为每个点都是独立变换的。 因此，我们可以添加一个依赖数据的空间转换器网络，该网络尝试在PointNet处理数据之前对数据进行规范化，以进一步改善结果。</p><p>文章主要贡献：</p><p>1，我们设计了可以直接对3D无序点云处理的深度网络架构。</p><p>2，这个网络如何被训练执行3D形状分类，零件分割和场景分割。</p><p>3，经验与理论分析其稳定性与有效性。</p><p>4，说明选定的神经元在网络中计算出的3D特征，并对其性能进行直观的解释。</p><h3 id="2-Problem-Statement"><a href="#2-Problem-Statement" class="headerlink" title="2 Problem Statement"></a>2 Problem Statement</h3><p>深度学习架构，直接将无序点云输入。一个点云表示为3D点的集合$\left\{P_{i} | i=1, \dots, n\right\}$，其中每个点$P_i$ 是其坐标(x,y,z) 的坐标（也可以加上另外的特征，如颜色，法向量等）。</p><p>对于对象分类任务，可以直接从形状中采样输入点云，也可以从场景点云中预先分割输入点云。 我们建议的深度网络针对所有k个候选类输出k个分数。</p><p> 对于语义分割，输入可以是用于部分零件区域分割的单个对象，也可以是3D场景中的用于对象区域分割。 我们的模型输出n×m分数，即输出每个点（一共n个）的每一个m个语义子类别。</p><h3 id="3-点集上的深度学习"><a href="#3-点集上的深度学习" class="headerlink" title="3 点集上的深度学习"></a>3 点集上的深度学习</h3><h4 id="3-1-点集属性"><a href="#3-1-点集属性" class="headerlink" title="3.1 点集属性"></a>3.1 点集属性</h4><p>1，无序性。 与图像中的像素阵列或体积网格中的体素阵列不同，点云是一组没有特定顺序的点。换句话说，消耗N个3D点集的网络需要对于输入集的N个排列按数据馈送顺序保持不变。（无论点如何顺序输入，都要能够识别）</p><p>2，点之间的相互作用。 这些点来自具有距离度量的空间。 这意味着这些点不是孤立的，相邻点形成一个有意义的子集。 因此，模型需要能够从附近的点捕获局部结构，以及局部结构之间的组合相互作用。</p><p>3，变换下的不变性。 作为几何对象，学习到的点集表示应不变于某些变换。 例如，一起旋转和平移点都不应修改全局点云类别或点的分割。</p><h4 id="3-2-点云架构"><a href="#3-2-点云架构" class="headerlink" title="3.2 点云架构"></a>3.2 点云架构</h4><p><img src="/images/20180914pointnet.jpg" alt="20180914pointnet"></p><p>我们的网络具有<strong>三个关键模块：最大池层（作为对称函数，用于汇总来自所有点的信息），一个局部和全局信息组合结构，以及两个对齐输入点集和点特征的联合对齐网络。</strong></p><h5 id="3-2-1-无序输入的对称函数！！！"><a href="#3-2-1-无序输入的对称函数！！！" class="headerlink" title="3.2.1 无序输入的对称函数！！！"></a>3.2.1 无序输入的对称函数！！！</h5><p>为了使模型对输入排列不变，存在以下三种策略：</p><p>1）按规范顺序对输入进行排序； </p><p>尽管排序听起来很简单，但实际上在高维空间中不存在稳定的排序，关于一般意义上的点扰动。 矛盾很容易说明。 如果存在这种排序策略，它将在高维空间和1d实线之间定义一个双射映射（输入的点不论顺序，通过一一对应的函数映射到高维空间）。 不难发现，关于点扰动要求顺序是稳定的，就等同于要求此映射随着维度减小而保留空间邻近性，这是一般情况下无法实现的任务。</p><p>因此，排序无法完全解决ordering问题，并且随着ordering问题的持续存在，网络很难学习从输入到输出的一致映射。 如实验所示（图5），我们发现直接在排序点集上应用MLP效果较差，尽管比直接处理未排序的输入要好一些。</p><p>2）将输入作为训练RNN的序列，但通过各种排列来增强训练数据； </p><p>使用RNN的想法将点集视为序列信号，并希望通过用随机排列的序列训练RNN，RNN将对输入顺序不变。 但是，在“ OrderMatters” [25]中，作者表明顺序确实很重要，不能完全省略。 尽管RNN对长度较短（数十个）的序列的输入排序具有相对较好的鲁棒性，但很难扩展到数千个输入元素，这是点集的常见大小。 根据经验，我们还表明，基于RNN的模型的性能不如我们提出的方法。</p><p>3）使用简单的<strong>对称函数</strong>汇总每个点的信息。 在此，对称函数将n个向量作为输入，并输出一个与输入顺序不变的新向量。 例如，+和∗运算符是对称二进制函数。</p><script type="math/tex; mode=display">f\left(\left\{x_{1}, \ldots, x_{n}\right\}\right) \approx g\left(h\left(x_{1}\right), \ldots, h\left(x_{n}\right)\right)</script><script type="math/tex; mode=display">f: 2^{\mathrm{R}^{N}} \rightarrow \mathbb{R}, h \quad: \mathbb{R}^{N} \rightarrow \mathbb{R}^{K}</script><p>g是一个对称函数。</p><p><strong>基本思想</strong>：从经验上讲，我们的基本模块非常简单，我们通过多层感知器网络近似模拟h函数，通过单个变量函数和最大池函数的组合来近似g。 通过实验发现这种方法效果很好。 通过收集h，我们可以学习多个f来捕获集合的不同属性。</p><h5 id="3-2-2-分类、分割"><a href="#3-2-2-分类、分割" class="headerlink" title="3.2.2 分类、分割"></a>3.2.2 分类、分割</h5><p><strong>点云的分类</strong>：轻松地在形状全局特征向量上训练SVM或多层感知器分类器以进行分类。</p><p><strong>点云的分割</strong>：需要结合局部信息和全局信息。将全局特征向量与每一个点的特征联合起来再送回每个点特征（feed it back to per point features）。再基于此提取每个新点的特征，这样每个点特征既了解本地信息又了解全局信息。（个人理解：由于需要对逐点的语义分割，所以将<em>global feature</em> 与每一点的feature向量连接，作用是使每一个点都同时具有自身点的feature和global feature，更有利于进行逐点的分类。）</p><p>（附录）分割网络是分类网络的扩展。局部特征（第二个feature transform T-net 网络输出）和全局特征（最大池化的输出）联合到一起 for each point。分割网络没有Dropout，训练参数与分类网络一样。输出是每n个点的每一个m个语义子类别。</p><p>对比实验：3D CNN Segmentation Network 模型：对于给定的点云，我们首先将其转换为具有32×32×32分辨率的占用网格的体积表示形式。然后，依次应用五个3D卷积运算，每个具有32个输出通道，步幅为1。 每个体素的感受野为19。 最后，将内核大小为1×1×1的3D卷积层序列附加到计算的特征图中，以预测每个体素的分割标签。</p><p><img src="/images/20200111_3DCNN.jpg" alt="20200111_3DCNN"></p><p>（附录）<strong>零件part分割</strong>。我们添加了一个ont-hot向量表明输入的类别，并将它和最大池化层的输出拼接。我们还在某些层layer增加神经元并添加了跳过链接以收集不同层中的局部点特征，并将它们连接起来以形成点特征输入到分割网络中。</p><p><img src="/images/20200111PartSegmentation.jpg" alt="20200111PartSegmentation"></p><p>通过这种修改，我们的网络能够预测依赖于局部几何和全局语义的每点数量。 例如，我们可以准确地预测每个点的法线（补充图），从而验证网络能够汇总该点的局部邻域的信息？。 </p><h5 id="3-2-3-对齐网络-Joint-Alignment-Network"><a href="#3-2-3-对齐网络-Joint-Alignment-Network" class="headerlink" title="3.2.3 对齐网络 Joint Alignment Network"></a>3.2.3 对齐网络 Joint Alignment Network</h5><p>如果点云经过某些几何变换（例如刚性变换），则该点云的语义标记必须不变。因此，我们期望通过网络学习到的表征（特征）对于这些变换是不变的。</p><p>我们通过<strong>微型网络（图2中的T-net）预测仿射变换矩阵</strong>（仿射变换前是直线，仿射变换后还是直线，直线比例保持不变。如平移，翻转，拉伸变换等），并将该变换直接应用于输入点的坐标。 T-net网络本身类似于大型网络，由点独立特征提取（point independent feature extraction），最大池化和完全连接层的基本模块组成。 </p><p>这个想法也可以进一步扩展到特征空间的对齐。 我们可以在点特征（point features）上插入另一个对齐网络，并预测一个特征转换矩阵以对齐来自不同输入点云（point clouds）的特征（理解：对齐特征有利于分类）。 然而，特征空间中的变换矩阵具有比空间变换矩阵高（much higher）的维数，这大大增加了优化的难度。 因此，我们在softmax训练损失中添加了一个正则化项。 我们约束特征变换矩阵使其接近正交矩阵</p><script type="math/tex; mode=display">L_{r e g}=\left\|I-A A^{T}\right\|_{F}^{2}</script><p>$A$ 是特征对齐矩阵（由a mini-network T-net预测的），正交变换将不会丢失输入中的信息，因此是需要的。 我们发现通过添加正则项，优化变得更加稳定，并且我们的模型获得了更好的性能。</p><h6 id="3-2-3-1-附录部分解释Network-Architecture-and-Training-Details"><a href="#3-2-3-1-附录部分解释Network-Architecture-and-Training-Details" class="headerlink" title="3.2.3.1 附录部分解释Network Architecture and Training Details"></a>3.2.3.1 附录部分解释Network Architecture and Training Details</h6><p>1，第一个 input transform T-net微型网络是一个minit-PointNet，输入是原始点集并回归到3 * 3大小的矩阵。他是由在每个点上的共享MLP（64，128，1024即CNN）组成，一个最大池化层，两个大小为512，256的全连接网络组成。输出矩阵被初始化为单位矩阵。除最后一层外，所有层均包括ReLU和批处理规范化（batch normalization）。</p><p>2，第二层feature transform T-net微型网络与第一个有相同的结构。除了输出是64*64大小的矩阵。矩阵也是被初始化为单位矩阵。将正则化损失（权重为0.001）添加到softmax分类损失中，以使矩阵接近正交。</p><h3 id="4-理论分析"><a href="#4-理论分析" class="headerlink" title="4 理论分析"></a>4 理论分析</h3><h4 id="4-1-函数逼近"><a href="#4-1-函数逼近" class="headerlink" title="4.1 函数逼近"></a>4.1 函数逼近</h4><p>令$\mathcal{X}=\left\{S: S \subseteq[0,1]^{m} \text { and }|S|=n\right\}$，$f: \mathcal{X} \rightarrow \mathbb{R}$ 是一个在$\mathcal{X}$ 上关于豪斯多夫距离的连续集合函数（set function），即$\forall \epsilon&gt;0, \exists \delta&gt;0, \text { for any } S, S^{\prime} \in \mathcal{X}$，如果$d_{H}\left(S, S^{\prime}\right)&lt;\delta$ ，则$\left|f(S)-f\left(S^{\prime}\right)\right|&lt;\epsilon$。我们的定理说，在最大池化层有足够的神经元的情况下，我们的网络可以任意近似f。PointNet模型的表征能力和maxpooling操作输出的数据维度(K)相关，K值越大，模型的表征能力越强。</p><p>Theorem 1：假设$f: \mathcal{X} \rightarrow \mathbb{R}$ 是一个关于豪斯多夫距离 $d_{H}(\cdot, \cdot)$ 的连续集合函数，对$\forall \epsilon&gt;0, \exists$ 一个连续函数 $h$ 和一个对称函数 $g\left(x_{1}, \ldots, x_{n}\right)=\gamma \circ M A X$，对任何$S \in \mathcal{X}$ ，</p><script type="math/tex; mode=display">\left|f(S)-\gamma\left(\underset{x_{i} \in S}{\operatorname{MAX}}\left\{h\left(x_{i}\right)\right\}\right)\right|<\epsilon</script><p>此处 $x_1, \dots,x_n$ 是任意顺序的S的全部元素。$\gamma$ 是一个连续函数，MAX是一个向量最大操作。</p><p>定理证明看论文补充材料（ supplementary material. ）</p><p>个人理解：表达式的意思是可以找出一个函数r，向量元素$x_i$经过$h$，足够多的神经元的MAX操作和r函数后任意近似原函数 $f(S)$，而$h$  在文章里值的是许多的卷积函数，MAX是最大池化函数，r是全连接分类映射网络。原函数$f(S)$ 可以想成是S是原所有点的特征空间，f是对原特征空间映射为点云物体的函数。</p><h4 id="4-2-瓶颈与稳定性"><a href="#4-2-瓶颈与稳定性" class="headerlink" title="4.2 瓶颈与稳定性"></a>4.2 瓶颈与稳定性</h4><p>理论上和实验上，我们发现网络的表现力受到最大池化层的尺寸（即（1）中的K）的强烈影响。</p><p>定义：$\mathbf{u}=\underset{x_{i} \in S}{\operatorname{MAX}}\left\{h\left(x_{i}\right)\right\}$ 是f的子网络，它映射 a point set in $[0,1]^m$ 为K维的向量。输入集中的小损坏或额外的噪声点不太可能改变网络的输出：</p><p>Theorem 2：假设$\mathbf{u}: \mathcal{X} \rightarrow \mathbb{R}^{K}$ ，$\mathbf{u} = {MAX}_{x_{i} \in S}\left\{h\left(x_{i}\right)\right\}$ 且 $f=\gamma \circ \mathbf{u}$ ，则：</p><script type="math/tex; mode=display">\text { (a) } \forall S, \exists \mathcal{C}_{S}, \mathcal{N}_{S} \subseteq \mathcal{X}, f(T)=f(S) \text { if } \mathcal{C}_{S} \subseteq T \subseteq \mathcal{N}_{S}</script><script type="math/tex; mode=display">(b)\left|\mathcal{C}_{S}\right| \leq K</script><p>a说明对于任何输入数据集S，可以找到最小集Cs和一个最大集Ns，使得对Cs和Ns之间的任何集合T，其网络输出都和S一样。模型对输入数据在有噪声(引入额外的数据点，趋于Ns)和有数据损坏(缺少数据点，趋于Cs)的情况都是<strong>鲁棒</strong>的。定理2(b)说明了最小集Cs的数据多少由maxpooling操作输出数据的维度K给出上界。</p><p>直观地，我们的网络学习通过稀疏的关键点来总结形状。在实验部分，我们看到关键点形成了对象的骨架。（实验部分请参考下一篇博客）</p><h3 id="5-PointNet-改进部分"><a href="#5-PointNet-改进部分" class="headerlink" title="5 PointNet++改进部分"></a>5 PointNet++改进部分</h3><p>简单说一下POINTNET的缺点是没有考虑点之间的局部关系。POINTNET++ 进行了改进。</p><p>提取一个点的局部特征。一个图片像素点的局部是其周围一定曼哈顿距离下的像素点，通常由卷积层的卷积核大小确定。同理，点云数据中的一个点的局部由其周围给定半径划出的球形空间内的其他点构成。组合层的作用就是找出通过采样层后的每一个点的所有构成其局部的点，以方便后续对每个局部提取特征。</p><p>特征提取层（feature learning）：因为PointNet给出了一个基于点云数据的特征提取网络，因此可以用PointNet对组合层给出的各个局部进行特征提取来得到局部特征。</p><p>分组层，在上一层提取出的中心点的某个范围内寻找最近个k近邻点组成patch；特征提取层是将这k个点通过小型pointnet网络进行卷积和pooling得到的特征作为此中心点的特征，再送入下一个分层继续。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，知乎PointNet解读 <a href="https://zhuanlan.zhihu.com/p/44809266" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44809266</a></p><p>2，Point perception <a href="http://mech.fsv.cvut.cz/~dr/papers/CC05/node6.html" target="_blank" rel="noopener">http://mech.fsv.cvut.cz/~dr/papers/CC05/node6.html</a></p><p>3，仿射变换概念：<a href="https://www.zhihu.com/question/20666664" target="_blank" rel="noopener">https://www.zhihu.com/question/20666664</a></p><p>4，豪斯多夫距离 <a href="https://www.cnblogs.com/icmzn/p/8531719.html" target="_blank" rel="noopener">https://www.cnblogs.com/icmzn/p/8531719.html</a> （即 A集合中的任一点ai 到集合B中的任意点的最短的距离di，然后在这些距离di中选择距离<strong>最长（远）</strong>的，即作为两个集合A与B之间的Hausdoff Distance。豪斯多夫距离量度度量空间中紧子集之间的距离。）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Abs-amp-Intro&quot;&gt;&lt;a href=&quot;#1-Abs-amp-Intro&quot; class=&quot;headerlink&quot; title=&quot;1 Abs &amp;amp; Intro&quot;&gt;&lt;/a&gt;1 Abs &amp;amp; Intro&lt;/h3&gt;&lt;p&gt;点云是一种重要的几何数据结构（自动驾驶的数据），由于不规则性许多研究者之前用3D体素网络 voxel grids（体积CNN：[28、17、18]是在体素化形状上应用3D卷积神经网络的先驱。由于数据稀疏性和3D卷积的计算成本，体积表示受到其分辨率的限制。）或图片集合（将点云数据投影到二维平面，扩展性以及提取特征的表示能力的限制。）来进行识别，但这使得数据变庞大，引入了量化伪像，这些伪像会掩盖数据的自然不变性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="三维点云" scheme="http://yoursite.com/tags/%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91/"/>
    
  </entry>
  
</feed>
