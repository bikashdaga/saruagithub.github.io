<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WangXue</title>
  
  <subtitle>1 笨笨的孩子慢慢学stay hungry stay foolish 2 武汉加油！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-19T03:04:36.249Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WangXue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从优化角度看L1正则化的稀疏性</title>
    <link href="http://yoursite.com/2020/04/18/20200418%E4%BB%8E%E4%BC%98%E5%8C%96%E8%A7%92%E5%BA%A6%E7%9C%8BL1%E6%AD%A3%E5%88%99%E5%8C%96%E7%9A%84%E7%A8%80%E7%96%8F%E6%80%A7/"/>
    <id>http://yoursite.com/2020/04/18/20200418%E4%BB%8E%E4%BC%98%E5%8C%96%E8%A7%92%E5%BA%A6%E7%9C%8BL1%E6%AD%A3%E5%88%99%E5%8C%96%E7%9A%84%E7%A8%80%E7%96%8F%E6%80%A7/</id>
    <published>2020-04-18T14:02:03.000Z</published>
    <updated>2020-04-19T03:04:36.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>大数据背景的几个特点：量大large scale，实时性动态产生数据，结构化/半结构化数据，可信赖程度低（Noise，考虑模型如何更robust），高维度且稀疏的数据集。</p><p>这里主要说高维稀疏数据带来的一些问题：</p><p>$x=\left(x_{1}, x_{2}, \cdots, x_{p}\right)$,  特征是p维，数据样例有n个，即整个dataset是 n × p ，传统的统计方法适用于一些 n  &gt; p 的情况，但是当 n &lt;&lt; p的时候，数据量小，但想要求的参数又很多的时候就有困难了。</p><a id="more"></a><h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><p>从最基本的模型开始来看如何解决这个问题。</p><p>X 代表输入，Y代表输出，$\varepsilon$ 是误差项。</p><script type="math/tex; mode=display">Y=f(X)+\varepsilon</script><p>监督学习，给出数据集 $\left(X_{1}, Y_{1}\right),\left(X_{2}, Y_{2}\right), \ldots,\left(X_{n}, Y_{n}\right)$，如何估计出 $f(X)$ 呢？</p><p>也可以用一些非参数的方法：如用KNN….</p><p>还可以考虑参数方法：施加一些参数进去，我们去估计参数 $\beta_i$</p><script type="math/tex; mode=display">Y=\beta_{1} X^{1}+\beta_{2} X^{2}+\cdots+\beta_{k} X^{p}+\varepsilon=\beta^{T} X</script><p>(这里我们比如我们画图看后，根据领域知识等，假设 f(X) 是线性的等，就用LR模型来看。)</p><p>常用方法用最小二乘法（即最小化平方损失函数）：</p><script type="math/tex; mode=display">\min \sum_{i=1}^{n}\left(Y_{i}-\beta^{T} X_{i}\right)^{2}=\|Y-X \boldsymbol \beta\|^{2}</script><ul><li>这样求解 $\beta$ 会得到很好的统计性质</li><li>问题存在：处理高维数据的时候 $X \in R^{n \times p}$ ，这个问题的解有多个，要取哪个？如果求解的话可以这里可以去写写 $|Y-X \boldsymbol \beta|^{2}$ 的最优性条件 KKT条件有：$X^TX \boldsymbol\beta = X^TY$ ，而这里的 $X^TX$ 是non singular，不可逆，求解有困难。</li><li>可解释性也不太好，这个得到的 $\beta_i$ 一般都是不为0，那Y到底跟哪个X有关呢，怎么找重要的因素去解释呢？</li><li>高维的时候可以考虑降维，如PCA，但也有问题，$x_1,…x_p$ 利用线性组合到一起，把某几个因素合为一个新变量，但新变量的解释也不好说。</li></ul><h3 id="Sparse-Optimization"><a href="#Sparse-Optimization" class="headerlink" title="Sparse Optimization"></a>Sparse Optimization</h3><h4 id="sparse-Optimization"><a href="#sparse-Optimization" class="headerlink" title="sparse Optimization"></a>sparse Optimization</h4><p>考虑用稀疏优化来解决。</p><p>定义稀疏结构 sparse structure：$x \in R^{p}$ 如果仅仅有少部分非0值，则称为sparse vector。</p><p>定义0范式：$||x||_0= \left\{i: x_{i} \neq 0\right\}$ 即是$x_i \neq 0$ 的个数 （如 x = (0,0,1), 则其0范数值为1）</p><p>稀疏数据问题：$||x||_0 &lt;&lt; p$  </p><p>个数限制优化 (Cardinality constrained Optimization)方法：</p><script type="math/tex; mode=display">min \|Y-X \boldsymbol \beta\|^{2}</script><script type="math/tex; mode=display">s.t. \|\boldsymbol \beta\|_{0} \leqslant k \quad(k<< p)</script><p>意思：最小化误差，但有约束存在 $\beta$ 的0范数小于等于 k，只有k个系数不为0，即Y只跟少数的k个X变量有关，解释性就加上了。</p><h4 id="Integer-Programming"><a href="#Integer-Programming" class="headerlink" title="Integer Programming"></a>Integer Programming</h4><p>我们把上面这个优化改写成一个整数规划来看：</p><script type="math/tex; mode=display">\min \|Y-x \beta\|^{2}</script><script type="math/tex; mode=display">s.t. \sum_{i=1}^p S_i \leq k</script><script type="math/tex; mode=display">S_i = 0 \quad or \quad 1</script><script type="math/tex; mode=display">\left|\beta_{i}\right| \leq M S_{i} , M - EnoughBig</script><p>类似一个设施选址问题的写法：两阶段，第一选不选：Si表示选不选，选了变量$X_i$，$S_i$就是1；coefficiency系数，$\beta_i$表示系数。</p><p>这样改写之后，就可以用部分求解器如CVX , Gurobi求解中等规模的问题。但是如果规模太大（ 即 p 非常大）就不好求解了。</p><h4 id="凸近似"><a href="#凸近似" class="headerlink" title="凸近似"></a>凸近似</h4><p>那我们转换整数规划为凸优化来解：</p><p><img src="/images/20200418convex_optimization.jpg" alt="20200418convex_optimization"></p><p>具体来看怎么转换的凸优化呢？</p><p><img src="/images/20200418convexification.jpg" alt="20200418convexification"></p><p>一维情况（左图）：</p><p>我们要去凸近似这个 f(x) 即zero-norm（0范数函数），当x=0时f(x)=0，当x在$-\tau \leqslant x \leqslant \tau$ （这里的$\tau$ 只是表示一个范围，可以取很大，这为了好看）时，f(x) = 1。</p><p>函数图画出来是上面那一根黑线（除开x=0中间那个空点，这个不好处理），怎么去凸近似这个函数呢？我们用函数 g(x) 去近似，即红色那个线把三个点连起来，这是最简单的，也可以考虑用二次函数椭圆形来近似也可以：</p><script type="math/tex; mode=display">g(x) = \frac{|x|}{\tau}</script><p>二维情况（右图）：</p><p>二维的情况也可以画图来分析：就是最下面中心那个点，加上面的十字线除开中间那个点（x其中一个为1），加上最上面为2的面：</p><script type="math/tex; mode=display">f(x) = ||x||_0 = \left\{\begin{array}{ll}0, & \text { If } x=0 \\ 1, & \text { If } x_{1}=0, x_{2} \neq 0 \text { or } \\ & x_{1} \neq 0, x_{2}=0 \\ 2, & \text { If } x_{1} \neq 0, x_{2} \neq 0\end{array}\right.</script><p>这里的凸近似，将下面的四根虚线连起来（延展上去也连上面的四个红点），就是g(x)：</p><script type="math/tex; mode=display">g(x) = \frac{1}{\tau}(\left|x_{1}\right|+\left|x_{2}\right|)</script><p>看看上面一维、二维的情况，都与绝对值有关，是不是还有点像L1正则化的样子，我们接着看。我们总结下zero norm0范式的凸近似是：</p><script type="math/tex; mode=display">\|x\|_{0}:\tau (\|x\|_{1}) = \tau \sum_{i=1}^n |x_i|</script><p>即存在一个 $\tau$ ，使得$\tau (|x|_{1})$ 是$|x|_{0}$最好的凸近似。</p><h3 id="Sparse-Linear-Regression"><a href="#Sparse-Linear-Regression" class="headerlink" title="Sparse Linear Regression"></a>Sparse Linear Regression</h3><h4 id="typical-sparse-model"><a href="#typical-sparse-model" class="headerlink" title="typical sparse model"></a>typical sparse model</h4><p>回忆之前的LR模型：</p><script type="math/tex; mode=display">min \|Y-x \boldsymbol\beta\|^{2}</script><script type="math/tex; mode=display">s.t.:\|\boldsymbol\beta\|_{0} \leqslant k</script><p>这里的约束我们就可以用前面推导的一范数来近似了：</p><script type="math/tex; mode=display">\|\boldsymbol\beta\|_{1} = \sum_{i=1}^p |\beta|_{i} \rightarrow \|\boldsymbol\beta\|_{0}</script><p>上面的模型可以改写为：</p><script type="math/tex; mode=display">min \|Y-x \beta\|^{2}</script><script type="math/tex; mode=display">s.t. \tau\|\beta\|_{1} \leqslant k \quad (即\|\beta\|_{1} \leqslant \lambda)</script><p> 这里的$\lambda$ 自己取。这就产生了新的模型了。</p><p>我们用图形说明看看，sparsity 是真的有的：</p><p><img src="/images/20200419sparsity_model.jpg" alt="20200419sparsity_model"></p><p>左下图：C越大椭圆越大。如果是$|\beta|_{1} \leqslant \lambda$则相交点在坐标轴上，往往是左下图红色点那里，而这个地方则很好的可见 $\beta$ 参数的非0个数  &lt; P=2了。但如果看右边图，采用 $|\beta|_{2}$ 则相交在中间，$\beta$参数的非0个数  =  P（2）了，那$\beta$ 全部都不为0，没有起到稀疏作用。</p><h4 id="Lagrange-version"><a href="#Lagrange-version" class="headerlink" title="Lagrange version"></a>Lagrange version</h4><p>我们再改写下上面的模型为拉格朗日版本，将约束放到上面相当于拉格朗日乘子：</p><script type="math/tex; mode=display">min\|Y-x \beta\|^{2}+{\mu}_{1}\|\beta\|_{0} \rightarrow min \|Y-x \beta\|^{2}+{\mu}_{2}\|\beta\|_{1}</script><p>这里看就是既要看损失，又要看稀疏性，这两者之间有个tradeoff平衡选择。</p><p>右侧这边这个模型，在统计中也叫做lasso模型，也就是L1正则化。</p><p><br></p><p><br></p><p>总结一下，在线性回归中，我们遇到了一个高维的问题导致了参数的不稀疏，无法较好的解释。我们用稀疏优化来解决这个问题，我们把选择部分参数不为0（不为0的参数个数）这个zero norm用凸近似来做，将其转换为绝对值这个凸函数，进过改写为拉格朗日形式后，这个约束就成了L1正则化的形式。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，南京大学，陈彩华 《高级最优化》</p><p>2，《最优化》陈宝林</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;大数据背景的几个特点：量大large scale，实时性动态产生数据，结构化/半结构化数据，可信赖程度低（Noise，考虑模型如何更robust），高维度且稀疏的数据集。&lt;/p&gt;&lt;p&gt;这里主要说高维稀疏数据带来的一些问题：&lt;/p&gt;&lt;p&gt;$x=\left(x_{1}, x_{2}, \cdots, x_{p}\right)$,  特征是p维，数据样例有n个，即整个dataset是 n × p ，传统的统计方法适用于一些 n  &amp;gt; p 的情况，但是当 n &amp;lt;&amp;lt; p的时候，数据量小，但想要求的参数又很多的时候就有困难了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>组合优化问题的启发式算法</title>
    <link href="http://yoursite.com/2020/04/15/20200415%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/15/20200415%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-15T04:25:01.000Z</published>
    <updated>2020-04-15T14:31:26.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组合优化问题"><a href="#组合优化问题" class="headerlink" title="组合优化问题"></a>组合优化问题</h3><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p>车辆路径规划问题，n位客户，在不同地点，有需求。在中央仓库有m辆车辆的均质车队。这是一个NP难问题，这类问题中，启发式和元启发式是实践中最常用的VRP解决方案。</p><p>启发式算法：模拟退火，遗传算法，蚁群优化算法等。</p><h4 id="NP难问题的一些解决方法"><a href="#NP难问题的一些解决方法" class="headerlink" title="NP难问题的一些解决方法"></a>NP难问题的一些解决方法</h4><p>1，精确方法（枚举，约束编程，分支定界，分支与剪切）是非多项式的，通常可以处理一定规模的问题实例（如旅行商问题TSP的80000节点）。</p><a id="more"></a><p>大量的问题实例可以有效地解决（例如，区间图的顶点着色问题）</p><p>2，一些指数算法仅取决于问题实例的一个参数=&gt;参数化算法（包括伪多项式算法）</p><p>3，近似算法</p><p>4，随机算法</p><p>5，启发式方法和元启发式方法可以视为最后的选择。但他们生成的解决方案没有任何性能保证。</p><h3 id="局部搜索启发式"><a href="#局部搜索启发式" class="headerlink" title="局部搜索启发式"></a>局部搜索启发式</h3><h4 id="局部搜索"><a href="#局部搜索" class="headerlink" title="局部搜索"></a>局部搜索</h4><p>局部搜索启发式迭代地优化解。 它枚举了导致新解（称为邻居neighbor）的可能更改（move）的列表，并在改进的情况下应用这些更改（接受更好的解）。</p><p><img src="/images/20200415local_search1.jpg" alt="20200415local_search1"></p><p>仅应用这些邻域会导致问题的局部最优，这可能与最佳解决方案（全局最优）大不相同。需要设计了几种策略来摆脱这些局部最优值，并继续在其他地区进行搜索。</p><h4 id="解决局部最优"><a href="#解决局部最优" class="headerlink" title="解决局部最优"></a>解决局部最优</h4><p>1，允许坏解的运动 deteriorating moves（模拟退火）</p><p>2，在解决方案上施加扰动perturbation以将其移至其他位置</p><p>3，更改邻居（可变邻居搜索<em>variable neighborhood search</em>）</p><p>4，惩罚当前的局部最优值</p><p>5，同时保留多个解（填充），然后将它们交叉在一起以生成新的起点（带有交叉算子的遗传算法）</p><p>6，重复一个建设性的过程来创建新解，并根据先前解中的成功（信息素）来促进良好的建设决策（如蚁群优化/强化学习）。</p><h4 id="metaheuristic定义"><a href="#metaheuristic定义" class="headerlink" title="metaheuristic定义"></a>metaheuristic定义</h4><p>元启发法被正式定义为一种迭代生成过程，该过程通过组合智能的不同概念来探索和利用搜索空间来引导从属启发法，并使用学习策略来构造信息，以便有效地找到接近最优的解决方案</p><p>一些特点：目标是有效地探索搜索空间以找到高质量的解，允许逃出局部最优，方法的抽象级别描述，元启发法通常是不确定的，最近的元启发法会从他们过去的搜索经验中“学习”以指导搜索。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;组合优化问题&quot;&gt;&lt;a href=&quot;#组合优化问题&quot; class=&quot;headerlink&quot; title=&quot;组合优化问题&quot;&gt;&lt;/a&gt;组合优化问题&lt;/h3&gt;&lt;h4 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h4&gt;&lt;p&gt;车辆路径规划问题，n位客户，在不同地点，有需求。在中央仓库有m辆车辆的均质车队。这是一个NP难问题，这类问题中，启发式和元启发式是实践中最常用的VRP解决方案。&lt;/p&gt;&lt;p&gt;启发式算法：模拟退火，遗传算法，蚁群优化算法等。&lt;/p&gt;&lt;h4 id=&quot;NP难问题的一些解决方法&quot;&gt;&lt;a href=&quot;#NP难问题的一些解决方法&quot; class=&quot;headerlink&quot; title=&quot;NP难问题的一些解决方法&quot;&gt;&lt;/a&gt;NP难问题的一些解决方法&lt;/h4&gt;&lt;p&gt;1，精确方法（枚举，约束编程，分支定界，分支与剪切）是非多项式的，通常可以处理一定规模的问题实例（如旅行商问题TSP的80000节点）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合优化" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="启发式算法" scheme="http://yoursite.com/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="优化算法" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>TreeNode树(PartI遍历)</title>
    <link href="http://yoursite.com/2020/04/15/20200415TreeNode%E6%A0%91(PartI%E9%81%8D%E5%8E%86)/"/>
    <id>http://yoursite.com/2020/04/15/20200415TreeNode%E6%A0%91(PartI%E9%81%8D%E5%8E%86)/</id>
    <published>2020-04-15T00:50:22.000Z</published>
    <updated>2020-04-15T03:11:42.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><p>TreeNode结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x),left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>二叉树：由一个根节点及两颗不相交的二叉树组成。</p><p>满二叉树：每一个结点或者是一个分支结点，并恰好有两个非空的子节点。</p><p>飞空满二叉树的叶结点数等于其分支结点数+1。</p><p>完全二叉树：严格的形状要求，从根节点起每一层从左到右填充。一棵高度为d的完全二叉树，除了d-1层以外，每一层都是满的。（完全二叉树不一定是满二叉树）</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="普通递归遍历"><a href="#普通递归遍历" class="headerlink" title="普通递归遍历"></a>普通递归遍历</h4><p>前序遍历，中序遍历，后序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_preoder0</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    travel_preoder0(root-&gt;left);</span><br><span class="line">    travel_preoder0(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要返回遍历结果的话，存vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; travel_preorder1(TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        travel_preorder1(root-&gt;left);</span><br><span class="line">        travel_preorder1(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用stack辅助前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_preoder2</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; Stk;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        Stk.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Stk.empty()) &#123;</span><br><span class="line">        root = Stk.top();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        Stk.pop();</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            Stk.push(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            Stk.push(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于stack是先入后出，前序遍历的话，root访问之后，先将right右结点放入stack里，再将left左子节点放入stack。但这样写不好写中序遍历和后序遍历的。</p><h4 id="迭代前序遍历算法"><a href="#迭代前序遍历算法" class="headerlink" title="迭代前序遍历算法"></a>迭代前序遍历算法</h4><p>注意节点入stack的顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代前序遍历算法，每到一个节点 A，就应该立即访问它。在访问完根节点后，遍历左子树前，要将右子树压入栈。</span></span><br><span class="line"><span class="comment">//时间复杂度为 O(n)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode* rt = root;</span><br><span class="line">    <span class="keyword">while</span> (rt || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (rt) &#123;</span><br><span class="line">            <span class="comment">//root,left,right</span></span><br><span class="line">            stk.push(rt-&gt;right);</span><br><span class="line">            ans.push_back(rt-&gt;val);<span class="comment">//first root</span></span><br><span class="line">            rt = rt-&gt;left; <span class="comment">// then left</span></span><br><span class="line">        &#125;</span><br><span class="line">        rt = stk.top();<span class="comment">//finally right</span></span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历完整棵树后，结果序列逆序即可。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    TreeNode* rt = root;</span><br><span class="line">    <span class="keyword">while</span>(rt || S.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">            <span class="comment">//root,right,left,then reverse</span></span><br><span class="line">            S.push(rt-&gt;left);</span><br><span class="line">            v.push_back(rt-&gt;val);</span><br><span class="line">            rt=rt-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        rt=S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inorder 中序迭代遍历树</span></span><br><span class="line"><span class="comment">//每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    TreeNode* rt = root;</span><br><span class="line">    <span class="keyword">while</span> (rt || S.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (rt) &#123;</span><br><span class="line">            <span class="comment">// all left</span></span><br><span class="line">            S.push(rt);</span><br><span class="line">            rt = rt-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mid</span></span><br><span class="line">        rt = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        v.push_back(rt-&gt;val);</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        rt = rt-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>逐层遍历，先根再左边右边逐层访问下来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; DequeTreeNode;</span><br><span class="line">    DequeTreeNode.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!DequeTreeNode.empty()) &#123;</span><br><span class="line">        TreeNode* pNode = DequeTreeNode.front();</span><br><span class="line">        DequeTreeNode.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pNode-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;left) &#123;</span><br><span class="line">            DequeTreeNode.push(pNode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right) &#123;</span><br><span class="line">            DequeTreeNode.push(pNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;树结构&quot;&gt;&lt;a href=&quot;#树结构&quot; class=&quot;headerlink&quot; title=&quot;树结构&quot;&gt;&lt;/a&gt;树结构&lt;/h3&gt;&lt;p&gt;TreeNode结构：&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode* left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode* right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x):val(x),left(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;),right(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="TreeNode" scheme="http://yoursite.com/tags/TreeNode/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CauseInfer论文(Part Ⅱ)</title>
    <link href="http://yoursite.com/2020/04/14/20200414CauseInfer%E8%AE%BA%E6%96%872/"/>
    <id>http://yoursite.com/2020/04/14/20200414CauseInfer%E8%AE%BA%E6%96%872/</id>
    <published>2020-04-14T09:29:40.000Z</published>
    <updated>2020-04-17T12:42:27.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CauseInfer的系统概述与工作流"><a href="#CauseInfer的系统概述与工作流" class="headerlink" title="CauseInfer的系统概述与工作流"></a>CauseInfer的系统概述与工作流</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>两层因果关系图</strong>：将诊断问题公式化为根因推断问题。为了推断服务和系统指标之间的根本原因，我们将运行中的分布式系统映射到<u>两层分层的因果关系图 two layered hierarchical causality graph。</u> 因果关系图中的每个有向边代表直接的“因果关系”关系。“因果关系cause effect”的合理基础是 原因指标cause metric的变化会导致影响指标effect metric的变化。</p><a id="more"></a><p><strong>较高的层</strong>是<u>由服务依赖关系组成的粗粒度因果关系图</u>，用于将故障原因定位到正确的服务。与NetMedic [15]不同，我们通过分析两个服务之间的通信延迟相关性（traffic lag correlation）来构造服务依赖关系图。</p><p><strong>较低的层</strong>是<u>由系统指标组成的细粒度因果关系图</u>，用于定位到正确的指标。指标因果关系图是通过“因果关系cause effect”概念而不是传统的“相关correlation”概念构建的。</p><p><br></p><h4 id="CauseInfer的工作流workflow"><a href="#CauseInfer的工作流workflow" class="headerlink" title="CauseInfer的工作流workflow"></a>CauseInfer的工作流workflow</h4><p> <strong>CauseInfer的核心模块是因果图生成器和推理引擎。</strong></p><p>因果关系图构建器可以使用收集的系统指标自动构建因果关系图。 </p><p>推论引擎负责推导因果关系图中的真正罪魁祸首。 </p><p>在目标云系统中，每个节点都维护一个指标因果图。 </p><p>推断inference是由前端中的SLO违规触发的，然后沿着服务依赖关系图中的路径从前端服务迭代传递到后端服务。</p><p>如果在一个节点中检测到SLO违规，则根据指标因果关系图进行细粒度的推断。 在本文中，我们将使用第4.1节中描述的统一指标标准<u>TCP请求延迟</u>来表示特定服务的SLO度量标准。</p><p><img src="/images/20200415CauseInfer_pig1.jpg" alt="20200415CauseInfer_pig1"></p><p>CauseInfer的基本结构和工作流程。 最底层是三层系统的物理拓扑。 顶部是抽象的服务和指标因果关系图。 在因果关系图中，大虚线圆圈表示服务，红色节点表示根本原因，黑色节点表示性能指标，绿色节点表示SLO指标，弧线表示因果关系，箭头表示方向 故障传播。</p><p><strong>举例</strong>：我们假设服务II节点中的指标E是根本原因。 当检测到服务I的SLO违反时，将触发原因推断。 在对服务I节点进行原因推断后，我们将性能异常定位于指标A。指标A是服务II的响应时间，它也是服务I指标因果关系图中的根本原因节点。异常A意味着 服务II的SLO被违反。 </p><p>因此，服务II节点中的根因推断被触发，并根据该节点的指标因果关系图继续进行推断。 最后，我们获得了根本原因，度量E。整个推理路径为SLO→A→D→E。</p><p>值得注意的是，由于统计误差和系统噪声，结果可能包含多个度量。 因此，必须有根因排名过程来减少误报并选择最可能的根本原因。</p><p><br></p><p><br></p><h3 id="系统设计——系统模块简介"><a href="#系统设计——系统模块简介" class="headerlink" title="系统设计——系统模块简介"></a>系统设计——系统模块简介</h3><p>如图3所示，CauseInfer系统主要包含两部分，即<strong>离线因果图构建和在线原因推断</strong>。 </p><p>在线部分包含两个模块，即数据收集模块和原因推断模块。 数据收集模块从特定节点中的多个数据源收集实时系统指标，并将<u>数据存储在时间序列数据库</u>中。 当检测到违反SLO时，将触发根因推断模块。 该模块负责根据因果图生成器生成的<u>因果图来精确定位和排序根因</u>。 最后，获得包含最可能原因的原因列表。</p><p> 离线部分包含三个模块，即预处理模块，突变点检测模块和因果图构建模块。 预处理模块在发送到下一阶段之前会对数据进行一些修改。 突变点change point detection检测模块使用贝叶斯change point检测方法将每个预处理指标转换为二进制数据序列。 因果关系图模块利用二值化数据来构建两层分层的因果关系图。 在下文中，我们将详细描述这些模块。</p><p><img src="/images/20200415CauseInfer_fig4.jpg" alt="20200415CauseInfer_fig4"></p><p><br></p><h3 id="系统设计——详述"><a href="#系统设计——详述" class="headerlink" title="系统设计——详述"></a>系统设计——详述</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><p><strong>时序数据收集</strong>：我们的目标是确定由根本原因（例如配置错误，过载，资源占用，软件错误等）引起的性能问题的根源。因此，<u>数据收集模块应收集足够多的运行时信息</u>，从应用程序、流程processes到操作系统的不同软件堆栈的多个数据源。当前CauseInfer仅支持数字数据，但不包括非数字数据，例如日志事件，非数字配置项等。</p><p><strong>SLO标准指标TCP时延</strong>：对于基于云或以云为中心的服务，最终用户体验是关键。一个特定应用程序的SLO指标（例如响应时间）可以直接显示最终用户的体验。SLO指标针对不同的应用程序而有所不同。因此，我们提出了一个<u>新的统一SLO度量标准，即TCP请求等待时间（TCP LATENCY）</u>。通过测量通过特定网络端口的最后一个入站数据包（即请求）和第一个出站数据包（即响应）之间的等待时间来获得TCP延迟。尽管此指标很简单，但在我们的系统中效果很好。</p><p><strong>其他指标获取</strong>：对于与流程processes和操作系统相关的指标，我们使用操作系统随附的工具（例如，Linux OS中的/ proc文件系统）收集它们。 除了两个指标标准（即每个进程发送的数据包数量以及内核空间和用户空间的锁lock状态）外，大多数系统度量标准都可以通过这种方式获得。 为了获得前一个指标，我们通过探测与网络传输相关的kprobes [20]（例如netdev.transmit）来捕获信息。 同样，我们通过探测相应的Kprobes来捕获锁定状态。 这些Kprobes已合并到主流Linux操作系统中。</p><p><br></p><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p><strong>Data aggregation</strong>：看到一个应用程序生成多个具有相同名称的进程processes来提供服务的情况并不少见。 例如，Apache httpd在Linux操作系统中总是生成多个具有相同名称“ httpd”的进程来处理Web请求。 在这种情况下，我们将这些流程的绩效指标聚合在一起。</p><p><strong>Metric selection</strong>：图4，一些指标高度相关correlation，需要减少冗余指标。</p><p><u>指标选择以简单的成对方式进行</u>：如果两个指标的Pearson相关系数的绝对值超过预设阈值（在本文中为0.8），则将其中一个消除。 例如，在图5中，CPU Int和CPU Irq的相关系数接近1。因此，我们将从CPU Int和CPU Irq中随机选择一个。</p><p> 但是对于那些预定义的根因指标（例如工作量workload和配置项configuration），我们将始终将其保留在指标集中。</p><p><br></p><p><br></p><p><br></p><h4 id="构建算法"><a href="#构建算法" class="headerlink" title="构建算法"></a>构建算法</h4><h5 id="离线change-point-detection"><a href="#离线change-point-detection" class="headerlink" title="离线change point detection"></a>离线change point detection</h5><p>cause-effect定义：如果一个变量变化导致另一个变量变化，则这俩者有因果关系。</p><p>首先识别系统指标里的changes突变。这可以被认为是离线分割问题。 但是挑战在于细分的数量，每个细分中的统计特征（即均值或方差）事先未知。  我们介绍了一种<strong>基于贝叶斯理论的新颖方法，即贝叶斯变化点检测</strong>（BCP）[22]。 变更点检测过程不仅提取变更，而且以二进制格式统一不同尺度的不同系统的指标，这意味着度量数据仅包含“ 0”（未更改）和“ 1”（更改）。</p><p>BCP的基本思想**（paper的P5）：是找到一个参数的基本序列，该序列将时间序列划分为具有相等参数值的连续块（序列块），并定位突变点的位置，即每个块的开始。</p><p>给定块和参数，不同块中的观测值是相互独立的。 应该给每个块的突变点和参数一个先验的概率分布 $\mu_{i,j}$ （是在位置i+1开始在j结束的块的均值）服从 $N\left(\mu_{0}, \sigma_{2}^{0} /(j-i)\right)$</p><p>给定观测序列：$X=\left(x_{1}, x_{2}, \cdots, x_{n}\right)$ ，目标是找到划分 $\rho=\left(P_{1}, P_{2}, P_{3}, \cdots, P_{n-1}\right)$ ，如果$P_i = 1$ ，则表示位置i+1有一个变化change。$\theta_i$ 表示$x_i$所在的划分P的统计参数。</p><p>Barry报告，参数序列$\theta_i$ 形成一个<strong>马尔可夫链</strong>：以概率$ 1 -p_i$ 假设 $\theta_i = \theta_{i+1}$ ，即$x_i,x_{i+1}$ 是属于相同的划分 ，or或者说以概率 $p_i$ 存在一个条件密度 $f\left(\theta_{i+1} | \theta_{i}\right)$ 。因此，我们使用一个马尔可夫蒙特卡洛法来计算一个近似划分。</p><p>在马尔可夫链的每一层转移，根据观测值的序列和 $P_j$ 的当前值，从$P_i$的条件分布中获得 $P_i$ 的值 ，$j \neq i$。在迭代的开始，我们为所有i都初始化 $P_i = 0$ 。转移概率 $p_i$ ，对于位置 $i+1$ 处的突变点的条件概率可以通过以下公式估计（参考论文22，这些表达式的参数设置）：</p><script type="math/tex; mode=display">\frac{p_{i}}{1-p_{i}}=\frac{\left(P_{i}=1 | X, P_{j}, j \neq i\right)}{\left(P_{i}=0 | X, P_{j}, j \neq i\right)}</script><p>因此我们可以获得 $f\left(P_{i}=1 | X, P_{j}, j \neq i\right)$ 和 随机采样$P_i$ 。在一次MCMC迭代中，为每个$P_{i}(1 \leq i \leq n)$ 产生一个值。每次迭代，后验均值$\mu_{i, j}$ 将根据当前划分进行更新。M次迭代以后，我们利用 $\mu_{i, j}$ 的M个估计的平均值作为给定X的后验均值的近似值。类似地，在给定$X$的情况下，我们可以获得$\sigma^2$的后验估计。同时，获得了概率$p_i$。 本文，M设置为1000足以估计参数。 最后，选择具有高概率 $p_i$ 的突变点（例如，本文中pi&gt; 0.6）作为变化。</p><p>为了评估BCP的有效性，我们利用它来确定从第4节中描述的CPU故障注入实验获得的CPU TOTAL指标的更改点。我们通过手动调查确认在CPU TOTAL度量标准中嵌入了16个更改点。  图5（a）显示了在注入多个CPU hog故障以及BCP检测到更改点时的CPU利用率数据。 从该图可以看出，几乎所有的变化都发生在CPU hot fault期间。 图5（b）表明，在CPU出现hog故障期间发生变化的可能性非常高，远大于0.6。 因此，BCP方法可以有效地识别嵌入在数据序列中的更改。 但是，由于BCP需要较长的历史数据和计算复杂性，因此利用BCP实时检测实时变化并不容易。</p><p><br></p><h5 id="随机图的构建-Causality-graph-building"><a href="#随机图的构建-Causality-graph-building" class="headerlink" title="随机图的构建 Causality graph building"></a>随机图的构建 Causality graph building</h5><p>$X \rightarrow Y$ X直接影响Y，表示为$X \in p a(Y)$ ，不允许两个变量相互影响。 因此，所有因果关系都可以通过有向无环图（DAG）进行编码。在DAG中，节点代表特定变量，边代表因果关系。 我们依靠观察和假设来形成因果关系理论。 </p><h6 id="Service-Dependency-Graph"><a href="#Service-Dependency-Graph" class="headerlink" title="Service Dependency Graph"></a>Service Dependency Graph</h6><p><strong>流量关联方法</strong>是一种通用的轻量级方法，无需更改源代码或准备其他知识。基本思想是两个相关服务之间的流量延迟通常表现出“典型”峰值，反映了使用或提供这些服务之间的潜在延迟。 a，我们的方法仅关注使用<strong>TCP</strong>作为其底层传输协议的有限应用程序集，尽管可以很容易地对其进行扩展。 b， 我们的方法依赖于现代操作系统的新属性，例如网络统计工具和用于探测系统调用的内核探测器。 C，我们利用流量延迟来确定依赖方向，而不是确定依赖结构。</p><p>我们使用<strong>两元组（ip，服务名称）</strong>而不是三元组（ip，端口，协议）来标识服务。在分布式系统中，ip表示唯一的主机，服务名称表示在主机中运行的唯一服务。 我们遵循Orion系统中服务依赖项的定义，即如果服务A需要服务B来满足其客户端A→B的某些请求。例如，Web服务需要从数据库服务维护的数据库中获取内容，因此 我们说Web服务取决于数据库服务。 </p><p>该方法开始于使用连接信息来构造服务依赖图的框架。 借助一些现成的网络监控工具（例如netstat），<u>我们获得了所有服务连接信息的列表</u>，包括协议，源IP，目标IP，端口和连接状态（例如，侦听或已建立）。 然后，我们从一堆由TCP协议标记的实时连接中筛选出源和目标信息。 图6展示了一个节点中选定的连接对样本。 每个连接的格式为 source ip : port → destination ip : port, which is called a <em>channel</em>称为通道。 该通道非常接近服务依赖关系，但缺服务的名称。</p><p>进程ID（即PID）。然后，我们将与PID有关的命令行用作服务名称。</p><p><u>通过网络发现两个通信服务之间的服务依赖关系</u>：为了获得特定服务的发送流量，我们通过探测内核函数netdev.transmit来计数数据包的数量，该函数在网络设备要发送缓冲区内容时调用。 假设X表示服务A的发送流量，Y表示服务B的发送流量，则X和Y之间的滞后相关性lag correlation定义为：</p><script type="math/tex; mode=display">\rho_{X Y}(k)=\frac{\sum_{t=0}^{N-1}\left(Y_{t}-\bar{Y}\right)\left(X_{t-k}-\bar{X}\right)}{\sqrt{\sum_{t=0}^{N-1}\left(X_{t}-\bar{X}\right)^{2} \sum_{t=0}^{N-1}\left(Y_{t}-\bar{Y}\right)^{2}}} k \in</script><script type="math/tex; mode=display">k^{*}=\left\{\operatorname{argmax}\left(\left|\rho_{X Y}(k)\right|\right), k \in[-30,30]\right\}</script><p>if $k^{*}&gt;0 , A \rightarrow B$ </p><p><img src="/images/20200417CauseInfer_fig7.png" alt="20200417CauseInfer_fig7"></p><p>由于资源共享，服务可能依赖于在同一节点中运行的其他服务，这被称为“非通信服务依赖性”。 考虑到这种间接依赖性，我们假设其他服务的性能指标的变化也影响当前关注的服务的性能指标的变化。 我们在指标因果关系图中建模这些依赖关系，在以下部分中进行了说明。</p><h6 id="Metric-Causality-Graph"><a href="#Metric-Causality-Graph" class="headerlink" title="Metric Causality Graph"></a>Metric Causality Graph</h6><p>我们<u>利用条件独立性检验</u>[ 参考 26]而非成对相关 pair-wise correlation 来构建因果关系图。 基于“因果关系cause effect”概念构建因果关系图的方法主要有两种，即条件独立性测试和基于评分score based的方法。 考虑到系统指标的高维性和轻量级需求，我们基于PC算法（unsupervised leaning）设计算法。 </p><p>DAG 有向无环图。两假设：causal Markov condition and faithfulness （31）</p><p>作为区分因果关系和相关性的基本属性，<u>因果马尔可夫条件</u>用于在两个以上变量之间产生一组独立关系，并构造因果图的框架。</p><p>忠实性假设指出存在一个有向无环图，G，使得V中变量之间的独立关系正是通过<u>条件马尔可夫条件</u>并由G表示的[26]。 因果关系可以通过因果马尔可夫条件与忠诚条件相结合来发现。</p><p>在这两个假设下，<u>PC算法根据统计条件独立性检验[26] [31]和D-separation [26] [31]为集体变量构造一个DAG</u>。 在本文中，我们利用基于<u>条件交叉熵的度量$G^2$</u> [31]定性地测试给定 $Z$ 时 $X$ 是否依赖于 $Y$，其中X，Y和Z是V中不相交的变量集，X和Y是单变量，但是 Z可以是一组变量。</p><script type="math/tex; mode=display">\begin{aligned} G^{2} &=2 m C E(X, Y | \mathbf{Z}) \\ &=\sum_{z} P(z) \sum_{x} \sum_{y} P(x, y | z) \log \left(\frac{P(x, y | z)}{p(x | z) \cdot p(y | z)}\right) \end{aligned}</script><p>m: sample size</p><p>$C E(X, Y | \mathbf{Z})$ the conditional cross entropy of X and Y given <strong>Z</strong>.</p><p>度量$G^2$服从$\chi^{2}$ ，自由度是：$\left(N_{X}-1\right)\left(N_{Y}-1\right) \prod_{Z^{\prime} \in \mathbf{Z}} N_{Z^{\prime}}$</p><p>$N_{X}, N_{Y} ,N_{Z^{\prime}}$ 各自代表变量 $X ,Y, Z’$ 的值。卡方测试我们可以决定是否接受独立性假设。$p &gt; \xi$ 接受独立性假设。</p><p>给定 $Z$ 如果 $X$ 独立于 $Y$ ，则 $I(X, Y | \mathbf{Z})=1$</p><p>PC算法从完全连接的无向图开始，然后促进 $G^2$ 以成对方式捕获所有变量中的所有独立关系，即该DAG的骨架。 以下工作是使用D-separation[26]，[32]确定因果关系的方向。</p><p><strong>确定因果关系的方向</strong>：</p><p>我们首先为aggressive（没有先验知识）算法准备系统指标。对于没有任何依赖服务的服务（例如数据库服务），因果关系图仅使用本地系统指标来构建。</p><p>但是对于具有依赖服务（例如Web服务）的因果关系图，不仅使用本地系统度量标准，而且还使用其依赖服务的TCP LATENCY度量标准来构建。</p><p>为了诊断由共置co-located服务引起的性能问题，我们将其系统指标集成到此算法中。本文中训练数据的长度设置为200，因为200个数据点足以建立精确的因果图。</p><p>然后，我们<u>采用PC algorithm构建DAG</u>。由于缺乏证据，统计错误或非因果关系，获得的DAG可能包含多个孤立的子图，违反直觉的因果关系和双向链接。例如，在图8（a）中，M5是隔离的，因果关系M 4→M 2是反直觉的，并且M 1和M 4之间的因果关系是双向的。</p><p>为了从SLO指标推断出根本原因，我们进一步使用以下规则从DAG中选择一个最大子图。规则1：作为最终effect metric的本地服务的TCP LATENCY指标没有后代。</p><p>规则2：最终指标可从图中的任何路径可达。</p><p>规则3：对于双向链接，两个方向均被保留，这意味着两个指标标准可能在彼此之间引起影响。</p><p><img src="/images/20200417fig8a.png" alt="20200417fig8a"></p><p><em>aggressive</em> algorithm in Algorithm 1 伪代码（见paper）：</p><p>step1，设置i=0，即$z=\{\}$ ，选择两个指标用 $G^2$ 方法测试他们的独立性。如SLO独立于在G2（Fig9）中的文件，即$I(S L O, F i l e)=1$ ，则将它们俩之间的边移出。</p><p>step2：然后当i = 1和i=2时，测试独立性。在G6中，给定Mem，SLO条件独立与GC，即$I(S L O, G C | M e m)=1$ ，因此 $M e m \in S(S L O, G C)$ </p><p>step3:当i=3，停止条件$\left|a d j\left(G^{u}, X\right)\right| \leq i, \forall X$ 满足。最终得到架构图如G7。</p><p>step4：接下来，根据算法中提到的规则确定方向。首先，G8 as $\operatorname{Mem} \notin S(F i l e, G C)$ ，然后“Mem —— SLO” 被 “ Mem ——&gt; SLO”替代。</p><p>最终的causality graph如G9。使用因果图G9，可以查明Hadoop-3382错误的根本原因。 CauseInfer首先使用服务依赖关系图将异常定位在名称节点上，然后在G9中沿路径“ SLO→Mem→File”找到根本原因“ File”。</p><p><img src="/images/20200417CauseInferFig9.jpg" alt="20200417CauseInferFig9"></p><p> 在本文中，我们将ξ设置为0.2以在开销和准确性之间进行权衡。</p><p>保守算法：首先要初始化完全无向图Gu中的某些方向。 TCP LATENCY和其他度量标准之间的链接是直接的。 指向预设根本原因指标和其他指标之间的链接。 第二点是在子图选择过程中添加另一个规则，即规则4，因为先验知识得到了补充。</p><p><br></p><h5 id="在线根因推断"><a href="#在线根因推断" class="headerlink" title="在线根因推断"></a>在线根因推断</h5><p>当在前端检测到SLO违规时，将触发原因推断。 我们首先使用指标因果关系图推断本地服务的根本原因。 如果根本原因位于本地服务的从属服务的SLO度量标准上，则将推理过程传播到远程从属服务。 该过程将反复进行，直到未发现任何违反SLO的情况或未找到相关服务为止。 请注意，图中的推断方向与因果方向相反。</p><p>为了实时检测SLO指标和其他系统指标的异常，我们采用流行的CUSUM [8]。$X(t)=\left\{x_{1}, x_{2}, \cdots, x_{t}\right\}$ 代表X的观测序列，如果在包括新的到达数据后统计属性发生变化，则会发生异常。$x_k$ 是否是突变基于对数似然比检验。</p><p>CUSUM statistic score is updated ：</p><script type="math/tex; mode=display">S(k+1)=\left(S(k)+\ln \frac{P_{1}\left(x_{k}\right)}{P_{0}\left(x_{k}\right)}\right)^{+}</script><script type="math/tex; mode=display">(a)^{+}=a \text { if } a>0 ; \text { else }(a)^{+}=0, S(0)=0</script><p>$P_i(x_k)$ 代表假设$H_i$下$x_k$的概率，相应的决策规则是：given a threshold h, 1 represt change</p><script type="math/tex; mode=display">d_{k}(S(k))=\left\{\begin{array}{ll}0 & \text { if } S(k) \leq h \\ 1 & \text { if } S(k)>h\end{array}\right.</script><p>为了推断特定节点中的根本原因，我们使用深度优先搜索（DFS）方法遍历度量因果关系图。当遍历图中的度量时，我们使用CUSUM来检查它是否异常。如果异常，我们将继续遍历其后代。否则，我们遍历其兄弟姐妹。如果没有任何异常指标的后代或所有后代中都没有违规，则将该指标视为根本原因。</p><p>图8（b）为例，当S LO异常时，我们从度量S LO开始推理过程。然后，我们调查指标M1。如果正常，则遍历其同级之一，即M2。如果M2异常，则是根本原因。 M2的另一个兄弟是M3。如果M3异常，我们将继续检查M2。由于M2异常，因此将M2作为根本原因。最终，尽管M 2和M 3均异常，但我们仅找到一个根本原因M 2。但是，在基于“相关”的方法中可能并非如此。由于存在多种因果路径，因此在某些情况下有可能获得一组潜在的根本原因。因此，有必要对最可能的原因进行排名和选择。在本文中，我们根据<u>其CUSUM得分</u>对根本原因进行排名。 CUSUM得分最高的根本原因将放在原因列表的顶部。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, Chen P, Qi Y, Hou D. CauseInfer: automated end-to-end performance diagnosis with hierarchical causality graph in cloud environment[J]. IEEE transactions on services computing, 2016, 12(2): 214-230.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CauseInfer的系统概述与工作流&quot;&gt;&lt;a href=&quot;#CauseInfer的系统概述与工作流&quot; class=&quot;headerlink&quot; title=&quot;CauseInfer的系统概述与工作流&quot;&gt;&lt;/a&gt;CauseInfer的系统概述与工作流&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;两层因果关系图&lt;/strong&gt;：将诊断问题公式化为根因推断问题。为了推断服务和系统指标之间的根本原因，我们将运行中的分布式系统映射到&lt;u&gt;两层分层的因果关系图 two layered hierarchical causality graph。&lt;/u&gt; 因果关系图中的每个有向边代表直接的“因果关系”关系。“因果关系cause effect”的合理基础是 原因指标cause metric的变化会导致影响指标effect metric的变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="faultDiagnosis" scheme="http://yoursite.com/tags/faultDiagnosis/"/>
    
      <category term="RootCause" scheme="http://yoursite.com/tags/RootCause/"/>
    
  </entry>
  
  <entry>
    <title>CauseInfer论文（partI）</title>
    <link href="http://yoursite.com/2020/04/13/20200413CauseInfer%E8%AE%BA%E6%96%871/"/>
    <id>http://yoursite.com/2020/04/13/20200413CauseInfer%E8%AE%BA%E6%96%871/</id>
    <published>2020-04-13T06:47:37.000Z</published>
    <updated>2020-04-15T14:28:13.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ABS-amp-Intro"><a href="#ABS-amp-Intro" class="headerlink" title="ABS &amp; Intro"></a>ABS &amp; Intro</h3><h4 id="云系统背景"><a href="#云系统背景" class="headerlink" title="云系统背景"></a>云系统背景</h4><p><strong>许多组件，复杂交互</strong>：cloud-based and cloud-centric systems always consist of a mass of components running in large distributed environments with complicated interactions.</p><a id="more"></a><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p><strong>引起性能问题的一些因素</strong>：highly dynamic runtime environment changes (e.g., overload and resource contention竞争，内部损伤) or software bugs (e.g., memory leak 外部)</p><p>必要性：在多租户云平台中，由于多个应用程序在同一位置，资源争用会导致持久的性能下降。在实际的生产系统中，性能问题可能会导致巨大的收入损失。（亚马逊数据）</p><p>定位好处：为系统管理员提供一些见解，例如瓶颈在哪里，或者两个应用程序适合共存于同一台机器上。如果快速找到根本原因，则可以显着降低云应用程序的MTTR。</p><h4 id="细粒度根因定位困难"><a href="#细粒度根因定位困难" class="headerlink" title="细粒度根因定位困难"></a>细粒度根因定位困难</h4><p>困难原因：due to complicated interactions and a large cardinality of potential cause set.</p><h5 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h5><p>监控中心以固定的时间间隔收集性能指标（例如CPU使用率），并在SLO（Service level objective）指标（例如响应时间）超过预设阈值时发出警报。 如果发生警报，系统管理员将始终手动查明罪魁祸首。 但手动诊断可能非常费力费时容易出错。</p><h4 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h4><p>构建CauseInfer系统，指出根因原因与给出提示。</p><p>CauseInfer可以自动将分布式系统映射到两层分层的因果关系图，并沿着因果关系图中的因果路径推断根本原因。 CauseInfer以明确的方式对故障传播路径进行建模，并且无需对正在运行的生产系统进行检测即可工作，</p><p>这使得CauseInfer比以前的方法更加有效和实用。 在两个基准系统中的实验评估表明，CauseInfer可以高精度地识别根本原因。 与几种最新方法相比，CauseInfer可以实现10％以上的改进。 此外，CauseInfer轻巧且足够灵活，可以轻松地在大型分布式系统中进行扩展。 使用CauseInfer，可以显着减少云系统的平均恢复时间（MTTR）。</p><h3 id="文献综述"><a href="#文献综述" class="headerlink" title="文献综述"></a>文献综述</h3><h4 id="一些不足"><a href="#一些不足" class="headerlink" title="一些不足"></a>一些不足</h4><h5 id="粗粒度"><a href="#粗粒度" class="headerlink" title="粗粒度"></a>粗粒度</h5><p>一些工作着重于粗略地定位故障（例如，服务级别[5]，[6]或节点级别[7]，[8]，[9]），而不是细粒度地确定真正原因粒度（例如，代码段[10]，[11]，[12]或配置项）。我们认为，粗粒度的故障定位还远远不够，因为它无法为我们提供更多根本原因的详细信息，这使得及时恢复系统变得困难。</p><h5 id="相当大的开销"><a href="#相当大的开销" class="headerlink" title="相当大的开销"></a>相当大的开销</h5><p>为了缩小故障位置，几个系统[10]，[12]，[13]，[14]可以非常精细地确定根本原因。但是他们需要检测应用程序源代码或正在运行的系统，这给生产系统带来了可观的开销。 </p><h5 id="因果关系弱"><a href="#因果关系弱" class="headerlink" title="因果关系弱"></a>因果关系弱</h5><p>大量工作[6]，[7]，[8]，[15]以成对方式利用“相关性correlation”分析来发现服务依赖性或运行时系统度量间的依赖性，并推断出根据这些依赖关系的根本原因。但是，<u>“相关”并不等同于“因果关系”</u>。弱的因果关系可能导致诊断结果不准确。</p><h4 id="OurWork"><a href="#OurWork" class="headerlink" title="OurWork"></a>OurWork</h4><h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p>在开销和粒度之间存在冲突时，要在两者之间取得平衡是一项艰巨的工作。细粒度总是意味着高开销。本文提出了一种解决方案，可以在不考虑开销的情况下进行细粒度的诊断。</p><p>性能问题原因大致分为两类：即<u>外部和内部损害</u>。前一类包括资源争用，配置错误，过载，资源消耗等等。后者主要指软件错误。此外，我们的主要观察结果是，大多数此类损害可以通过运行时系统指标直接或间接地表现出来，这将在第2节中更详细地说明。此外，这些指标可以通过现成的工具轻松监控。根据此观察，<u>我们的目标是通过将原因归因于最相关的运行时系统指标来缩小导致性能问题的可能原因。</u>例如，如果系统中发生并发错误，则根本原因应归因于违反的“锁定”指标。</p><h5 id="两关键问题"><a href="#两关键问题" class="headerlink" title="两关键问题"></a>两关键问题</h5><p>i）如何对正在运行的服务和运行时性能指标之间的因果关系进行建模，以及（ii）如何使用具有成本效益的方法来推断根本原因。</p><h5 id="CauseInfer简介"><a href="#CauseInfer简介" class="headerlink" title="CauseInfer简介"></a>CauseInfer简介</h5><p>根因指标的变化会导致effect metric的改变，<u>CauseInfer的本质是建立因果图，该因果图用于为运行分布式系统的故障传播路径建模并在因果图中沿因果路径推断根本原因。</u> 为此，CauseInfer首先从多个数据源收集运行时性能指标，然后通过<strong>贝叶斯变化点检测方法</strong> 提取嵌入在这些指标中的变化点。</p><p>利用变化数据，CauseInfer通过基于统计的方法构造两层层次因果图，以解决关键问题（i）。该因果图由一个粗粒度图和一个细粒度图组成。前一个图是通过一种新颖的轻量级流量滞后相关方法<strong>（traffic lag correlation method）</strong>构造的服务级依赖图，旨在将根本原因定位在服务级别上。而后一个图是系统指标/度量metric因果关系图<strong>（system metric causality graph）</strong>，它是通过条件独立性测试[16]在运行时性能指标中构建的，目的是在指标级别找到真正的罪魁祸首。</p><p>为了解决关键问题（ii），针对每个节点1专门构建指标因果图。应用程序的SLO（Service level objective）指标将来自不同节点的两个指标因果关系图链接在一起。</p><p>CauseInfer部署在基于云的系统中。它着重于诊断导致虚拟服务器中违反SLO的性能问题。 <strong>CauseInfer通过监视服务的响应时间来检测SLO违规</strong>。其他SLO指标（例如，可用性）将在我们的未来工作中进行讨论。（不会影响SLO的性能问题不在本文讨论范围之内。例如，除非服务器的内存使用率很高，否则CauseInfer将不会开始诊断，除非请求响应时间很高。）此外，系统崩溃也不在我们的考虑范围之内，因为可以通过诸如Sherlock [17]之类的传统工具来解决它们。</p><p>一旦发生SLO违规，就会触发推理过程。 CauseInfer首先通过分析特定服务的SLO指标来定位故障。然后，它通过检测因果路径上有故障的节点中的性能指标违规来查明根本原因。重复该过程，直到揭示出所有潜在的根本原因。由于采用了分层图结构，在推理过程中跳过了一些常规路径，因此大大缩短了推理时间。在两个测试基准中的实验评估，即在线事务处理（OLTP）基准：TPC-W [18]和大数据基准：BigDataBench [19]，表明CauseInfer可以准确地找出根本原因，并且胜过几种最先进的方法。</p><h5 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h5><p>1，Bayesian change point 检测方法   </p><p>2，通过分析两个服务之间的通信延迟相关性the traffic lag correlation，提出了一种新颖的轻量级服务依赖发现方法。 服务依赖关系图非常有效地指导我们在服务级别上定位性能问题。</p><p>3，我们设计了一种新颖的方法来发现从多个数据源收集的运行时系统指标之间的因果关系。 与基于correlation-based approaches 相关的方法不同，该方法利用条件独立性测试来精确快速地对系统故障之间的故障传播路径进行建模。</p><p>4，CauseInfer系统</p><h3 id="故障背景与动机"><a href="#故障背景与动机" class="headerlink" title="故障背景与动机"></a>故障背景与动机</h3><h4 id="云平台需要诊断工具"><a href="#云平台需要诊断工具" class="headerlink" title="云平台需要诊断工具"></a>云平台需要诊断工具</h4><p>举例：在Hadoop错误库有一个真正的性能错误，即Hadoop-3382。 未完全关闭打开的文件时，在namenode中发生内存泄漏。 而且内存泄漏将延长Hadoop请求的响应时间。 <u>故障传播路径是“打开的文件→内存利用率→响应时间”</u>。 如果事先知道故障传播路径，则可以查明性能问题的根本原因。 以Hadoop-3382为例，一旦作业执行时间变得异常，我们就可以在“打开的文件”中找到根本原因。 这促使我们对故障传播路径进行显式建模。</p><h4 id="性能问题分类"><a href="#性能问题分类" class="headerlink" title="性能问题分类"></a>性能问题分类</h4><p>引用【7,8,15】，我们发现性能问题可能是由运行时环境更改或软件错误引起的。通过手动分析这些原因，这些原因与 <strong>物理资源（例如，CPU和内存）或逻辑资源（例如，锁和队列）高度相关</strong>，并且可以很容易地监视这两个原因。这一发现也与[11]中的观察结果相符，在该发现中作者声称可以通过 <strong>分析系统调用</strong>（例如sys write，sys open，sys futex等）来诊断性能错误。这些系统调用用于为应用程序提供接口，以利用物理或逻辑系统资源。</p><p><img src="/images/20200414CauseInfer_fig1.jpg" alt="20200414CauseInfer_fig1"></p><p>如图1所示。因此，通过分析物理或逻辑资源利用率，我们可以细粒度地诊断性能问题。</p><h4 id="相关性陷进"><a href="#相关性陷进" class="headerlink" title="相关性陷进"></a>相关性陷进</h4><p>大量现有文献利用“相关性”（例如，皮尔逊相关系数）对服务[5]，[6]或系统指标[2]，[7]，[8]之间的依赖关系进行建模。我们认为基于“相关性”的方法可能会错误地将某些独立关系视为依赖关系的可能性很高。原因是该方法旨在仅捕获两个指标之间的简单关联。它<u>不能捕获两个以上指标之间的更复杂的依赖关系</u>，称为“条件依赖”。</p><p>（CauseInfer论文(Part Ⅱ) CauseInfer的工作流模型）</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, Chen P, Qi Y, Hou D. CauseInfer: automated end-to-end performance diagnosis with hierarchical causality graph in cloud environment[J]. IEEE transactions on services computing, 2016, 12(2): 214-230.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ABS-amp-Intro&quot;&gt;&lt;a href=&quot;#ABS-amp-Intro&quot; class=&quot;headerlink&quot; title=&quot;ABS &amp;amp; Intro&quot;&gt;&lt;/a&gt;ABS &amp;amp; Intro&lt;/h3&gt;&lt;h4 id=&quot;云系统背景&quot;&gt;&lt;a href=&quot;#云系统背景&quot; class=&quot;headerlink&quot; title=&quot;云系统背景&quot;&gt;&lt;/a&gt;云系统背景&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;许多组件，复杂交互&lt;/strong&gt;：cloud-based and cloud-centric systems always consist of a mass of components running in large distributed environments with complicated interactions.&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="faultDiagnosis" scheme="http://yoursite.com/tags/faultDiagnosis/"/>
    
      <category term="RootCause" scheme="http://yoursite.com/tags/RootCause/"/>
    
  </entry>
  
  <entry>
    <title>hadoop配置</title>
    <link href="http://yoursite.com/2020/04/06/20200406hadoop%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/04/06/20200406hadoop%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-06T03:01:16.000Z</published>
    <updated>2020-04-16T14:42:30.815Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SSH远程"><a href="#SSH远程" class="headerlink" title="SSH远程"></a>SSH远程</h3><p>1，在mac上用parallels desktop开启一个Ubuntu16的虚拟机。</p><p>注意设置里换源，中国区的快些。</p><p>然后进行更新 (sudo apt-get update ,  然后sudo apt-get upgrade)</p><p>然后安装ssh（sudo apt-get install openssh-server）。</p><a id="more"></a><p>然后我在本机mac这边用ssh远程登录ubuntu。将mac的ssh公钥发送给ubunt，（ssh-copy-id <em>*</em>@10.211.55…IP），以后就可以直接ssh user@IP登录ubuntu了。</p><h3 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h3><h4 id="Java环境"><a href="#Java环境" class="headerlink" title="Java环境"></a>Java环境</h4><p>在 Linux 中下载java JDK，下载的Linux X64的1.7版本的jdk-7u80</p><p><a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html#jdk-7u80-oth-JPR" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html#jdk-7u80-oth-JPR</a></p><p><img src="/images/20200407JavaJDK.jpg" alt="20200407JavaJDK"></p><p>我远程scp传到ubuntu的时候提醒connection refused，这个是因为我mac的setting里的sharing的remote login没有开启，这里得开启一下。</p><p>接着配置Java环境变量，配置在/etc/profile中，作为<strong>全局系统变量</strong>，使用<strong>sudo vi /etc/profile</strong>进行环境变量编辑，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加并保存</span></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.7.0_80  #注意此处jdk目录与你解压目录相同</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>编辑完后终端输入<strong>source /etc/profile</strong>使环境变量生效。</p><h4 id="hadoop下载"><a href="#hadoop下载" class="headerlink" title="hadoop下载"></a>hadoop下载</h4><p>下载的hadoop2.6版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.6.0-cdh5.7.0.tar.gz</span><br></pre></td></tr></table></figure><p>然后对hadoop进行解压放到与jdk同一个目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hadoop-2.7.1.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p>配置hadoop全局环境变量并使其生效，在Java环境变量配置的下面:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">HADOOP VARIABLES</span></span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop-2.6.4</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line">export HADOOP_MAPRED_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_COMMON_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_HDFS_HOME=$HADOOP_HOME</span><br><span class="line">export YARN_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</span><br><span class="line">export HADOOP_OPTS="-Djava.library.path=$HADOOP_HOME/lib"</span><br></pre></td></tr></table></figure><p>编辑完后终端输入<strong>source /etc/profile</strong>使环境变量生效。</p><p>另外这里注意配置hadoop-env.sh文件的$JAVA_HOME，接着用<strong>sudo gedit hadoop-env.sh</strong>配置jdk绝对路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.7.0_80  #注意此处jdk目录与你解压目录相同</span><br></pre></td></tr></table></figure><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a>映射配置</h4><p>使用 vim 进入到 “/etc/hostname” 的这个文件进行修改，我修改了为“wangxue-para”，同时修改“/etc/hosts”文件，在里面追加 IP 地址与 wangxue-para 主机的映射。</p><p><img src="/images/20200407hadoop-hostname.jpg" alt="20200407hadoop-hostname"></p><h4 id="配置免秘钥登录"><a href="#配置免秘钥登录" class="headerlink" title="配置免秘钥登录"></a>配置免秘钥登录</h4><p>整个hadoop的处理过程之中，都是利用ssh实现通讯的，就算是在本机，也一样使用ssh进行通讯处理，因此需要在电脑上配置ssh免登录处理。</p><p>在本主机上生成一个ssh key：使用<strong>sudo apt-get openssh-server</strong>安装openssh-server后，然后使用<strong>ssh-keygen -t rsa -P “”</strong>生成.ssh文件</p><p>保存公钥：这个时候的程序如果要想进行登录依然需要密码。需要将公钥信息保存在授权认证的文件之中 ： “authorized_key”文件里面。<strong>cd .ssh/</strong>进入到该文件中，然后使用 <strong>ls</strong> 命令查看其中的文件，然后使用<strong>cat id_rsa.pub &gt;&gt; authorized_keys</strong>把公钥存到authorized_keys文件中，最后使用<strong>ssh localhost</strong>验证免密钥是否配置成功。</p><h3 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h3><h4 id="Hadoop-主要包含模块"><a href="#Hadoop-主要包含模块" class="headerlink" title="Hadoop 主要包含模块"></a>Hadoop 主要包含模块</h4><ul><li>Hadoop Common: The common utilities that support the other Hadoop modules.</li><li>Hadoop Distributed File System (HDFS™): A distributed file system that provides high-throughput access to application data.</li><li>Hadoop YARN: A framework for job scheduling and cluster resource management.</li><li>Hadoop MapReduce: A YARN-based system for parallel processing of large data sets.</li></ul><p>hadoop支持三种启动模式：</p><ul><li>Local (Standalone) Mode - 单机模式</li><li>Pseudo-Distributed Mode - 伪分布式</li><li>Fully-Distributed Mode - 全分布式</li></ul><h4 id="wordcount单机测试"><a href="#wordcount单机测试" class="headerlink" title="wordcount单机测试"></a>wordcount单机测试</h4><p>在单机模式下，读取的是本地数据，这里采用的是单机模式。</p><p>进入你的/hadoop目录我的是“~/app/hadoop2.6”，使用<strong>mkdir input</strong>创建一个input文件夹。随便在input目录下创建一个txt文本，准备统计文本的单词个数。</p><p>执行hadoop的统计命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.6.0-cdh5.7.0-sources.jar org.apache.hadoop.examples.WordCount input output</span><br></pre></td></tr></table></figure><p>进行对单词的计数测试，然后再使用<strong>cat output/*</strong>查看计数的结果。</p><p><img src="/images/20200407single_wordcount.jpg" alt="20200407single_wordcount"></p><h4 id="伪分布式"><a href="#伪分布式" class="headerlink" title="伪分布式"></a>伪分布式</h4><p>伪分布式读取的则是 HDFS 上的数据；要使用 HDFS，首先需要在 HDFS 中创建用户目录。</p><p>伪分布式里要修改hadoop的几个重要的文件。先做简单的介绍：</p><h5 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h5><p>配置公共属性，指定namenode标识以及其端口号。即确定Hadoop的核心的信息，包括临时目录，访问地址。我们用gedit编辑它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hadoop/etc/hadoop/</span><br><span class="line">vim core-site.xml</span><br></pre></td></tr></table></figure><p>在configuration中添加配置property：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/home/wangxue/app/hadoop-2.6/tmp&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;location to store temporary files&lt;/description&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>这个文件路径配置的是临时文件的地址，不配置就会在hadoop的文件夹里面生成“tmp”文件(“/home/wangxue/app/hadoop-2.6/tmp”)，如果这样配置，每次重新开机启动，所有的配置就会被清空，namenode的格式化信息就会丢失，您的Hadoop环境就失效了。所以这里先建立tmp文件夹，再重新配置一个tmp文件的目录。</p><h5 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h5><p>可以确定文件的备份个数以及数据文件夹的路径，即指定namenode存放元数据的位置和datanode存放数据块的位置，配置HDFS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/home/wangxue/app/hadoop-2.6/hdfs/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/home/wangxue/app/hadoop-2.6/hdfs/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>HDFS文件存储的副本个数，默认3。因为我们这只有一个节点，所以设置1.</p><h5 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h5><p>配置MapReduce，用于指定jobtracker标识及其端口号、指定tasktracker执行mapreduce程序的本地目录和共享目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>采用yarn管理MR，还可以配置：</p><p>apreduce.jobhistory.address 历史服务器端口地址mapreduce.jobhistory.webapp.address 历史服务器web端地址</p><h5 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h5><p>暂时简单的理解为配置相关的job的处理，配置YARN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt; </span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; </span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt; </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>最后执行<strong>hdfs namenode –format</strong>命令来格式化hdfs。</p><p><img src="/images/20200410hdfs_format.jpg" alt="20200410hdfs_format"></p><p>然后依次执行hdfs的命令</p><p><strong>sbin/start-dfs.sh，sbin/start-yarn.sh</strong>来启动hadoop。</p><p><img src="/images/20200410start_hdfs.jpg" alt="20200410start_hdfs"></p><p>在终端输入<strong>jps</strong>发现相应的NameNode、DataNode等java进程已经在运行了。</p><p><img src="/images/20200410jsp.jpg" alt="20200410jsp"></p><p>可以打开firefox浏览器，输入网址 <a href="http://localhost:50070，查看NameNode和DataNode相关信息。" target="_blank" rel="noopener">http://localhost:50070，查看NameNode和DataNode相关信息。</a></p><p><img src="/images/20200410web_hdfs.jpg" alt="20200410web_hdfs"></p><p>检查配置是否成功，运行WordCount例子。创建输出文件夹，将txt文本文件放入input下，然后执行wordcount进行统计，最后cat展示output的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin/hadoop fs -mkdir -p input</span><br><span class="line"></span><br><span class="line">bin/hadoop fs -copyFromLocal README.txt input</span><br><span class="line"></span><br><span class="line">bin/hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.7.3-sources.jar org.apache.hadoop.examples.WordCount input output</span><br><span class="line"></span><br><span class="line">bin/hadoop fs -cat output/*</span><br></pre></td></tr></table></figure><h3 id="Python执行任务"><a href="#Python执行任务" class="headerlink" title="Python执行任务"></a>Python执行任务</h3><p>参考4，<a href="https://www.jianshu.com/p/229c7ec48110" target="_blank" rel="noopener">https://www.jianshu.com/p/229c7ec48110</a></p><p>首先我在hadoop-2.6目录下新建文件夹test/code/ ，用于存放mapper.py和reducer.py</p><p>遇到的问题：找不到hadoop-streaming，注意要找到自己本地环境中安装hadoop中的stream jar包，我的也是在share目录下的，用tab补全jar名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/app/hadoop-2.6/share/hadoop/tools/lib/hadoop-streaming-2.6.0-cdh5.7.0.jar</span><br></pre></td></tr></table></figure><p>然后上传本地的txt文件（用于统计单词的原始文本）到hdfs系统。</p><p>这里遇到一个问题是，执行到mapreduce.job: Running job <em>**</em>就一直卡着不动了，这里我停下了，重新jps命令检查了hadoop的启动信息，缺少了NodeManager，故重新启动了下hadoop。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop-all.sh</span><br><span class="line">start-all.sh</span><br></pre></td></tr></table></figure><p>jps结果如下，这个是正常的：</p><p><img src="/images/20200415py_jps.jpg" alt="20200415py_jps"></p><p>然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hadoop jar /share/hadoop/tools/lib/hadoop-streaming-2.6.0-cdh5.7.0.jar -file /test/code/mapper.py    -mapper /test/code/mapper.py -file /test/code/reducer.py   -reducer /home/hadoop/reducer.py -input /user/wangxue/hdfs_first/* -output /user/wangxue/hdfs_first_output</span><br></pre></td></tr></table></figure><p>正确执行：</p><p><img src="/images/20200415py_wordcount.jpg" alt="20200415py_wordcount"></p><p>最后用cat命令查看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs dfs -cat /user/wangxue/hdfs_first_output/part-00000</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，部分参考 <a href="http://blog.sanyuehua.net/2017/10/30/Hadoop-Pseudo-distributed/" target="_blank" rel="noopener">http://blog.sanyuehua.net/2017/10/30/Hadoop-Pseudo-distributed/</a></p><p><a href="https://blog.sanyuehua.net/2017/10/27/Hadoop-SetUp/" target="_blank" rel="noopener">https://blog.sanyuehua.net/2017/10/27/Hadoop-SetUp/</a></p><p>2，<a href="https://zhengbao.wang/Centos7搭建Hadoop伪分布式集群详细步骤/" target="_blank" rel="noopener">https://zhengbao.wang/Centos7%E6%90%AD%E5%BB%BAHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</a></p><p>3，《云计算课程》实验2</p><p>4，<a href="https://www.jianshu.com/p/229c7ec48110" target="_blank" rel="noopener">https://www.jianshu.com/p/229c7ec48110</a> 让Python代码在hadoop上运行</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SSH远程&quot;&gt;&lt;a href=&quot;#SSH远程&quot; class=&quot;headerlink&quot; title=&quot;SSH远程&quot;&gt;&lt;/a&gt;SSH远程&lt;/h3&gt;&lt;p&gt;1，在mac上用parallels desktop开启一个Ubuntu16的虚拟机。&lt;/p&gt;&lt;p&gt;注意设置里换源，中国区的快些。&lt;/p&gt;&lt;p&gt;然后进行更新 (sudo apt-get update ,  然后sudo apt-get upgrade)&lt;/p&gt;&lt;p&gt;然后安装ssh（sudo apt-get install openssh-server）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>大数据技术1hadoop</title>
    <link href="http://yoursite.com/2020/04/05/20200405%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF1hadoop/"/>
    <id>http://yoursite.com/2020/04/05/20200405%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF1hadoop/</id>
    <published>2020-04-05T01:37:46.000Z</published>
    <updated>2020-04-06T02:54:08.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><p>hadoop是一个开源框架，允许使用简单的编程模型在跨计算机集群的分布式环境中存储和处理大数据。</p><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>分布式文件系统，是一个高度容错性的系统（每个数据块都复制到多个节点），可以提供高吞吐量的数据访问（T级别，多个节点同时处理数据）。</p><p>文件分块存储，HDFS将一个完整的大文件平均分块存储到不同的计算器上，多主机读取比单主机读取效率更高。代码向数据迁移，尽量地将任务分配到离数据最近的机器上运行。</p><a id="more"></a><p>适用情况：大规模数据，流式数据（一次写入多次读写，不支持动态改变文件内容，不支持并发写，小文件不合适。），一般硬件，时间延迟有代价（低时延的访问需求HBase更合适）。</p><h4 id="关键元素"><a href="#关键元素" class="headerlink" title="关键元素"></a>关键元素</h4><p>Block：文件分块，一般大小是64MB or 128MB。配置大的块减少搜寻时间，减少管理块的数据开销，每个块都需要在NameNode上有对应的记录；对数据块进行读写减少建立网络的连接成本。每个块都会被复制到多台机器（可靠性）。</p><p>NameNode：保存整个文件系统的目录信息，文件信息及分块信息。存储文件的metadata，运行时所有数据都保存到内存，整个HDFS可存储的文件数受限于NameNode的内存大小。一个Block在NameNode中对应一条记录</p><p>DataNode：分布在廉价的计算机上，用于存储Block块文件。负责数据的读写操作和复制操作，DataNode启动时会向NameNode报告当前存储的数据块信息。DataNode之间会进行通信，复制数据块，虽然有冗余但是可靠。</p><p>结构如图：</p><p><img src="/images/20200405hadoop_namenode.jpg" alt="20200405hadoop_namenode"></p><p>名称节点（NameNode） 主节点（Master），数据节点 （DataNode） 从节点（Slave）</p><p>名称节点负责文件和目录的创建、删除和重命名等，同时管理数据节点与文件块的映射关系；数据节点负责数据的存储和读取。</p><h4 id="HDFS的数据流—读文件"><a href="#HDFS的数据流—读文件" class="headerlink" title="HDFS的数据流—读文件"></a>HDFS的数据流—读文件</h4><p><img src="/images/20200405HDFS_architecture.jpg" alt="20200405HDFS_architecture"></p><p>客户端client用FileSystem的open() 函数打开文件。</p><p>DistributedFileSystem用RPC调用元数据节点，得到文件的数据块信息。对于每一个数据块，元数据节点返回保存数据块的数据节点的地址。</p><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>是一套从海量数据中提取分析元素，最后返回结果集的编程模型。MapReduce的基本原理就是：将大的数据分析分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。</p><p>一种分布式的计算方式指定一个Map函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p><p><img src="/images/20200405MapReduce.jpg" alt="20200405MapReduce"></p><p>map: (K1, V1) → list(K2, V2) combine: (K2, list(V2)) → list(K2, V2) reduce: (K2, list(V2)) → list(K3, V3)</p><p><img src="/images/20200405MapReduce1.jpg" alt="20200405MapReduce1"></p><p>多节点下流程图：</p><p><img src="/images/20200405mapreduce2.png" alt="20200405mapreduce2"></p><p>Record reader：记录阅读器会翻译由输入格式生成的记录，记录阅读器用于将数据解析给记录，并不分析记录自身。记录读取器的目的是将数据解析成记录，但不分析记录本身。它将数据以键值对的形式传输给mapper。通常键是位置信息，值是构成记录的数据存储块.</p><p>Map：在映射器中用户提供的代码称为中间对。对于键值的具体定义是慎重的，因为定义对于分布式任务的完成具有重要意义.键决定了数据分类的依据，而值决定了处理器中的分析信息。</p><p>Shuffle and Sort：ruduce任务以随机和排序步骤开始。此步骤写入输出文件并下载到本地计算机。这些数据采用键进行排序以把等价密钥组合到一起。</p><p>Reduce：reducer采用分组数据作为输入。该功能传递键和此键相关值的迭代器。可以采用多种方式来汇总、过滤或者合并数据。当ruduce功能完成，就会发送0个或多个键值对。</p><p>输出格式：输出格式会转换最终的键值对并写入文件。默认情况下键和值以tab分割，各记录以换行符分割。因此可以自定义更多输出格式，最终数据会写入HDFS。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，《云计算课程》</p><p>2，W3Cschool： <a href="https://www.w3cschool.cn/hadoop/fgr61jyf.html" target="_blank" rel="noopener">https://www.w3cschool.cn/hadoop/fgr61jyf.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;h3 id=&quot;虚拟化技术&quot;&gt;&lt;a href=&quot;#虚拟化技术&quot; class=&quot;headerlink&quot; title=&quot;虚拟化技术&quot;&gt;&lt;/a&gt;虚拟化技术&lt;/h3&gt;&lt;h3 id=&quot;Hadoop&quot;&gt;&lt;a href=&quot;#Hadoop&quot; class=&quot;headerlink&quot; title=&quot;Hadoop&quot;&gt;&lt;/a&gt;Hadoop&lt;/h3&gt;&lt;p&gt;hadoop是一个开源框架，允许使用简单的编程模型在跨计算机集群的分布式环境中存储和处理大数据。&lt;/p&gt;&lt;h3 id=&quot;HDFS&quot;&gt;&lt;a href=&quot;#HDFS&quot; class=&quot;headerlink&quot; title=&quot;HDFS&quot;&gt;&lt;/a&gt;HDFS&lt;/h3&gt;&lt;p&gt;分布式文件系统，是一个高度容错性的系统（每个数据块都复制到多个节点），可以提供高吞吐量的数据访问（T级别，多个节点同时处理数据）。&lt;/p&gt;&lt;p&gt;文件分块存储，HDFS将一个完整的大文件平均分块存储到不同的计算器上，多主机读取比单主机读取效率更高。代码向数据迁移，尽量地将任务分配到离数据最近的机器上运行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>分治递归思想</title>
    <link href="http://yoursite.com/2020/03/31/20200330%E5%88%86%E6%B2%BB%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2020/03/31/20200330%E5%88%86%E6%B2%BB%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/</id>
    <published>2020-03-31T01:37:21.000Z</published>
    <updated>2020-04-13T14:49:58.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分治递归思想"><a href="#分治递归思想" class="headerlink" title="分治递归思想"></a>分治递归思想</h3><p>为了解决一个给定的问题，算法一次或多次递归的调用自身以解决若干子问题，这些就是典型的分治法的思想。我们将原问题分解为几个规模较小但类似于原问题的子问题，从而递归的调用自身，最后合并这些子问题的解来建立原问题的解。</p><p>关键：1，分解原问题为相同结构的子问题。2，解决这些子问题。3，合并子问题的解。</p><a id="more"></a><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><h4 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h4><p>如果计算1 + 2 + … n ，可以用递归的方法来写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddFrom1ToN_Recursive</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n &lt;= <span class="number">0</span>?: <span class="number">0</span>:n + AddFrom1ToN_Recursive(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里递归比循环的时间复杂度更高，函数递归调用自身都要在内存栈中分配空间保存参数（如n到哪了），返回地址（函数的地址），临时变量（上一次计算得到的AddFrom1ToN_Recursive值）等等，因此空间和时间消耗较多。</p><p>更严重的话递归会带来调用栈溢出的问题，递归调用层级太多就有可能超出栈的容量。</p><h4 id="归并排序。"><a href="#归并排序。" class="headerlink" title="归并排序。"></a>归并排序。</h4><p><a href="[https://saruagithub.github.io/2020/03/10/20200309%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/](https://saruagithub.github.io/2020/03/10/20200309排序算法复习/">排序—归并排序</a>)</p><p>归并排序的详细复杂度分析见 《算法导论》P21，通过递归树分析，总代价是$cnlgn + cn$ (c表示求解规模为1的问题所需要的时间以及在分解步骤与合并步骤处理每个数组元素所需要的时间。)</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="leecode84"><a href="#leecode84" class="headerlink" title="leecode84"></a>leecode84</h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>分析：最大面积是最矮柱子以后，矩形的宽尽可能往两边延伸；or 最矮柱子左边的最大面积矩形 or 最矮柱子右边的最大面积矩形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>,<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minindex = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;=<span class="built_in">end</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>[minindex] &gt; <span class="built_in">height</span>[i]) &#123;</span><br><span class="line">            minindex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>[minindex]*(<span class="built_in">end</span>-start+<span class="number">1</span>) ,<span class="built_in">max</span>( calculateArea(<span class="built_in">height</span>,start,minindex<span class="number">-1</span>), calculateArea(<span class="built_in">height</span>,minindex+<span class="number">1</span>,<span class="built_in">end</span>)) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculateArea(<span class="built_in">height</span>, <span class="number">0</span>, <span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main_recursive</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;largestRectangleArea(nums)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多二叉树类的问题都涉及到递归方法。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, 《算法导论》机械工业出版社 第三版（黑皮的，Thoms H Cormen…）</p><p>2，leecode网站</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分治递归思想&quot;&gt;&lt;a href=&quot;#分治递归思想&quot; class=&quot;headerlink&quot; title=&quot;分治递归思想&quot;&gt;&lt;/a&gt;分治递归思想&lt;/h3&gt;&lt;p&gt;为了解决一个给定的问题，算法一次或多次递归的调用自身以解决若干子问题，这些就是典型的分治法的思想。我们将原问题分解为几个规模较小但类似于原问题的子问题，从而递归的调用自身，最后合并这些子问题的解来建立原问题的解。&lt;/p&gt;&lt;p&gt;关键：1，分解原问题为相同结构的子问题。2，解决这些子问题。3，合并子问题的解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>链表类算法</title>
    <link href="http://yoursite.com/2020/03/29/20200329%E9%93%BE%E8%A1%A8%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/29/20200329%E9%93%BE%E8%A1%A8%E7%B1%BB%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-29T14:26:48.000Z</published>
    <updated>2020-04-04T15:02:15.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>用指针来实现线性表，链表是动态的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x),next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;p&gt;用指针来实现线性表，链表是动态的。&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="ListNode" scheme="http://yoursite.com/tags/ListNode/"/>
    
  </entry>
  
  <entry>
    <title>数组实现堆</title>
    <link href="http://yoursite.com/2020/03/28/20200328%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86/"/>
    <id>http://yoursite.com/2020/03/28/20200328%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86/</id>
    <published>2020-03-28T09:25:36.000Z</published>
    <updated>2020-03-28T10:08:59.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树，逐层而下，从左到右，结点的位置完全由其序号觉得，因此可以用数组来实现。</p><p>计算各结点下标的公式，其中$r$ 表示结点的下标，范围在0 ~ n-1 之间，n是二叉树结点的总数。</p><p>$Parent(r)= \lfloor (r-1)/2 \rfloor$ 向下取整，当$r≠0$时</p><p>$Leftchild(r)=2r+1$,当$2r+1&lt;n$时</p><a id="more"></a><p>$Rightchild(r)=2r+2$,当 $2r+2&lt;n$ 时</p><p>$Leftsibling()=r-1$,当r为偶数时</p><p>$Rightsibling()=r+1$ ,当r为奇数并且$r+1&lt;n$时</p><p><img src="/images/20200328Build_heap.jpg" alt="20200328Build_heap"></p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>完全二叉树的一个重要应用是最大堆和最小堆，最小堆就是儿子的值一定不小于父亲的值，树的节点从上到下，从左到右紧凑排列。这里给出最小堆的实现：</p><p>插入数值：在堆的末尾插入，然后不断向上提升，直到没有大小颠倒。</p><p>删除数值：首先把堆的最后一个节点的数值放到根上去，并且删除最后一个节点，然后不断向下交换直到没有大小颠倒为止。向下交换的时候如果2个儿子都比自己小，那么选择数值较小的儿子进行交换。</p><p>复杂度：建堆需要$\Theta(n)$ 的时间，但删除插入都和树深度成正比，时间复杂度是$\Theta(nlogn)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------- min heap --------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[MAX_N],sz=<span class="number">0</span>; <span class="comment">//sz is global variable, meaning the lengh of heap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//own node's num.</span></span><br><span class="line">    <span class="keyword">int</span> node_index = sz++;</span><br><span class="line">    <span class="keyword">while</span> (node_index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = (node_index<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">//i's parent</span></span><br><span class="line">        <span class="keyword">if</span> (heap[p] &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// sequence is ok</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// parent's value put down, node value go up</span></span><br><span class="line">        heap[node_index] = heap[p];</span><br><span class="line">        node_index = p;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[node_index] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heap_pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// min (root)</span></span><br><span class="line">    <span class="keyword">int</span> rec = heap[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// the new temp root value, get it for compare and move it</span></span><br><span class="line">    <span class="keyword">int</span> x = heap[--sz];</span><br><span class="line">    <span class="comment">//replace from the root</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt; sz) &#123;</span><br><span class="line">        <span class="comment">//compare the children value</span></span><br><span class="line">        <span class="keyword">int</span> a = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = i*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) &#123;</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sequence is right</span></span><br><span class="line">        <span class="keyword">if</span> (heap[a] &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// child's value go up</span></span><br><span class="line">        heap[i] = heap[a];</span><br><span class="line">        i=a;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = x;</span><br><span class="line">    <span class="keyword">return</span> rec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//push(3);</span></span><br><span class="line">    heap_push(<span class="number">9</span>);</span><br><span class="line">    heap_push(<span class="number">2</span>);</span><br><span class="line">    heap_push(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;heap[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pop:"</span>&lt;&lt;heap_pop()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pop:"</span>&lt;&lt;heap_pop()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ------ standard package is the max queue ------</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; qqueue;</span><br><span class="line">    qqueue.push(<span class="number">-9</span>);</span><br><span class="line">    qqueue.push(<span class="number">-2</span>);</span><br><span class="line">    qqueue.push(<span class="number">-6</span>);</span><br><span class="line">    <span class="comment">//loop until it is empty</span></span><br><span class="line">    <span class="keyword">while</span> (!qqueue.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span> * qqueue.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        qqueue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，《数据结构与算法分析》 Clifford A. Shaffer 等</p><p>2，《挑战程序设计》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;完全二叉树&quot;&gt;&lt;a href=&quot;#完全二叉树&quot; class=&quot;headerlink&quot; title=&quot;完全二叉树&quot;&gt;&lt;/a&gt;完全二叉树&lt;/h3&gt;&lt;p&gt;完全二叉树，逐层而下，从左到右，结点的位置完全由其序号觉得，因此可以用数组来实现。&lt;/p&gt;&lt;p&gt;计算各结点下标的公式，其中$r$ 表示结点的下标，范围在0 ~ n-1 之间，n是二叉树结点的总数。&lt;/p&gt;&lt;p&gt;$Parent(r)= \lfloor (r-1)/2 \rfloor$ 向下取整，当$r≠0$时&lt;/p&gt;&lt;p&gt;$Leftchild(r)=2r+1$,当$2r+1&amp;lt;n$时&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
      <category term="完全二叉树" scheme="http://yoursite.com/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>20200325word的xml无效而无法打开</title>
    <link href="http://yoursite.com/2020/03/26/20200325word%E7%9A%84xml%E6%97%A0%E6%95%88%E8%80%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"/>
    <id>http://yoursite.com/2020/03/26/20200325word%E7%9A%84xml%E6%97%A0%E6%95%88%E8%80%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/</id>
    <published>2020-03-26T01:07:58.000Z</published>
    <updated>2020-03-26T01:26:04.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>写论文生成word的时候出现了xml无效的问题。</p><p><img src="/images/20200325word_problem1.jpg" alt="20200325word_problem1"></p><p>将word文档原扩展名“docx”手动改为压缩文件扩展名“zip”，备份一个，然后用解压软件解压。用vscode编辑器或者其他的一些xml编辑器（如firstobject）打开解压文件夹下的word目录下的document.xml 文件。根据对xml错误提示进行更改。</p><a id="more"></a><p>我这里提示的错误是：起始标记“mc:Fallback”（偏移位置 1732371）在偏移位置 1733790缺少对应的结束标记。则将鼠标移动到 1733790个字节的位置，说明这里缺少了 ＜/mc:Fallback＞，注意英文输入。 </p><p>然后重复分析xml文档的缺失，直到没有任何问题。其中遇到了下图这个最后的问题，这个问题是直接缺了 ＜ /w:r＞这个标签，怎么分析的呢？是查找对比前面的几对Fallback的格式发现的缺失，这个就要好好对比一下了。</p><p><img src="/images/20200325word_problem2.jpg" alt="20200325word_problem2"></p><h3 id="重新打开"><a href="#重新打开" class="headerlink" title="重新打开"></a>重新打开</h3><p>最后将改完的xml替换原来的xml，再将“.zip”改回”.dcox“文档，再次打开word文件就可以打开了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;写论文生成word的时候出现了xml无效的问题。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/20200325word_problem1.jpg&quot; alt=&quot;20200325word_problem1&quot;&gt;&lt;/p&gt;&lt;p&gt;将word文档原扩展名“docx”手动改为压缩文件扩展名“zip”，备份一个，然后用解压软件解压。用vscode编辑器或者其他的一些xml编辑器（如firstobject）打开解压文件夹下的word目录下的document.xml 文件。根据对xml错误提示进行更改。&lt;/p&gt;
    
    </summary>
    
    
      <category term="配置" scheme="http://yoursite.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="word" scheme="http://yoursite.com/tags/word/"/>
    
  </entry>
  
  <entry>
    <title>Unsupervised Anomaly Detection via Variational Auto-Encoder for Seasonal KPIs in Web Applications (Donut model, Part Ⅱ)</title>
    <link href="http://yoursite.com/2020/03/14/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part2)/"/>
    <id>http://yoursite.com/2020/03/14/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part2)/</id>
    <published>2020-03-14T09:40:12.000Z</published>
    <updated>2020-03-15T00:29:36.966Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Evaluation实验"><a href="#Evaluation实验" class="headerlink" title="Evaluation实验"></a>Evaluation实验</h3><h4 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h4><p>我们从大型互联网上获得了18个维护良好的商业KPIs（时间跨度足以进行培训和评估），所有的KPIs间隔为1min。三个数据集 A B C 如图6的Table1。因此我们可以评估Donut在不同级别的噪声。 我们将每个数据集分为训练集 49%，验证集21%和测试集30%。</p><a id="more"></a><p><img src="/images/20200314Donut_Dataset.jpg" alt="20200314Donut_Dataset"></p><h4 id="Performance-Metric度量指标"><a href="#Performance-Metric度量指标" class="headerlink" title="Performance Metric度量指标"></a>Performance Metric度量指标</h4><p>评估中，完全忽略了所有算法在缺失点（“空”）的输出。本文所有评估的算法为每个点计算一个异常分数，选择一个阈值来进行决策：如果某个点的分数大于阈值，则应该触发警报。这样，异常检测就类似于分类问题，并且我们可以计算与每个阈值相对应的精度和召回率。给定所有可能的阈值，我们可以进一步计算AUC，即召回率的平均精度。或F分数，它是给定一个特定阈值的精度和召回率的谐平均值。我们还可能枚举所有阈值，获得所有F分数，并使用最佳F分数作为度量。给定最佳全局阈值，最好的F分数表示模型在特定测试集上的最佳性能。在实践中，最佳F分数与AUC基本一致，除了细微差异（见图8）。<strong>相比AUC我们更喜欢best F-score</strong>，因为在某个阈值上拥有出色的F分数比在大多数阈值上拥有高但不是那么出色的F分数更为重要。</p><p>简单评估策略：在实际应用中，操作员通常并不关心逐点度量。 如果延迟不太长，触发连续异常段中任何点的警报都是可接受的。 已经提出了一些用于异常检测的度量来适应这种偏好，例如，[22 NAB]，但是大多数度量没有被广泛接受，这可能是因为它们太复杂了。 相反，我们使用一种简单的策略：如果可以通过选定的阈值检测到真实异常段中的任何点，那么我们就说该段被正确检测了，并且将该段中的所有点都视为可以被此段检测到。 同时，异常段外的点将照常处理。 然后相应地计算精度，召回率，AUC，F-score和best F-score。 图7中说明了这种方法。alert delay = 警报分段中第一个点与第一个检测到的点之间的时间差。</p><p><img src="/images/20200314Metric.jpg" alt="20200314Metric"></p><h4 id="Experiment-启动"><a href="#Experiment-启动" class="headerlink" title="Experiment 启动"></a>Experiment 启动</h4><p>参数设置：我们设置窗口大小W = 120，即2h。W的选择受到两个因素的限制。 一方面，W太小将导致模型无法捕获模式，因为模型被期望识别出那些仅来自窗口的正常模式，（请参阅第5.1节）。 另一方面，W太大会增加过度拟合的风险，因为我们用没有权值共享的全连接层，因此模型参数的数量与W成正比。我们将B和C的潜在维度K设置为3，因为3维空间可以很容易地可视化以便分析。隐藏层的 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 和 $p_{\theta}(\mathbf{x} | \mathbf{z})$ 都选择作两个ReLU层，每个ReLU层具有100个单位，这使得变分和生成网络具有相等的大小。我们没有对隐藏网络的结构进行详尽的搜索。</p><p>其他超参： std 层的 $\epsilon = 10^{-4}$ ，injection ratio = $\lambda$ ,  MCMC 迭代次数M = 10， 蒙特卡洛积分的采样数量$L = 1024$ ，训练的batch size = 256，运行250 Epochs，优化器是 Adam[15]，初始学习率是 $10^{-3}$ ，每过10Epochs就将学习率折0.75，对隐藏层采用L2正则化其系数coefficient = $10^{-3}$。 我们按标准裁剪clip梯度，限制为10.0。 </p><p>标签说明：为了评估没有标签的Donut，我们将忽略所有标签。 对于偶有的标签，我们对训练和验证集的异常标签进行下采样，以使其包含10％的标记异常。 请注意，缺失点不会被下采样。 我们一直随机丢弃异常片段，其概率与每个片段的长度成正比，直到达到所需的下采样率。 我们使用这种方法，而不是随机丢弃单个异常点，因为KPI是时间序列，并且每个异常点都可能泄漏有关其邻近点的信息，从而导致性能被高估。 这样的下采样完成了10次，这使我们能够进行10个独立的重复实验。 对于每个数据集，总体而言，我们有三个版本：0％标签，10％标签和100％标签。</p><h4 id="总体性能"><a href="#总体性能" class="headerlink" title="总体性能"></a>总体性能</h4><p>我们比较AUC，best F-score和平均alert delay，与三种算法相比，如图8：</p><p><img src="/images/20200314compare_metric.jpg" alt="20200314compare_metric"></p><p>比较的算法：Opprentice[25]，VAE baselin[2] 基于VAE的异常检测不处理时间序列，因此我们按以下方法设置VAE基模型。 首先，VAE基模型具有与Donut相同的网络结构，如图4所示。其次，在图3中的所有技术中，仅使用“数据准备”步骤中的那些技术。 第三，正如[2]所建议的，我们从训练数据中排除所有包含标记异常或缺失点的窗口。 Donut-Prior算法，给定一个生成模型自然学习 $p(x)$ ，而在VAE $p(x)$ 被定义为 $\mathbb{E}_{\boldsymbol{p}_{\theta}(\mathbf{z})}\left[p_{\theta}(\mathbf{x} | \mathbf{z})\right]$ ，我们还评估了重建概率的先前部分 $\mathbb{E}_{p_{\theta}(\mathbf{z})}\left[\log p_{\theta}(\mathbf{x} | \mathbf{z})\right]$。 我们只需要先验的基模型，因此我们可以通过简单的蒙特卡洛积分来计算先验期望，而无需使用先进的技术来改善结果。</p><p>The best F-score of Donut is quite satisfactory in totally unsu- pervised case, ranges from 0.75 to 0.9, </p><p>Donut，Opprentice和VAE Baseline的平均警报延迟在所有数据集中都是可接受的</p><h4 id="Donut技术的效果"><a href="#Donut技术的效果" class="headerlink" title="Donut技术的效果"></a>Donut技术的效果</h4><p>我们提出的三种技术的各自的作用(1) M-ELBO (Eqn (3)), (2) missing data injection, and (3) MCMC imputation。我们通过这些技术的四种可能的组合展示了Donut的最佳F分数：</p><p><img src="/images/202003154Tech-BestF-score.jpg" alt="202003154Tech-BestF-score"></p><p>仅M-ELBO就能在VAE基模型上做出大部分改进。 它通过训练Donut来适应x中可能出现的异常点并在这种情况下产生所需的输出而起作用。尽管对于生成模型来说很自然（第5.2节），但仅使用正常数据来训练VAE以进行异常检测不是一个好习惯。</p><p>丢失数据注入是为增强M-ELBO的效果而设计的，实际上可以看作是一种数据增强方法。我们仅注入遗漏的点。由于缺少数据注入而导致的最佳F分数的提高不是很明显。注射会给训练带来额外的随机性，因此需要更大的训练时间。</p><p>MCMC imputation还旨在帮助Donut处理异常点。 尽管Donut仅在某些情况下使用MCMC获得了最佳F评分的显着改善，但它从未损害性能。 根据[32]，这应该是预期的结果。 因此，我们建议在检测中始终采用MCMC。</p><h4 id="分析K的影响。"><a href="#分析K的影响。" class="headerlink" title="分析K的影响。"></a>分析K的影响。</h4><p>$z$ 的维度 K很重要。K太小可能会导致拟合不足或次优平衡（请参见第5.4节）。 另一方面，K太大可能会导致重建概率无法找到好的后验概率（请参阅第5.1节）。 在完全不受监督的情况下很难选择一个好的K，因此我们将其留作未来的工作。</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>我们在此提出针对重建概率以及整个Donut算法的KDE（内核密度估计）解释。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Evaluation实验&quot;&gt;&lt;a href=&quot;#Evaluation实验&quot; class=&quot;headerlink&quot; title=&quot;Evaluation实验&quot;&gt;&lt;/a&gt;Evaluation实验&lt;/h3&gt;&lt;h4 id=&quot;Datasets&quot;&gt;&lt;a href=&quot;#Datasets&quot; class=&quot;headerlink&quot; title=&quot;Datasets&quot;&gt;&lt;/a&gt;Datasets&lt;/h4&gt;&lt;p&gt;我们从大型互联网上获得了18个维护良好的商业KPIs（时间跨度足以进行培训和评估），所有的KPIs间隔为1min。三个数据集 A B C 如图6的Table1。因此我们可以评估Donut在不同级别的噪声。 我们将每个数据集分为训练集 49%，验证集21%和测试集30%。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="AnomalyDetection" scheme="http://yoursite.com/tags/AnomalyDetection/"/>
    
  </entry>
  
  <entry>
    <title>Unsupervised Anomaly Detection via Variational Auto-Encoder for Seasonal KPIs in Web Applications (Donut model, Part I)</title>
    <link href="http://yoursite.com/2020/03/13/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part1)/"/>
    <id>http://yoursite.com/2020/03/13/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part1)/</id>
    <published>2020-03-13T02:54:13.000Z</published>
    <updated>2020-04-15T13:56:06.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ABS-amp-Intro"><a href="#ABS-amp-Intro" class="headerlink" title="ABS&amp;Intro"></a>ABS&amp;Intro</h3><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>大的互联网公司一般会密切监控KPIs。然而这些有不同模式不同数据质量的季节性KPIs的异常检测很有挑战，特别是无标签。本文中，我们提出了Donut，基于VAE（Variational Auto-Encoder 变分自动编码器）的无监督异常检测算法，其最佳F-score达到0.75 ~ 0.9。我们为Donut的重构提出了一种新颖的KDE解释，使其成为第一种基于VAE的异常检测算法，并且具有扎实的理论解释。</p><a id="more"></a><h4 id="KPIs时间序列数据"><a href="#KPIs时间序列数据" class="headerlink" title="KPIs时间序列数据"></a>KPIs时间序列数据</h4><p>度量指标如页面浏览量，在线用户数量，订单数量等等。在所有的这些KPIs里，本文主要关心一些商业相关的KPIs，这些受用户行为计划所影响，因此大致表现出有规律的季节性模式（如按天，按周等）。</p><p>检测KPI异常的相关文献【1, 2, 5– 8, 17, 18, 21, 23–27, 29, 31, 35, 36, 40, 41】 很丰富。现有的异常检测算法遭受算法挑选/参数调整的麻烦，严重依赖标签，性能不令人满意和/或缺乏理论基础。</p><h4 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h4><p>本文提出的Donut，基于VAE（代表性的深层生成模型）的无监督异常检测算法，伴有理论解释，可以无标签或偶尔提供的标签下学习。</p><p>本文贡献：</p><p>1，Donut里的三项技术：改进的ELBO，缺失数据注入进行训练以及为了检测的MCMC (imputation)借补法。使它大大超越了最新的监督类和基于VAE的异常检测算法。 对于来自顶级全球互联网公司的研究KPI，无监督Donut的最佳F-score在0.75到0.9之间。</p><p>2，在文献中，我们首次发现采用VAE（或一般而言的生成模型）进行异常检测需要对正常数据和异常数据进行训练，这与通常的直觉相反。</p><p>3，我们为Donut在z空间中提出了一种新颖的KDE解释，使其成为第一个基于VAE的具有可靠理论解释的异常检测算法。这种解释可能有益于异常检测中其他深度生成模型的设计。 我们发现了潜在z空间中的时间梯度效应，很好地说明了Donut在检测季节性KPI异常方面的出色性能。</p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><h4 id="KPIs的异常检测"><a href="#KPIs的异常检测" class="headerlink" title="KPIs的异常检测"></a>KPIs的异常检测</h4><p>商业KPIs一般由季节性，另一方面在每个重复周期中，KPI曲线的形状并不完全相同，因为用户行为可能会随着天变化。这里我们命名KPIs为“具有局部变化的季节性KPIs” （如图1）</p><p><img src="/images/20200313Donut_Figure_KPIs.jpg" alt="20200313Donut_Figure1"></p><p>另一类局部变化是随着日数增加的趋势，可以通过Holt-Winters [41]和时间序列分解[6]来确定。 除非正确处理了这些局部变化，否则异常检测算法可能无法正常工作。</p><p>除了季节性，局部变化variation，这些KPIs也有噪声noise。我们假设噪声独立，在每个点服从0均值高斯分布。高斯噪声的精确值是没有意义的，因此，我们仅关注这些噪声的统计数据，即噪声的方差。</p><p>现在我们可以将季节性KPI的“正常模式”形式化为两个组成部分的组合：（1）具有局部变化的季节性模式（2）高斯噪声的统计数据。</p><p>我们使用Anomaly表示不遵循正常模式的（突然的尖峰和骤降）数据点，abnormal表示Anomaly和缺失点。本文主要检测Anomalies。</p><p>由于操作员需要处理异常以进行故障排除/缓解，因此有些异常会被标上标签。 请注意，此类偶然标签对异常的覆盖范围与典型的监督学习算法所需要的相去甚远。</p><p>异常检测算法一般对$x_{t-T+1}, \ldots, x_{t}$ 计算$p\left(y_{t}=1 | x_{t-T+1}, \ldots, x_{t}\right)$ ，操作员只需选择阈值判断异常。</p><h4 id="2-3的Problem-Statement"><a href="#2-3的Problem-Statement" class="headerlink" title="2.3的Problem Statement"></a>2.3的Problem Statement</h4><p>（挪到前面来了）在我们的上下文中，尽管远不完整，但偶尔还是可以使用标签，应该以某种方式加以利用。本文的问题陈述如下：</p><p>我们致力于<u>基于深度生成模型且具有可靠理论解释的无监督异常检测算法，该算法可以利用偶尔可用的标签</u>。</p><h3 id="Previous-Work"><a href="#Previous-Work" class="headerlink" title="Previous Work"></a>Previous Work</h3><h4 id="传统统计模型"><a href="#传统统计模型" class="headerlink" title="传统统计模型"></a>传统统计模型</h4><p>许多基于传统统计模型的异常检测器（大多是时间序列模型）[6, 17, 18, 24, 26, 27, 31, 40, 41] 已经被提出来计算异常分数。由于这些算法通常对适用的KPI有基本的假设，需要涉及专家的参考才能为给定的KPI选择合适的检测器，然后基于训练数据去微调检测器参数。这些检测器的简单集合（例如多数表决[8]和归一化[35]）不能很好地起作用。</p><h4 id="监督集成方法"><a href="#监督集成方法" class="headerlink" title="监督集成方法"></a>监督集成方法</h4><p>为了规避传统统计异常检测器算法/参数调整的麻烦，提出了有监督的集成方法<strong>EGADS [21]和Opprentice [25]</strong>。 他们使用用户反馈作为标签并使用传统检测器输出的异常评分作为特征来训练异常分类器。 EGADS和Opprentice均显示出令人鼓舞的结果，但它们严重依赖于<strong>良好的标签</strong>（远远超过我们所积累的轶事标签），这在大规模应用中通常不可行。 此外，运行多个传统检测器以在检测期间提取特征会引入大量的计算成本，这是一个实际问题。</p><h4 id="无监督方法与深度生成模型"><a href="#无监督方法与深度生成模型" class="headerlink" title="无监督方法与深度生成模型"></a>无监督方法与深度生成模型</h4><p>最近采用无监督机器学习方法是个趋势。, e.g., one-class SVM [1, 7], clustering based methods [9] like K-Means [28] and GMM [23], KDE [29], and VAE [2] and VRNN [36].  </p><p>其理念是关注正常模式而不是异常：由于KPIs通常主要由正常数据组成，因此即使没有标签也可以轻松地训练模型。 粗略地说，它们都首先识别原始或某些潜在特征空间中的“正常”区域，然后通过测量观测值与正常区域的“距离”来计算异常分数。</p><p>沿着此方向，1，学习正常模式可以看作是学习训练数据的分布，这是生成模型的主题。2，最近在利用深度学习技术训练生成模型方面取得了巨大进展（例如<strong>GAN [13]和深度贝叶斯网络[4，39]</strong>）。后者属于深度生成模型家族，它采用图形graphical[30]模型框架和变分技术[3]，以VAE [16，32]为代表。 3，尽管深度生成模型在异常检测方面具有广阔的前景，但现有的基于VAE的异常检测方法[2]并非为KPIs（时间序列）设计，在我们的设置中效果不佳（请参见§4），并且没有 为其用于异常检测的深度生成模型的设计提供支持的理论基础（请参阅§5）4，简单地采用基于VRNN的更复杂的模型[36]在我们的实验中显示出训练时间长且性能差。5，[2]假定仅对干净数据进行训练，这在我们的上下文中是不可行的。</p><h3 id="变分自动编码器Variational-Auto-Encoder"><a href="#变分自动编码器Variational-Auto-Encoder" class="headerlink" title="变分自动编码器Variational Auto-Encoder"></a>变分自动编码器Variational Auto-Encoder</h3><p>由于VAE是深度贝叶斯网络的基本构建块，因此我们选择开始使用VAE。</p><p><img src="/images/20200313Donut_Figure2_VAE.jpg" alt="20200313Donut_Figure2_VAE"></p><h4 id="VAE的背景"><a href="#VAE的背景" class="headerlink" title="VAE的背景"></a>VAE的背景</h4><p>深度贝叶斯网络使用神经网络来表达变量之间的关系，因此它们不再局限于简单的分布族，因此可以轻松地应用于复杂的数据。 在训练和预测中经常采用变分推理技术[12]，这是由神经网络延伸出的解决后验分布的有效方法。</p><p>VAE是深度贝叶斯网络，它对两个随机变量（潜变量$z$和可见变量$x$）之间的关系进行建模。 为 $z$ 选择一个先验分布，它通常是多元单位高斯分布 $\mathcal{N}(\mathbf{0}, \mathbf{I})$ 。之后，从由参数为 $\theta$ 的神经网络提取出的 $p_{\theta}(\mathbf{x} | \mathbf{z})$ 中采样得到 $x$ 。$p_{\theta}(\mathbf{z} | \mathbf{x})$ 的准确形式由任务需求进行选择。真实的后验 $p_{\theta}(\mathbf{z} | \mathbf{x})$ 是无解析解的，但对于训练是必不可少的，并且通常对预测有用，因此变分推理技术可用于fit另外的神经网络，作为近似后验 $q_{\phi}(\mathbf{z} | \mathbf{x})$。该后验通常被假定为 $\mathcal{N}\left(\boldsymbol{\mu}_{\phi}(\mathbf{x}), \boldsymbol{\sigma}_{\phi}^{2}(\mathbf{x})\right)$ , $\boldsymbol{\mu}_{\phi}(\mathbf{x})$ 与 $\boldsymbol{\sigma}_{\phi}(\mathbf{x})$ 是由神经网络导出。（如图FIgure2）</p><p>SGVB [16, 32] 是一个伴随VAE一起用的变分推断算法，其中通过最大化变分下界evidence lower bound (ELBO Eqn1 ) 来联合训练近似后验模型和生成模型。</p><p>Equation 1:</p><script type="math/tex; mode=display">\begin{aligned} \log p_{\theta}(\mathbf{x}) & \geq \log p_{\theta}(\mathbf{x})-\operatorname{KL}\left[q_{\phi}(\mathbf{z} | \mathbf{x}) \| p_{\theta}(\mathbf{z} | \mathbf{x})\right] \\ &=\mathcal{L}(\mathbf{x}) \\ &=\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{x})+\log p_{\theta}(\mathbf{z} | \mathbf{x})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right] \\ &=\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{x}, \mathbf{z})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right] \\ &=\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{x} | \mathbf{z})+\log p_{\theta}(\mathbf{z})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right] \end{aligned}</script><p>蒙特卡洛积分常常被用于近似 Eqn 1 中的期望。如Eqn 2，$\mathbf{z}^{(l)}, l=1 \ldots L$ 是来自 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 的样例samples。整个本文中，我们都坚持使用这种方法。</p><p>Equation 2：</p><script type="math/tex; mode=display">\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}[f(\mathbf{z})] \approx \frac{1}{L} \sum_{l=1}^{L} f\left(\mathbf{z}^{(l)}\right)</script><h3 id="Architecture结构"><a href="#Architecture结构" class="headerlink" title="Architecture结构"></a>Architecture结构</h3><p>Donut的总体架构如图Figure3，三个关键技术是Modified ELBO，训练时的Missing Data Injection， 检测时的MCMC Imputation。</p><p><img src="/images/20200314Arch_Donut.jpg" alt="20200314Arch_Donut"></p><p><img src="/images/20200314Network_Donut.jpg" alt="20200314Network_Donut"></p><h4 id="Network-Structure"><a href="#Network-Structure" class="headerlink" title="Network Structure"></a>Network Structure</h4><p>VAE不是一个序列模型，因此我们在KPI上应用长度为 $w$ 的<strong>滑动窗口</strong>[34]。 对于每一个 $x_t$ 使用 $x_{t-W+1}, …, x_{t}$ 作为VAE的 $X$  向量。该滑动窗口由于其简单性而首先被采用，实际上却带来了重要而有益的结果。</p><p>Donut的总体网络结构如图4，其中有双线轮廓的组件 (e.g., Sliding Window x, W Dimensional at bottom left) 是我们的新设计，其余组件来自标准VAEs。先验 $p_{\theta}(z)$ 被选择为 $\mathcal{N}(\mathrm{0}, \mathrm{I})$ 。 x和z后验均选择为对角高斯 diagonal Gaussian：</p><script type="math/tex; mode=display">p_{\theta}(\mathbf{x} | \mathbf{z})=\mathcal{N}\left(\boldsymbol{\mu}_{\mathbf{x}}, \boldsymbol{\sigma}_{\mathbf{x}}^{2} \mathbf{I}\right)</script><script type="math/tex; mode=display">q_{\phi}(\mathbf{z} | \mathbf{x})=\mathcal{N}\left(\boldsymbol{\mu}_{\mathbf{z}}, \boldsymbol{\sigma}_{\mathbf{z}}^{2} \mathbf{I}\right)</script><p>这里的$\mu_x,\mu_z,\sigma_x,\sigma_z$ 是每个独立高斯组件的均值和标准差。 $z$ 是 K 维的。通过分离的隐藏层$f_{\phi}(\mathbf{x}) , f_{\theta}(\mathbf{z})$ ，从 $x$ 和 $z$ 隐藏特征被提取出来。然后从隐藏特征中得出x和z的高斯参数。 </p><p>均值是从线性层导出：</p><script type="math/tex; mode=display">\boldsymbol{\mu}_{\mathbf{X}}=\mathbf{W}_{\boldsymbol{\mu}_{\mathbf{X}}}^{\top} f_{\theta}(\mathbf{z})+\mathbf{b}_{\boldsymbol{\mu}_{\mathbf{X}}}</script><script type="math/tex; mode=display">\boldsymbol\mu_{z}=\mathbf{W}_{\mu_{z}}^{\top} f_{\phi}(\mathbf{x})+\mathbf{b}_{\mu_{z}}</script><p>标准差是从soft-plus层导出，加上一个非负小数 $\epsilon$ ：</p><script type="math/tex; mode=display">\sigma_{\mathrm{x}} = \text{SoftPlus} \left[\mathbf{W}_{\sigma_{x}}^{\top} f_{\phi}(\mathbf{x})+\mathbf{b}_{\sigma_{x}}\right]+\epsilon</script><script type="math/tex; mode=display">\sigma_{\mathrm{z}}=\text{SoftPlus} \left[\mathbf{W}_{\boldsymbol{\sigma}_{\mathbf{z}}}^{\top} f_{\phi}(\mathbf{z})+\mathbf{b}_{\boldsymbol{\sigma}_{\mathbf{z}}}\right]+\boldsymbol{\epsilon}</script><p>这里的 $\text{SoftPlus}[a] = log[exp(a) + 1]$ ，这里介绍的所有W-s和b-s是相应层的参数。 注意，将标量函数 $f(x)$ 应用于向量 $x$ 时，意味着将其应用于每个部分component。</p><p>我们以此种方式导出 $\sigma_x, \sigma_z$ 而非像其他人一样用线性层导出 $log_{\sigma_x}$ 有以下几个原因：我们关注的 KPIs 的局部变化非常小，以至于 $\sigma_x$ 和 $\sigma_z$ 可能变得非常接近于零，从而使 $log_{\sigma_x}$ 和$\log_{\sigma_z}$无界。 在计算高斯变量的可能性时，这将导致严重的数值问题。 因此，我们使用soft-plus和 $\epsilon$ 技巧来防止此类问题。</p><p>我们有意选择全连接层作为隐藏层的结构，从而使整体体系结构相当简单。 这是因为我们的目标是开发具有扎实的理论解释的基于VAE的异常检测算法，并且简单的网络结构无疑将使在复杂的“变分自动编码器”中分析内部行为更加容易。</p><h4 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h4><p>训练直接用SGVB[16] 算法去优化 ELBO (Eqn 1) ，由于[16]报告，当使用SGVB算法训练VAE时，一个样本已经足以计算ELBO，因此在训练期间让采样数$L = 1$。我们还按照SGVB的要求应用了重新参数化技巧：没有采样 $\mathbf{z} \sim \mathcal{N}\left(\boldsymbol{\mu}_{\mathbf{z}}, \boldsymbol{\sigma}_{\mathbf{z}}^{2} \mathbf{I}\right)$ ，专门的随机变量 $\xi \sim \mathcal{N}(0, \mathrm{I})$ 被采样，如此我们重写 $z$ 为 $\mathbf{z}(\boldsymbol{\xi})=\boldsymbol{\mu}_{\mathbf{z}}+\boldsymbol{\xi} \cdot \boldsymbol{\sigma}_{\mathbf{z}}$。$\xi$ 上的采样与参数 $\phi$ 无关，像VAE是普通神经网络一样，这使我们能够应用<strong>随机梯度下降</strong>。$x$ 的窗口在每个epoch之前都会随机打乱，这有利于随机梯度下降。 在每个mini-batch中要获取足够多的 $x$，这对于稳定训练至关重要，因为采样会引入额外的随机性。</p><p>对于某些给定的KPIs这里没有labels，可能会想用合成的值替换训练数据中的标记异常（如果有）和缺失点（已知）。先前的一些工作已经提出了填补缺失数据的方法，例如[37]，但是很难产生足够好地遵循“正常模式”的数据。重要的是，用另一种算法生成的数据训练生成模型是很荒谬的，因为生成模型的一个主要应用就是生成数据。 使用由比VAE更弱的算法估算的数据可能会降低性能。 因此，我们不会在训练VAE之前采用缺失数据插值imputation，而是选择简单地将缺失点填充为零（在图3中的数据准备步骤中），然后修改ELBO（以下简称M-ELBO）以排除异常和缺失点的影响（如图所示）。 如图3中的“训练”步骤。</p><p>更具体地，我们<strong>修改标准的ELBO</strong> （Eqn 1中）为 Eqn 3：</p><script type="math/tex; mode=display">\widetilde{\mathcal{L}}(\mathbf{x})=\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\sum_{w=1}^{W} \alpha_{w} \log p_{\theta}\left(x_{w} | \mathbf{z}\right)+\beta \log p_{\theta}(\mathbf{z})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right]</script><p>其中 $\alpha_w$ 定义为指示值 indicator，当$\alpha_w = 1$ 指示 $x_w$ 不是异常值或缺失值。$\alpha_w = 0$ 反之。$\beta$ 被定义为 $\left(\sum_{w=1}^{W} \alpha_{w}\right) / W$ 。请注意，当训练数据中没有标记的异常时，方程（3）仍然成立。$\alpha_w$ 直接排除了来自标记的异常和缺失点的 $p_{\theta}\left(x_{w} | \mathbf{z}\right)$ 的贡献，而缩放因子 $\beta$ 根据 $x$ 中正常点的比例缩小了 $p_{\theta}(\mathbf{z})$ 的贡献。这种修改使Donut能够正确地重建 $x$ 内的正常点，即使 $x$ 内的某些点异常。我们并没有收缩 $q_{\phi}(\mathbf{z} | \mathbf{x})$ ，因为下面两个考虑：不像 $p_{\theta}(\mathbf{z})$ 是生成模型 （即“正常模式”的模型）中的一部分，$q_{\phi}(\mathbf{z} | \mathbf{x})$ 仅仅描述了从x到z的映射，并未考虑“正常模式”。因此，似乎没有必要去掉 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 的贡献。另一个原因是 $\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right]$ 是 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 的熵。这个熵术语实际上在训练中还有其他作用（将在5.3节中讨论），因此最好保持不变。</p><p>进一步地，我们还在训练中引入了<strong>缺失数据注入</strong>：我们将 $λ$ 比例的正常点随机设置为零，就好像它们是缺失点一样。 缺失点更多，当给定异常 $x$ 时 ，会更频繁地训练Donut来重建正常点，从而增强了M-ELBO的效果。 该注入在每轮  epoch 之前完成，并且在Epoch 结束后恢复点。 图3中的Training步骤显示了这种丢失的数据注入。</p><h4 id="Detection"><a href="#Detection" class="headerlink" title="Detection"></a>Detection</h4><p>与仅为一个目的而设计的判别模型（例如，为仅计算分类概率 $p(y|x)$ 而设计的分类器）不同，像VAE这样的生成模型可以得出各种输出。 在异常检测的范围内，观察窗 $x$ 的可能性（即VAE中的 $p_{\theta}(\mathbf{x})$ ）是重要的输出，因为我们想知道给定的 $x$ 遵循正常模式的程度。可以采用蒙特卡洛方法来计算 $x$ 的概率密度 <script type="math/tex">p_{\theta}(\mathbf{x})=\mathbb{E}_{p_{\theta}(\mathbf{z})}\left[p_{\theta}(\mathbf{x} | \mathbf{z})\right]</script> 。尽管在理论上有很好的解释，但实际上，对先验样本进行采样实际上并不能很好地完成工作，如第4段所示</p><p>与其对先验进行采样，不如通过变分后验 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 来推导有用的输出。一种选择是计算出 $\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[p_{\theta}(\mathbf{x} | \mathbf{z})\right]$ 。尽管与 $p_{\theta}(\mathbf{x})$ 相似，它实际上不是一个定义很好的概率密度。另一种选择是计算在[2] 中采用的 $\mathbb{E}_{\boldsymbol{q}_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{x} | \mathbf{z})\right]$ ，称为“重建概率”。由于在异常检测中只关注异常评分的顺序而不是确切值，因此我们遵循[2]并使用后者。或者另一个可选项，如[36]所示，ELBO（等式Eqn 1）也可用于近似 $\log p_{\theta}(\mathbf{x})$。然而，在ELBO的另外一项  $\mathbb{E}_{q_{\phi}(\mathbf{z} | \mathbf{x})}\left[\log p_{\theta}(\mathbf{z})-\log q_{\phi}(\mathbf{z} | \mathbf{x})\right]$  使其内部机制难以理解。 由于[36]中的实验不支持该可选方法的优越性，因此我们选择不使用它。</p><p>在检测期间，测试窗口$x$中的异常点和缺失点可能给映射的 $z$ 带来偏差，并进一步使重建概率不准确，这将在5.2节中讨论。 由于缺失点始终是已知的（称为“null”），我们有机会消除缺失点所带来的偏差。 我们选择采用经过训练的VAE的基于MCMC的缺失数据插入imputation技术，该技术由[32]提出。 同时，我们在检测之前不知道异常点的确切位置，因此无法对异常采用MCMC。</p><p>更具体地，测试 $x$ 被划分为观察部分和缺失部分，即 $\left(\mathbf{x}_{o}, \mathbf{x}_{m}\right)$。一个 $z$ 样例从 $q_{\phi}\left(\mathbf{z} | \mathbf{x}_{o}, \mathbf{x}_{m}\right)$ 中获取，然后一个重建样例 $\left(\mathbf{x}_{\boldsymbol{o}}^{\prime}, \mathbf{x}_{m}^{\prime}\right)$ 从 $p_{\theta}\left(\mathbf{x}_{\boldsymbol{o}}, \mathbf{x}_{m} | \mathbf{z}\right)$ 中获取得到。$\left(\mathbf{x}_{o}, \mathbf{x}_{m}\right)$ then由 $\left(\mathbf{x}_{\boldsymbol{o}}, \mathbf{x}_{m}^{\prime}\right)$ 替换，即观察点是固定的，缺失点被设置为新值。  这个过程迭代 M次，然后最终的 $\left(\mathbf{x}_{o}, \mathbf{x}_{m}^{\prime}\right)$ 被用来计算重建概率。在整个过程中，中间值$\mathbf{x}_{m}^{\prime}$会越来越接近正常值。给定足够大的M，可以减少偏差，并且可以获得更准确的重构概率。 MCMC方法在图5中说明，并在图3的“检测”步骤中显示。</p><p><img src="/images/20200314Figure5_MCMC.jpg" alt="20200314Figure5_MCMC"></p><p>MCMC之后，我们取z的L个样本通过蒙特卡洛积分来计算重构概率。 值得一提的是，尽管我们可以计算x的每个窗口中每个点的重建概率，但我们仅使用最后一个点的分数（即$x_t$ 在 $x_{t-T+1}, \ldots, x_{t}$），因为我们想要将在检测过程中尽快归纳异常 。后续文章中我们仍将使用矢量符号，它们与VAE的体系结构相对应。 尽管可以通过延迟决策并在不同时间考虑同一点的更多分数来提高检测性能，但我们将其留作将来的工作。</p><p><a href="https://saruagithub.github.io/2020/03/14/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part2" target="_blank" rel="noopener">实验部分Part2</a>/)</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，Xu H, Chen W, Zhao N, et al. Unsupervised anomaly detection via variational auto-encoder for seasonal kpis in web applications[C]//Proceedings of the 2018 World Wide Web Conference. 2018: 187-196.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ABS-amp-Intro&quot;&gt;&lt;a href=&quot;#ABS-amp-Intro&quot; class=&quot;headerlink&quot; title=&quot;ABS&amp;amp;Intro&quot;&gt;&lt;/a&gt;ABS&amp;amp;Intro&lt;/h3&gt;&lt;h4 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h4&gt;&lt;p&gt;大的互联网公司一般会密切监控KPIs。然而这些有不同模式不同数据质量的季节性KPIs的异常检测很有挑战，特别是无标签。本文中，我们提出了Donut，基于VAE（Variational Auto-Encoder 变分自动编码器）的无监督异常检测算法，其最佳F-score达到0.75 ~ 0.9。我们为Donut的重构提出了一种新颖的KDE解释，使其成为第一种基于VAE的异常检测算法，并且具有扎实的理论解释。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="AnomalyDetection" scheme="http://yoursite.com/tags/AnomalyDetection/"/>
    
  </entry>
  
  <entry>
    <title>Computers&amp;Operations Research部分论文简读</title>
    <link href="http://yoursite.com/2020/03/10/20200310Computers&amp;Operations%20Research%E9%83%A8%E5%88%86%E8%AE%BA%E6%96%87%E7%AE%80%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/03/10/20200310Computers&amp;Operations%20Research%E9%83%A8%E5%88%86%E8%AE%BA%E6%96%87%E7%AE%80%E8%AF%BB/</id>
    <published>2020-03-10T01:58:02.000Z</published>
    <updated>2020-03-18T12:33:20.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Exact-and-heuristic-approaches-to-detect-failures-in-failed-k-out-of-n-systems"><a href="#Exact-and-heuristic-approaches-to-detect-failures-in-failed-k-out-of-n-systems" class="headerlink" title="Exact and heuristic approaches to detect failures in failed k-out-of-n systems"></a>Exact and heuristic approaches to detect failures in failed k-out-of-n systems</h2><h3 id="ABS-amp-Intro"><a href="#ABS-amp-Intro" class="headerlink" title="ABS&amp;Intro"></a>ABS&amp;Intro</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>本文考虑n个系统中k个故障了（表决系统），相应的测试每个组件是有成本的。另外，我们具有某些组件是故障的原因的先验概率信息。目标是以最小的预期成本去识别导致故障的那部分组件。</p><a id="more"></a><h4 id="本文工作"><a href="#本文工作" class="headerlink" title="本文工作"></a>本文工作</h4><p>提出了精确与近似的策略，在故障表决系统（k-out-of-n）中检测组件状态。我们提出两种整数规划编程公式，两种基于Markov决策过程（MDP）的新颖方法以及两种启发式算法。展示了精确式算法的限制以及启发式算法在随机产生的测试例子的有效性。尽管CPU时间更长，整数规划更灵活地整合更多约束 restriction，例如必要时进行测试优先级关系。数值结果表明，针对所提出的MDP模型进行动态编程是最有效的精确方法，在一小时内最多可解决12个组件。 针对小到中级测试实例，启发式算法的性能是对比精确式算法给的，并针对高级测试实例给出下限。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>系统越来越复杂，组件、感应器，子系统越来越多。为了系统更加可靠，系统中总会有冗余存在。当组件故障时，整个系统也可能fail，需要尽快恢复。两个主要问题：(1) 是否系统工作和失败（序列测试问题） (2) 故障原因（failure detection故障检测问题）。在这两种问题中，可行的解决方法可以被描述为二分决策树，目标是最小化期望成本。</p><p>difference区别：故障检测问题中测试结果的概率随着测试执行而变化。但在序列测试问题中则是不变的。另一个区别是，在故障检测问题中，输出是导致故障的一组组件，而在序列测试问题中，输出是系统正在运行或发生故障的信息以及该状态的证明。</p><h4 id="研究综述"><a href="#研究综述" class="headerlink" title="研究综述"></a>研究综述</h4><p>序列测试问题和故障检测问题：Chang 研究在序列测试的上下文中以最小的成本诊断电子晶体，并提供多项式时间的精确式算法。B K 提出了表决系统以在核反应堆子系统中提供冗余，以实现可靠的运行。W提出当测试不完美并且测试有优先限制时的启发式算法。Ba分析某些维护策略的长期平均成本。Gar蚁群优化算法用于计算机网络中的故障定位。</p><p>故障检测问题的灵异研究领域：离散搜索问题，旨在找到隐藏在N个盒子中的一个item，并且其预期成本最小。检查盒子会很昂贵，并且已知该item在盒子内的概率是先验的。K对搜索问题提出最优贪心算法，当仅可能出现假阳性结果时。W&amp;D考虑一个变体，当存在简单的优先级约束并且路径依赖关系由组活动定义时。</p><h4 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h4><p>1，我们引入和研究了k-out-of-n系统的故障检测问题，将文献中研究的n-out-of-n系统归纳了下来。</p><p>2，我们提供了四种精确的两种启发式方法来解决该问题，并提供了两种下限lower bound方案，用于在较大的情况下进行基准测试。</p><p>3，首次提出整数规划建模和马尔可夫决策过程来解决此类问题。</p><p>4，我们进行数值实验以评估不同方法的有效性。</p><p>（暂时了解背景和introduction，未读完）</p><h2 id="A-survey-of-models-and-algorithms-for-emergency-response-logistics-in-electric-distribution-systems-Part-I-Reliability-planning-with-fault-considerations"><a href="#A-survey-of-models-and-algorithms-for-emergency-response-logistics-in-electric-distribution-systems-Part-I-Reliability-planning-with-fault-considerations" class="headerlink" title="A survey of models and algorithms for emergency response logistics in electric distribution systems. Part I: Reliability planning with fault considerations"></a>A survey of models and algorithms for emergency response logistics in electric distribution systems. Part I: Reliability planning with fault considerations</h2><h3 id="ABS-amp-Intro-1"><a href="#ABS-amp-Intro-1" class="headerlink" title="ABS&amp;Intro"></a>ABS&amp;Intro</h3><p>配电系统的应急响应设计一系列在可靠性和应急计划级别的决策问题。这些操作包括故障诊断，故障定位，故障隔离，恢复和修复。本文回顾了针对与配电运行相关的故障考虑的可靠性规划问题的优化模型和解决方法。本文对确定配电变电站单故障容量，重新分配超负荷，配置配电系统，将地理区域划分为服务区域以及定位物料仓库和仓库的研究进行了调查。</p><p>规划应急响应的操作涉及许多决策问题，可以使用运筹学方法论来解决。 故障情况可能会导致配电系统服务中断的“极端”状态，从而降低服务质量并给电力公司造成经济损失。eg 2008年1月在中国中东部和南部地区的暴风雪使几个省的电线和电线杆倒塌，影响了中国近三分之二的土地，估计造成了100亿美元的直接经济损失。但应急分配响应研究少。</p><p>由于网络拓扑结构，操作能力和应用的操作设备等特性的差异，规划人员面临的问题非常复杂，并且因地而异。 在过去的二十年中，文献中已经出现了越来越多的运筹学应用程序用于应急分配响应。配电系统中涉及的大量组件，配电网络的复杂性以及公用事业运营这些网络的能力不断提高，所有这些都促使人们在配电公用事业的各个层面上使用优化技术。</p><h2 id="Application-of-Optimized-Machine-Learning-Techniques-for-Prediction-of-Occupational-Accidents"><a href="#Application-of-Optimized-Machine-Learning-Techniques-for-Prediction-of-Occupational-Accidents" class="headerlink" title="Application of Optimized Machine Learning Techniques for Prediction of Occupational Accidents"></a>Application of Optimized Machine Learning Techniques for Prediction of Occupational Accidents</h2><h3 id="ABS-amp-Intro-2"><a href="#ABS-amp-Intro-2" class="headerlink" title="ABS&amp;Intro"></a>ABS&amp;Intro</h3><p>机器学习在职业安全领域中预测事故的探索几乎是新的。但基于ML方法的算法在参数合理调整优化之前并不能得到最佳性能。更进一步，此外，仅选择高效的优化分类器可能无法满足总体决策目的，因为它无法解释事故发生背后的因素之间的相互关系。因此，除了预测之外，还需要从事故数据中提取决策规则。</p><p>考虑到上述问题，在这项研究中，使用职业事故数据occupational accident data，已优化的机器学习算法来已经被应用于预测事故后果，例如伤害，差错和财产损失。使用了两种流行的机器学习算法，即支持向量机（SVM）和人工神经网络（ANN），其参数通过两种强大的优化算法进行了优化，<strong>即遗传算法（GA）和粒子群优化（PSO）</strong>，以实现更高的准确性和鲁棒性。基于PSO的SVM具有最高的准确性和鲁棒性，优于其他算法。此外，<strong>通过将决策树C5.0算法与基于PSO的SVM模型相结合来提取规则</strong>。最后，提取了一组九个有用的规则，以识别造成伤害，near miss差错和财产损失案件的根本原因。提出了一个钢铁厂的案例研究case study，以揭示该方法的潜力和有效性。</p><p>简介：全球每年约有230万工人死于职业事故和疾病，其中包括约36万致命事故[1]。事故的根本原因是不安全的情况或不安全的行为，或两者兼有。造成事故的因素有很多。文献中有许多理论可以解释事故的因果关系。 Khanzode等 [5]解释了他们在事故背后的各种研究理论，例如事故倾向性理论[6]，多米诺骨牌理论[7]，伤害流行病学[8]，系统理论[9]，社会技术系统理论[10]和宏观人机工程学理论[11]。由于一系列事件或因果关系的存在，导致发生伤害事件。如果知道原因，则可以预测结果（即事故）。另外，预测模型将量化各种因果因素对事故发生的贡献。</p><p>ML用于预测模型很广泛。然而，ML技术用于职业事件分析还是有限的 limited biasis。至今，关于职业分析的研究展示了基于机器学习技术的预测能力[14]和解释能力[15]。这些方法基于事件报告中的历史数据或与员工进行的访谈，可确保它们在预测功能和影响事件结果的预测变量的重要性方面优于常规统计数据。</p><p>本文：</p><p>本研究的主要目标是使用机器学习技术（即SVM和ANN）开发预测模型，以预测职业事故的后果。 为了获得更好的精度，在分类器上采用了优化技术，即GA和PSO。 此外，基于PSO-SVM、结合决策树（C5.0）的分类器对伤害injury的发生提取规则。 次要目标包括使用卡方特征选择技术识别可归因于事件结果的相关变量。 分析结果显示了SVM分类器在预测以及规则提取目的方面的效用。</p><h3 id="文献综述"><a href="#文献综述" class="headerlink" title="文献综述"></a>文献综述</h3><p>在职业事件预测中，许多机器学习算法如SVM，ANN，Extreme Learning machine（极限学习机）与决策树等。在DT在事故分析中的应用中，通常使用C4.5，C5.0分类和回归树（CART）分析，卡方自动交互检测器（CHAID）等算法来预测职业事故。使用DT的主要目的是预测和解释数据中的定性和定量模式，从而对隐藏信息探索。 由于对属性分布或属性独立性假设的放宽，DTs已成功应用于医学[17]，社会科学[18]，业务管理[19]，建筑工程与管理[20]，过程等不同领域 工业[13]。</p><p>除了DTs，神经网络，贝叶斯分类器，自适应神经模糊推理系统（ANFIS），贝叶斯网络，支持向量机，extreme learning machine (ELM) 被用于不同的领域。eg：He等。试图通过使用ANN的后向算法（BA-ANN）和指数评估方法（EEM）的分类技术解决煤与瓦斯突发问题[24]。使用BAANN，针对响应变量（即煤和瓦斯突发）计算因子的权重。Yi等人他们收集了550份与工作，环境和个人有关的数据，并由ANN进行了分析，以预测建筑工地工人的感知劳累（RPE）等级。</p><p>以上机器学习方法都要调整参数。为了调整分类算法的参数，发现优化方法比其他技术（如手动调整或网格搜索）最有用。从其他领域的研究可以看出，为了提高SVM模型的准确性，可以考虑优化惩罚因子（c）和内核参数 r [27]。有许多优化技术用于这个目的像遗传算法（GA），粒子群优化（PSO），梯度下降法等[28]。其中，GA和PSO被认为是最优化分类器参数（例如SVM）以实现更高准确度的方法[29]。使用基于GA算法的反向传播神经网络（BPNN）的初始参数，网络拓扑，权重和阈值[30]。 </p><p>分类器不仅取决于参数，还取决于数据类型。数值属性比类别属性或纯文本属性有更多信息。事故领域中的大多数文献都使用数值数据或类别数据来分析事故场景。 对纯文本数据的分析仍未得到充分利用，因为从纯文本中提取模式是一项艰巨的任务。 叙事文本是预测事故的关键资源之一。 它提供了分析中有价值的附加信息以及其他类型的数据。如布朗所做的一个值得注意的贡献是使用与潜在狄利克雷分配（LDA）和随机森林[35]等其他技术相关的文本挖掘来分析铁路事故数据，以探索事故背后的主要因素。在道路事故分析中，Pereira等人进行了一项研究。使用交通事件报告的主题建模来实时提取信息以预测事件持续时间[40]。</p><p>从事故数据集中提取规则及其解释通常被认为是一种有效的方法。通常可以使用决策树（DT）或关联规则挖掘（ARM）方法获得规则。在一些职业事故研究中，DT已比ARM更多地用于规则提取和解释。当目标函数是离散值，属性值对可描述目标函数或对数据集进行噪声训练时，发现DT很有用。还尝试过带有SVM的DT算法，以将SVM决策的黑匣子变成透明且可理解的规则，这些规则可用作任何决策任务的第二意见。</p><h3 id="本文研究关键"><a href="#本文研究关键" class="headerlink" title="本文研究关键"></a>本文研究关键</h3><p>1，将文本数据与非文本数据用于事件预测</p><p>2，分类器的参数优化，以获得更好的预测准确率</p><p>3，少有基于SVM的规则提取用于事件发生的研究</p><h2 id="Application-of-SVM-and-ANN-for-intrusion-detection"><a href="#Application-of-SVM-and-ANN-for-intrusion-detection" class="headerlink" title="Application of SVM and ANN for intrusion detection"></a>Application of SVM and ANN for intrusion detection</h2><h3 id="ABS-amp-Intro-3"><a href="#ABS-amp-Intro-3" class="headerlink" title="ABS &amp; Intro"></a>ABS &amp; Intro</h3><p>两种数据挖掘技术，ANNs 人工神经网络和支持向量机。两种编码方式，，基于简单频率的方案和tf×idf方案，来检测潜在的系统入侵。我们的结果展示采用TF-IDF方案的SVM性能最佳，而基于简单频率方案的ANN表现最差。实验中使用的数据是麻省理工学院林肯实验室的DARPA 1998入侵检测评估计划的BSM审核数据。</p><p>简介：电子商务和最近的在线消费者热潮迫使对共享网络上的系统的基本计算机安全设计进行更改。 现在设计的系统具有更高的灵活性和更少的屏障安全性。 此外，随着计算机在金融上越来越普及给大众，它们也越来越以消费者为导向。 用户友好性和公共可访问性的结合，尽管对普通人有利，但不可避免地使交换的信息容易受到犯罪分子的攻击。 存储在内部数据仓库中的消费者信息，员工数据或知识产权受到外部攻击者和不满员工的威胁，他们可能会滥用访问权限谋取私利。由于软件应用程序中隐藏的弱点和错误bug，安全策略或防火墙很难阻止此类攻击。 此外，黑客不断发明新的攻击并通过Internet进行传播。</p><p> 入侵检测系统可以检测，识别并响应未经授权的或异常的活动，具有缓解或防止此类攻击的潜力。 因此，security breech是Internet社区日益关注的一个领域[2]。</p><p>大多数研究人员（请参见表1）使用简短的系统调用序列来表征程序行为。少部分使用系统调用的频率分布。与基于序列的编码技术相比，基于频率的编码技术所需的开销更少，基于序列的编码技术需要为每个程序构建一个文件（例如，必须为sendmail或lpr 1构建一个文件），并在每个时间帧检查攻击 。 基于频率的编码技术仅为每个进程而不是每个程序（一个进程可能包含多个程序）建立一个配置文件，并在该过程结束时检查攻击实例。 </p><p>在这项研究中，我们探索了应用人工神经网络（ANN）和支持向量机（SVM）预测基于基于频率的编码技术的攻击的可行性。使用ANN和SVM进行攻击检测的目的是从有限的训练数据中发展泛化能力。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，Yavuz T, Kundakcioglu O E, Ünlüyurt T. Exact and heuristic approaches to detect failures in failed k-out-of-n systems[J]. Computers &amp; Operations Research, 2019, 112: 104752.</p><p>2，A survey of models and algorithms for emergency response logistics in electric distribution systems. Part I: Reliability planning with fault considerations</p><p>3，Application of Optimized Machine Learning Techniques for Prediction of Occupational Accidents</p><p>4，Application of SVM and ANN for intrusion detection （Wun-Hwa Chen, Sheng-Hsun Hsu∗, Hwang-Pin Shen）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Exact-and-heuristic-approaches-to-detect-failures-in-failed-k-out-of-n-systems&quot;&gt;&lt;a href=&quot;#Exact-and-heuristic-approaches-to-detect-failures-in-failed-k-out-of-n-systems&quot; class=&quot;headerlink&quot; title=&quot;Exact and heuristic approaches to detect failures in failed k-out-of-n systems&quot;&gt;&lt;/a&gt;Exact and heuristic approaches to detect failures in failed k-out-of-n systems&lt;/h2&gt;&lt;h3 id=&quot;ABS-amp-Intro&quot;&gt;&lt;a href=&quot;#ABS-amp-Intro&quot; class=&quot;headerlink&quot; title=&quot;ABS&amp;amp;Intro&quot;&gt;&lt;/a&gt;ABS&amp;amp;Intro&lt;/h3&gt;&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;本文考虑n个系统中k个故障了（表决系统），相应的测试每个组件是有成本的。另外，我们具有某些组件是故障的原因的先验概率信息。目标是以最小的预期成本去识别导致故障的那部分组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="故障检测" scheme="http://yoursite.com/tags/%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B/"/>
    
      <category term="Operation Research" scheme="http://yoursite.com/tags/Operation-Research/"/>
    
  </entry>
  
  <entry>
    <title>排序算法复习</title>
    <link href="http://yoursite.com/2020/03/10/20200309%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/03/10/20200309%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-03-10T01:06:57.000Z</published>
    <updated>2020-04-13T05:11:06.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>排序算法在搜索中常用，因此非常重要。排序算法里包含了重要的分治的思想，就是在划分子问题上。归并排序将数据折半划分，快速排序将数据分成大数和小数部分，基数排序则每次都会按照关键码中的一个数字划分数据。</p><p>什么是稳定的排序：如果一种排序算法不会改变关键码值相同的记录的相对顺序，则称为稳定的。</p><h4 id="三种基本的排序算法"><a href="#三种基本的排序算法" class="headerlink" title="三种基本的排序算法"></a>三种基本的排序算法</h4><a id="more"></a><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>例子：每处理一次数据就把它和前面已经排序的子序列进行比较，再将它插入到前面的正确位置。算法里的Comp类要自己写，实现关键码比较大小，如int就直接比较大小，其他类别比较大小等等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inssort</span><span class="params">(E A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i; (j&gt;<span class="number">0</span>)&amp;&amp;(Comp::prior(A[j],A[j<span class="number">-1</span>])); j--)</span><br><span class="line">swap(A, j, j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(array)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(array)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> array[j] &lt; array[j<span class="number">-1</span>]:</span><br><span class="line">array[j],array[j<span class="number">-1</span>] = array[j<span class="number">-1</span>],array[j] <span class="comment"># change the elem</span></span><br></pre></td></tr></table></figure><p>这里最差的情况是每条记录都必须移动到最前面（如 array = [3,2,1,0])，空间复杂度由于并没有用其他临时数组，所以还是 $O(1)$，此时时间复杂度：</p><script type="math/tex; mode=display">\sum_{i=2}^n i \approx n^2/2 = \Theta(n^2)</script><p>最佳情况就是每条记录都已经是有序的了，进入内部for循环就退出，于是此时的时间代价是 $\Theta(n)$</p><p>平均情况根据逆置来判断，逆置的数值（即数组中位于一个给定值之前的比它大的值的数目）决定比较与交换的次数。平均情况下，在数组的前i-1条记录中有一半关键码值比第i条记录的关键码值大。平均情况下，时间代价是最差情况的一半 $\Theta(n^2/4)$， 是稳定排序。</p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>例子：气泡冒上来的过程。从最后开始，比较相邻的，如果前面的比它大则交换。就像气泡逐渐被推到数组的顶部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubsort</span><span class="params">(E A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;i; j--)</span><br><span class="line">      <span class="keyword">if</span>(Comp::prior(A[j],A[j<span class="number">-1</span>]))</span><br><span class="line">        swap(A,j,j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(array)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(array)<span class="number">-1</span>):</span><br><span class="line">flag = <span class="number">0</span>  <span class="comment"># trace the exchange times</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)<span class="number">-1</span>,i,<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> array[j] &lt; array[j<span class="number">-1</span>]:</span><br><span class="line">array[j], array[j - <span class="number">1</span>] = array[j - <span class="number">1</span>], array[j]</span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>):</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>内层的for循环比较次数总会是 i，因此最差时间代价是：$\sum_{i=1}^n i \approx n^2/2 = \Theta(n^2)$ ，平均也是类似插入排序$\Theta(n^2)$，它是稳定的排序。</p><p>修改冒泡排序以跟踪其执行的交换次数。 如果数组已经按排序顺序排列，并且冒泡排序不进行交换，则算法可以在经过一遍后终止。在最佳情况下复杂度是 $\Theta(n)$ 。</p><p>冒泡排序相对于大多数其他算法（甚至是快速排序，但不是插入排序）具有的唯一显着优势是，该算法内置了检测列表是否被有效排序的功能。</p><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>选择排序就是选择数组中第i小的记录，并把该记录放到数组的第i个位置上，只需一次交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selsort</span><span class="params">(E A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> lowindex = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;i ; j--)</span><br><span class="line">      <span class="keyword">if</span>(Comp::prior(A[j], A[lowindex]))</span><br><span class="line">        lowindex = j;</span><br><span class="line">    swap(A,i,lowindex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(array)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(array)<span class="number">-1</span>):</span><br><span class="line">lowindex = i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> array[j] &lt; array[lowindex]:</span><br><span class="line">lowindex = j</span><br><span class="line">array[i], array[lowindex] = array[lowindex], array[i]</span><br></pre></td></tr></table></figure><p>比较的次数是 $\Theta(n^2)$ ，但交换的次数比冒泡排序少很多，对于那些做交换花费时间多的问题是更好的。</p><h3 id="改进的排序"><a href="#改进的排序" class="headerlink" title="改进的排序"></a>改进的排序</h3><h4 id="shellsort"><a href="#shellsort" class="headerlink" title="shellsort"></a>shellsort</h4><p>它在不相邻的记录之间进行比较与交换。shell排序利用了插入排序的最佳时间代价特性。他将序列分成多个子序列，然后分别对子序列进行排序，最后将子序列组合起来。由于实现了元素的跳跃式移动，使排序效率提高。如下图：图中的增量序列就是8，4，2，1。最后一轮将是一次“正常的”插入排序，因为此时序列整体基本上有序，故用插入排序的复杂度相对较小。</p><p>shellsort增量选择3的时候，效果较好，平均运行时间复杂度是$\Theta(n^{1.5})$ 。 </p><p>相同的元素可能在各自的插入排序中移动， 是不稳定排序。在中等大小规模的数据上表现良好。</p><p><img src="/images/20200310shellsort.jpg" alt="20200310shellsort"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shellsort</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insort</span><span class="params">(E A[],<span class="keyword">int</span> n, <span class="keyword">int</span> increment)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=increment; i&lt;n; i+=increment) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; (j&gt;=increment)&amp;&amp;(A[j]&lt;A[j-increment]); j-=increment) &#123;</span><br><span class="line">            E temp = A[j];</span><br><span class="line">            A[j] = A[j-increment];</span><br><span class="line">            A[j-increment] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(E A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n/<span class="number">2</span>; i&gt;<span class="number">2</span>; i/=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            insort&lt;E&gt;(&amp;A[j], n-j, i);<span class="comment">//A[j] is the start address  偏移，巧妙</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insort&lt;E&gt;(A, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">16</span>] = &#123;<span class="number">59</span>,<span class="number">20</span>,<span class="number">17</span>,<span class="number">13</span>,<span class="number">28</span>,<span class="number">14</span>,<span class="number">23</span>,<span class="number">83</span>,<span class="number">36</span>,<span class="number">98</span>,<span class="number">11</span>,<span class="number">70</span>,<span class="number">65</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    shellsort&lt;<span class="keyword">int</span>&gt;(num, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n:num) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(array):</span><br><span class="line">n = len(<span class="built_in">array</span>)</span><br><span class="line">gap = n <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> i in range(gap,n):</span><br><span class="line">temp = <span class="built_in">array</span>[i]</span><br><span class="line">j = i</span><br><span class="line"><span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> <span class="built_in">array</span>[j-gap] &gt; temp:</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j-gap]</span><br><span class="line">j-=gap</span><br><span class="line"><span class="built_in">array</span>[j] = temp</span><br><span class="line">gap <span class="comment">//= 2</span></span><br></pre></td></tr></table></figure><h4 id="mergesort"><a href="#mergesort" class="headerlink" title="mergesort"></a>mergesort</h4><p>来源于分治的思想，在排序问题上分治的思想体现在把待排序的列表分成片段，先处理片段，然后将片段重组。</p><p>伪代码的提现其思想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List mergesort(List inlist)&#123;</span><br><span class="line">if(inlist.length() &lt;= 1) return inlist;</span><br><span class="line">List L1 = half of the list;</span><br><span class="line">List L2 = other half of the list;</span><br><span class="line">return mergesort(mergesort(L1),mergesort(L2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/20200310Merge-Sort.png" alt="20200310Merge-Sort"></p><p>当输入的待排序数据存储在链表中时，归并排序是一个很好的选择。</p><p>两个指针，最初分别为两个已经排序序列的起始位置。比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。重复直到某一指针达到序列尾，剩下的元素直接放入到合并的片段里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(E A[],E temp[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    mergesort&lt;E&gt;(A, temp, left, mid);</span><br><span class="line">    mergesort&lt;E&gt;(A, temp, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">//then merge, temp[] is the auxiliary array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=left; i&lt;=right; i++) &#123;</span><br><span class="line">        temp[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i1 = left;</span><br><span class="line">    <span class="keyword">int</span> i2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> curr=left; curr&lt;=right; curr++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i1 == mid+<span class="number">1</span>) A[curr] = temp[i2++]; <span class="comment">//left all &lt; right</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i2 &gt; right) A[curr] = temp[i1++]; <span class="comment">//right all &lt; left</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp[i1] &lt; temp[i2]) A[curr] = temp[i1++];<span class="comment">// smaller one is put into A</span></span><br><span class="line">        <span class="keyword">else</span> A[curr] = temp[i2++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">16</span>] = &#123;<span class="number">59</span>,<span class="number">20</span>,<span class="number">17</span>,<span class="number">13</span>,<span class="number">28</span>,<span class="number">14</span>,<span class="number">23</span>,<span class="number">83</span>,<span class="number">36</span>,<span class="number">98</span>,<span class="number">11</span>,<span class="number">70</span>,<span class="number">65</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    mergesort&lt;<span class="keyword">int</span>&gt;(num, temp, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n:num) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当被排序元素的数目是n时，递归的深度是$logn$ ，第一层递归是对长度为n的数组排序，下一层是对2个长度为n/2的子数组排序……，在所有$logn$ 层递归中，每一层都需要$\Theta(n)$ 时间代价，因此总时间代价都是$n log(n)$。由于需要temp数组做临时存储，空间复杂度是$\Theta(n)$.</p><p>python版本代码可以参考<a href="https://www.geeksforgeeks.org/python-program-for-merge-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/python-program-for-merge-sort/</a></p><h4 id="quicksort"><a href="#quicksort" class="headerlink" title="quicksort"></a>quicksort</h4><p>快速排序不需要额外的空间，典型应用是Unix系统调用库里的qsort函数。快速排序选定一个轴值，数组在小于轴值的放在左边，大于的放在右边。这被称为数组的一个划分 partition。快速排序最差情况是当轴值每次都不能把数组划分得很好，下一次处理子问题规模只比原来的问题规模减少1，时间代价是$\Theta(n^2)$ ，最佳和平均复杂度是$\Theta(n logn)$ 。2，由于递归调用，空间复杂度是$\Theta(logn)$</p><p>快排为什么这么快？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>&amp; pivot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(A[++l] &gt; pivot); <span class="comment">//move the index</span></span><br><span class="line">        <span class="keyword">while</span>((l&lt;r) &amp;&amp; (A[--r] &lt; pivot));</span><br><span class="line">        swap(A,l,r);</span><br><span class="line">    &#125;<span class="keyword">while</span>(l&lt;r);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myqsort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = (i+j)/<span class="number">2</span>; <span class="comment">//这里可以写一个findpivot函数，三者取中（三个随机值的中间）</span></span><br><span class="line">    swap(A,pivotIndex,j);</span><br><span class="line">    <span class="keyword">int</span> k = partition(A,i<span class="number">-1</span>,j,A[j]); <span class="comment">//k is the start of the left half</span></span><br><span class="line">    swap(A,k,j);<span class="comment">// 轴值就在k位置，就是最终排序好的数组中的位置</span></span><br><span class="line">    myqsort(A,i,k<span class="number">-1</span>);</span><br><span class="line">    myqsort(A,k+<span class="number">1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的改进可以从pivotIndex的设置，以及递归到一个较小的数组的时候采用插入排序（基本有序的小数组很适合）等。</p><p>Python版本：更清晰一点，把轴值设置为左边第一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(array, left, right)</span>:</span></span><br><span class="line"><span class="keyword">if</span> left &gt;= right:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">low = left</span><br><span class="line">high = right</span><br><span class="line">key = array[low]</span><br><span class="line"><span class="keyword">while</span> left &lt; right:</span><br><span class="line"><span class="keyword">while</span> left &lt; right <span class="keyword">and</span> array[right] &gt; key:</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line">array[left] = array[right]</span><br><span class="line"><span class="keyword">while</span> left &lt; right <span class="keyword">and</span> array[left] &lt;= key:</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">array[right] = array[left]</span><br><span class="line">array[right] = key</span><br><span class="line"></span><br><span class="line">quick_sort(array, low, left - <span class="number">1</span>)</span><br><span class="line">quick_sort(array, left + <span class="number">1</span>, high)</span><br></pre></td></tr></table></figure><h4 id="heapsort"><a href="#heapsort" class="headerlink" title="heapsort"></a>heapsort</h4><p>堆是一棵完全二叉树，可以用数组来实现。参考 <a href="[https://saruagithub.github.io/2020/03/28/20200328%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86/](https://saruagithub.github.io/2020/03/28/20200328数组实现堆/">数组实现堆</a>)</p><p>堆可以用来排序，适合于那些数据集太大而不适合在内存中排序的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(E A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">E maxval;</span><br><span class="line">heap&lt;E&gt; Heap(A,n,n); <span class="comment">//build the heap</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n ; i++)</span><br><span class="line">    maxval = Heap.removefirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建堆需要$\Theta(n)$，且n次取堆的最大元素要用$\Theta(logn)$ 时间，因此时间代价是$nlogn$。但堆排序一般情况下比快排在常熟因子上慢。</p><p>为什么堆排比快排慢？堆排序将最大值取走后要调整结构，用堆底元素替换堆顶元素，然后那最后一个元素从顶上往下滑到恰当的位置（重新使堆最大化）。其实这里堆底的元素肯定很小，将它拿到堆顶和原本属于最大元素的两个子节点比较，比他们都大的可能性是很小的。这一次比较的结果就是概率不均等的，这次比较就很有可能是无效的，堆顶元素很有可能继续下移比较。</p><p>Python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To heapify subtree rooted at index i , n is size of heap</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(array,n,i)</span>:</span></span><br><span class="line">largest = i <span class="comment"># init largest as root</span></span><br><span class="line">l = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">r = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># See if left child of root exists and is greater than root</span></span><br><span class="line"><span class="keyword">if</span> l &lt; n <span class="keyword">and</span> array[i] &lt; array[l]:</span><br><span class="line">largest = l</span><br><span class="line"><span class="comment"># See if right child of root exists and is greater than root</span></span><br><span class="line"><span class="keyword">if</span> r &lt; n <span class="keyword">and</span> array[largest] &lt; array[r]:</span><br><span class="line">largest = r</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change root, if needed</span></span><br><span class="line"><span class="keyword">if</span> largest != i:</span><br><span class="line">array[i], array[largest] = array[largest], array[i]  <span class="comment"># swap</span></span><br><span class="line"><span class="comment"># Heapify the root</span></span><br><span class="line">heapify(array, n, largest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The main function to sort an array of given size</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">n = len(arr)</span><br><span class="line"><span class="comment"># Build a maxheap.</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">heapify(arr, n, i)</span><br><span class="line"><span class="comment"># One by one extract elements</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment"># swap</span></span><br><span class="line">heapify(arr, i, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="计数排序-分配排序Binsort"><a href="#计数排序-分配排序Binsort" class="headerlink" title="计数排序 / 分配排序Binsort"></a>计数排序 / 分配排序Binsort</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">B[A[i]] = A[i];</span><br></pre></td></tr></table></figure><p>这里的关键码用来确定一个记录在排序中的最后的位置，关键码将记录放到盒子里，是分配排序的一个基本例子。比如数组[0,3,4,2,1] 经过一遍之后，B array 就直接把值放到了该放的地方了。</p><p>但这里它只能用于对一个从0到n-1的序列进行排序，而且还有重复的问题待处理。如果数组B变成一个链表数组，将所有的关键码i的值放到B[i] 盒子里，这就解决了重复的问题。另一个扩展是允许关键码大于n。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxKeyValue = <span class="number">100</span>; <span class="comment">// 0&lt;=A[i]&lt;=50</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Binsort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// n is the A.length</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; B[MaxKeyValue];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        B[A[i]].push_back(A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MaxKeyValue; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i].<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it=B[i].<span class="built_in">begin</span>(); it!=B[i].<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">','</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num[<span class="number">16</span>] = &#123;<span class="number">59</span>,<span class="number">20</span>,<span class="number">17</span>,<span class="number">13</span>,<span class="number">28</span>,<span class="number">14</span>,<span class="number">23</span>,<span class="number">83</span>,<span class="number">36</span>,<span class="number">98</span>,<span class="number">11</span>,<span class="number">70</span>,<span class="number">65</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">15</span>&#125;;</span><br><span class="line">  Binsort(num,<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也可以优化一些，计数排序：B[A[i]] 存储 A[i] 值出现的次数。这样最好遍历一遍B，再根据次数，输出下标值，即排序后的A[i]。但以上设计的缺陷是MaxKeyValue太大了，如果是$n^2$ ， 那么时间代价就是 $\Theta(n^2)$ ，而且所用空间也更大了。</p><h4 id="桶排序-基数排序"><a href="#桶排序-基数排序" class="headerlink" title="桶排序/基数排序"></a>桶排序/基数排序</h4><p>进一步改进前面的Binsort为桶式排序Bucketsort，每一个盒子并非与一个关键码值联系，而是与一组关键码有关。记录放到“桶”中后，再借用其他排序对桶里的记录排序。</p><p>eg：有10个盒子，首先可以把记录的关键码对10取模的结果赋值到盒子里，这样每个关键码都以其个位为标准放到10个不同的盒子里。然后按顺序再收集这些记录，按照最高位（十位）对他们进行排序。如图：</p><p><img src="/images/20200310BucketSort.jpg" alt="20200310BucketSort"></p><p>对于n长的序列，假设基数是r，这个算法需要k轮，每一轮分配的时间是$\Theta(n+r)$ ，总时间代价是$\Theta(nk + rk)$， k是与关键码的长度有关。因此平均时间复杂度是$\theta(n)$，空间复杂度是用于计数的cnt数组和Bin辅助数组带来的 $\Theta(n + k)$ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每一轮分配结束时，记录都被复制回原数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span>* Bin,<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> r,<span class="keyword">int</span> cnt[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//n is the size of A</span></span><br><span class="line">    <span class="comment">//k is the digit of A[max], r is Cardinality 10 (make r from 1 to 10 to 100)</span></span><br><span class="line">    <span class="comment">//cnt[i] stores occurrences of records in bin[i]</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,rtoi=<span class="number">1</span>; i&lt;k; i++,rtoi*=r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;r; j++) cnt[j] = <span class="number">0</span>; <span class="comment">//init cnt,roti save the r^i</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//count the number of records for each bin on this pass</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) cnt[(A[j] / rtoi) % r]++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//index of B: cnt[j] will be index for last slot of bin j</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;r; j++) cnt[j] = cnt[j<span class="number">-1</span>] + cnt[j];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//put records into bins, work from bottom of each bin</span></span><br><span class="line">        <span class="comment">//since bins fill from bottom, j counts downwards</span></span><br><span class="line">        <span class="keyword">for</span> (j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            Bin[--cnt[ (A[j] / rtoi) % r] ] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//copy B back to A</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            A[j] = Bin[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//n is the size of A,k is the digit of A[max], r is Cardinality 10 (make r from 1 to 10 to 100)</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">12</span>] = &#123;<span class="number">27</span>,<span class="number">91</span>,<span class="number">1</span>,<span class="number">97</span>,<span class="number">17</span>,<span class="number">23</span>,<span class="number">84</span>,<span class="number">28</span>,<span class="number">72</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> B[<span class="number">12</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    radix(A,B,n,k,r,cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此记录一个degub情况：上面有个情况是cnt的计数数组，判断A数组里的数应该放到哪个合适的位置出了个bug，cnt被A[j] = 72的时候篡改了。这里编程规范得注意，好好初始化，因为没指定数组长度，程序执行过程中很有可能地址错乱！！！</p><h3 id="其他内嵌算法"><a href="#其他内嵌算法" class="headerlink" title="其他内嵌算法"></a>其他内嵌算法</h3><h4 id="timsort"><a href="#timsort" class="headerlink" title="timsort"></a>timsort</h4><p>这是Python的内嵌排序算法。</p><p><img src="/Users/wangxue/gitpro/20191105MyBlog/saruagithub/source/images/20200310Allsort.jpg" alt="20200310Allsort"></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，《数据结构与算法分析》 Clifford A. Shaffer 等</p><p>2，<a href="[https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F](https://baike.baidu.com/item/希尔排序">百度百科</a>)</p><p>3， <a href="https://www.jiqizhixin.com/articles/2018-11-20-3" target="_blank" rel="noopener">机器之心 Timsort</a></p><p>4，<a href="https://www.geeksforgeeks.org/python-program-for-merge-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/python-program-for-merge-sort/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h3&gt;&lt;p&gt;排序算法在搜索中常用，因此非常重要。排序算法里包含了重要的分治的思想，就是在划分子问题上。归并排序将数据折半划分，快速排序将数据分成大数和小数部分，基数排序则每次都会按照关键码中的一个数字划分数据。&lt;/p&gt;&lt;p&gt;什么是稳定的排序：如果一种排序算法不会改变关键码值相同的记录的相对顺序，则称为稳定的。&lt;/p&gt;&lt;h4 id=&quot;三种基本的排序算法&quot;&gt;&lt;a href=&quot;#三种基本的排序算法&quot; class=&quot;headerlink&quot; title=&quot;三种基本的排序算法&quot;&gt;&lt;/a&gt;三种基本的排序算法&lt;/h4&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>DFS与BFS算法</title>
    <link href="http://yoursite.com/2020/02/28/20200228DFS%E4%B8%8EBFS%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/28/20200228DFS%E4%B8%8EBFS%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-28T08:15:28.000Z</published>
    <updated>2020-03-18T14:19:31.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>深度优先搜索从某个状态开始，不断的转移状态直到无法转移，然后回退到前一步的状态。执行的过程其实是跟栈有关，因为暂时没有执行的部分会被存放到堆栈里。直白点就是一条道走到黑，然后再逐步掉头，继续走到头。</p><p>一般要注意算法停止条件。迭代过程分析。</p><h3 id="2-DFS类题目"><a href="#2-DFS类题目" class="headerlink" title="2 DFS类题目"></a>2 DFS类题目</h3><h4 id="部分和问题"><a href="#部分和问题" class="headerlink" title="部分和问题"></a>部分和问题</h4><p>给定整数$a_{1}, a_{2}, \cdots, a_{n}$ ，判断能否可以从中选出若干数，使他们的和恰好为$k$</p><a id="more"></a><p>例如：输入 n = 4, a = {1,2,4,7} , k=13</p><p>Yes (13 = 2 + 4 + 7)</p><p>分析：首先要考虑所有数字的组合情况，判断组合的加和是否等于k，典型的搜索过程，用DFS。转移过程就是先一直往左到底，然后在倒回去一步走 dfs(i+1, sum+a[i])  加上a[i] 。</p><p>如下图，整个DFS的展开如黑色，红色是执行过程：</p><p><img src="/images/20200228Dfs1.jpg" alt="20200228_dfs1"></p><p>深度优先搜索就是从最开始的状态出发，遍历所有可以达到的状态。由此可以对所有的状态进行操作或者列举出所有的状态。DFS在设计的时候要考虑停止条件（i==n），搜索的结果变量 sum等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[max_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == n)</span><br><span class="line">        <span class="keyword">return</span> sum==k; <span class="comment">// all nums have been used</span></span><br><span class="line">    <span class="keyword">if</span>(dfs(i+<span class="number">1</span>, sum))  <span class="comment">//not add a[i]</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(dfs(i+<span class="number">1</span>, sum+a[i])) <span class="comment">// add a[i]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"input n:"</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dfs(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Yes!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="延伸-leecode39题"><a href="#延伸-leecode39题" class="headerlink" title="延伸 leecode39题"></a>延伸 leecode39题</h5><p>给定一个无重复元素的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的数字可以无限制重复被选取。（这里与上一题的不同在于数字可以重复选取，并且要存所有组合的结果）</p><p>分析：组合、搜索问题首先需要画出树形图，代码根据树形图写出来。</p><p>如输入: <code>candidates = [2, 3, 6, 7]</code>，<code>target = 7</code>，所求解集为: <code>[[7], [2, 2, 3]]</code>。</p><p>我自己的思路：首先k控制DFS的深度，sum判断每次加和结果，last存上一个candidate的值，从而在每次下一层的时候避免重复选择之前选过的小的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意last控制去重</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_addSum1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> k, <span class="keyword">int</span> sum, <span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        res.push_back(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &lt; last) <span class="keyword">break</span>;</span><br><span class="line">        v.push_back(candidates[i]);</span><br><span class="line">        dfs_addSum1(candidates,res,target,v,k+<span class="number">1</span>,sum+candidates[i],candidates[i]);</span><br><span class="line">        v.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum1(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    dfs_addSum1(candidates,res,target,v, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span> ); <span class="comment">// 0 means level, 0 is temp_sum, 0 is the last val</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种答案的思路是根据remain 从最开始的target减去candidate里的剩余数字。last变量这里很巧，这样每次就从比之前的数字更大的数字去选择。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_addSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v,<span class="keyword">int</span> remain, <span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    res.push_back(v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(remain &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = last; i &lt; candidates.<span class="built_in">size</span>(); i++)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    v.push_back(candidates[i]);</span><br><span class="line">    dfs_addSum(candidates,res,v, remain - candidates[i], i);</span><br><span class="line">    v.pop_back();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">  dfs_addSum(candidates,res,v,target, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h4><p>leecode17题：给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>对应关系如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; table&#123;</span><br><span class="line">    &#123;<span class="string">'0'</span>, <span class="string">" "</span>&#125;, &#123;<span class="string">'1'</span>,<span class="string">"*"</span>&#125;, &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;, &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;,&#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>如，给定输入”23”，输出是[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p><p>分析：根据数字，组合数字的字母，也是一个全部搜索的过程。停止条件是当字符串不断拼接直到长度与输入的数字个数一致。 变量有res （即最后输出），str变量用来存拼接字符，k控制深度。（另外两个参数digits与hash其实是相当于默认参数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res,<span class="built_in">string</span> str,<span class="built_in">string</span>&amp; digits,<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;&amp;hash, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// stop condition, str 不断拼接，直到与给的数字长度相同</span></span><br><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">size</span>() == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">        res.push_back(str);<span class="comment">//添加到结果里</span></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//递归深入完毕，退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> temp = hash[digits[k]];<span class="comment">//k代表每层</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> w:temp)&#123;</span><br><span class="line">        str += w; <span class="comment">// 添加一个字符</span></span><br><span class="line">        dfs(res, str, digits, hash, k+<span class="number">1</span>); <span class="comment">//继续向下搜索</span></span><br><span class="line">        str.pop_back();<span class="comment">//去掉末尾字符向上走（回溯）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits)&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; table&#123;</span><br><span class="line">    &#123;<span class="string">'0'</span>, <span class="string">" "</span>&#125;, &#123;<span class="string">'1'</span>,<span class="string">"*"</span>&#125;, &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'3'</span>,<span class="string">"def"</span>&#125;, &#123;<span class="string">'4'</span>,<span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>,<span class="string">"jkl"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'6'</span>,<span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>,<span class="string">"pqrs"</span>&#125;,&#123;<span class="string">'8'</span>,<span class="string">"tuv"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'9'</span>,<span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="string">""</span>) <span class="keyword">return</span> result;</span><br><span class="line">    dfs(result,<span class="string">""</span>,digits,table,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h4><p>leecode 22：给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。如n=3时，输出：[  “((()))”,  “(()())”,  “(())()”,  “()(())”,  “()()()”]</p><p>分析：全部组合的过程中，注意简单的条件剪枝。停止条件左括号个数 = n且右括号个数 = n。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剪枝的条件为：左括号的数目一旦小于右括号的数目，以及，左括号的数目和右括号数目均小于n。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> str,<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; n || r &gt; n || r &gt; l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == n &amp;&amp; r==n) &#123; <span class="comment">//stop condition</span></span><br><span class="line">        res.push_back(str);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(res, str + <span class="string">'('</span>, l+<span class="number">1</span>, r, n);</span><br><span class="line">    dfs(res, str + <span class="string">')'</span>, l, r+<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    dfs(res, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// thanks a lot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组的所有子集"><a href="#数组的所有子集" class="headerlink" title="数组的所有子集"></a>数组的所有子集</h4><p>leecode 78给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res_temp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == nums.<span class="built_in">size</span>())  &#123;</span><br><span class="line">        res.push_back(res_temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不选</span></span><br><span class="line">    dfs_subsets(nums,res_temp,res,k+<span class="number">1</span>);</span><br><span class="line">    res_temp.push_back(nums[k]); <span class="comment">//选nums[k]</span></span><br><span class="line">    dfs_subsets(nums,res_temp,res,k+<span class="number">1</span>);</span><br><span class="line">    res_temp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res_temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    dfs_subsets(nums,res_temp,res,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图遍历的DFS"><a href="#图遍历的DFS" class="headerlink" title="图遍历的DFS"></a>图遍历的DFS</h3><p> 在图的遍历过程中，常用两种遍历算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graphTraverse</span><span class="params">(Graph* G)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G-&gt;n();v++) G-&gt;setMark(v, UNVISITED); <span class="comment">// n - nodes num</span></span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G-&gt;n();v++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G-&gt;getMark(v) == UNVISITED)</span><br><span class="line">doTraverse(G,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在搜索过程中，每当访问某个顶点V时，DFS会递归的访问它的所有未被访问的相邻节点。DFS将所有从顶点V出去的边存入栈中，从栈顶弹出一条边，根据这个边找到顶点V的一个相邻节点，这个顶点就是下一个要访问的顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph* G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">PreVisit(G,v); <span class="comment">//take appropriate action</span></span><br><span class="line">G-&gt;setMark(v, VISITED);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> w = G-&gt;first(v); w&lt;G-&gt;n(); w=G-&gt;next(v,w))</span><br><span class="line"><span class="keyword">if</span>(G-&gt;getMark(w) == UNVISITED)</span><br><span class="line">DFS(G,w); <span class="comment">// go deep to traverse</span></span><br><span class="line">PostVisit(G,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图遍历的BFS"><a href="#图遍历的BFS" class="headerlink" title="图遍历的BFS"></a>图遍历的BFS</h3><p>BFS  在进一步深入访问其他顶点之前，检查起点的所有相邻节点。用队列代替递归栈，BFS将逐层对各个节点进行访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph* G, <span class="keyword">int</span> start, Queue&lt;<span class="keyword">int</span>&gt;* Q)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v,w;</span><br><span class="line">Q-&gt;enqueue(start); <span class="comment">// initial node</span></span><br><span class="line">G-&gt;setMark(start,VISITED);</span><br><span class="line"><span class="keyword">while</span>(Q-&gt;length() != <span class="number">0</span>)&#123; <span class="comment">//process all vertices</span></span><br><span class="line">    v = Q-&gt;dequeue();</span><br><span class="line">    PreVisit(G,v);</span><br><span class="line">    <span class="keyword">for</span>(w=G-&gt;first(v); w&lt;G-&gt;n(); w = G-&gt;next(v,w))&#123;</span><br><span class="line">      <span class="keyword">if</span>(G-&gt;getMark(w) == UNVISITED)&#123;</span><br><span class="line">        G-&gt;getMark(w) == VISITED;</span><br><span class="line">        Q-&gt;enqueue(w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，leecode100经典 17,22题。</p><p>2，《挑战程序设计》</p><p>3,  《数据结构与算法分析 》 Clifford A. Shaffer</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h3&gt;&lt;p&gt;深度优先搜索从某个状态开始，不断的转移状态直到无法转移，然后回退到前一步的状态。执行的过程其实是跟栈有关，因为暂时没有执行的部分会被存放到堆栈里。直白点就是一条道走到黑，然后再逐步掉头，继续走到头。&lt;/p&gt;&lt;p&gt;一般要注意算法停止条件。迭代过程分析。&lt;/p&gt;&lt;h3 id=&quot;2-DFS类题目&quot;&gt;&lt;a href=&quot;#2-DFS类题目&quot; class=&quot;headerlink&quot; title=&quot;2 DFS类题目&quot;&gt;&lt;/a&gt;2 DFS类题目&lt;/h3&gt;&lt;h4 id=&quot;部分和问题&quot;&gt;&lt;a href=&quot;#部分和问题&quot; class=&quot;headerlink&quot; title=&quot;部分和问题&quot;&gt;&lt;/a&gt;部分和问题&lt;/h4&gt;&lt;p&gt;给定整数$a_{1}, a_{2}, \cdots, a_{n}$ ，判断能否可以从中选出若干数，使他们的和恰好为$k$&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS与BFS" scheme="http://yoursite.com/tags/DFS%E4%B8%8EBFS/"/>
    
  </entry>
  
  <entry>
    <title>字节算法岗面试记录</title>
    <link href="http://yoursite.com/2020/02/10/20200210%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E5%B2%97%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/02/10/20200210%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E5%B2%97%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2020-02-10T09:40:59.000Z</published>
    <updated>2020-03-19T01:09:42.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>面试官真的是很直接了，就出了道算法题。但整体来说这个面试官真的是超级好了啊，特别会引导，我觉得字节就是这点细节很好。</p><p>最大连续序列和。</p><p>如给一个Array： 1，-2，3，1，-1，5 。则是8 (3, 1, -1 , 5)</p><p>分析：设DP[k] 是表示以k结尾的最大的和。则递推公式为 DP[k] = max{DP[k-1] + A[k] ，A[k] }，要么是前一个连续和加上数组值（当前数组值为正），要么就是数组本身。这样最后只需要一遍遍历过去，找出以某个k结尾的最大和的那个DP值即为答案。</p><a id="more"></a><p>代入看：初始化DP[0] = 0 , DP[1] = max{1, 0} = 1 , DP[2] = max{-1, -2} = -1; ….</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSequenceSum</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> dp[length];</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+matrix[i], matrix[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// get the max</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i] &gt; res) res = dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的时间复杂度是O (n)，空间复杂度也是O(n)，面试官引导进行优化空间。</p><p>思路就是用变量存上一个dp[i-1] 与最大的 dp值，直接返回即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSequenceSum</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> dp[length];</span><br><span class="line">  <span class="keyword">int</span> dp_max = matrix[<span class="number">0</span>]; <span class="comment">// store the max</span></span><br><span class="line">  <span class="keyword">int</span> dp_last = matrix[<span class="number">0</span>]; <span class="comment">// store the dp[i-1]</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">    dp_last = <span class="built_in">max</span>(dp_last + matrx[i], matrix[i]);</span><br><span class="line">    <span class="keyword">if</span>(dp_last &gt; dp_max) dp_max = dp_last;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真的是有意思，我也没有刷完所有题，感觉自己思路还是有些慢，得再练哦。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的技术leader有点像个稍严厉的大父亲，而且涉及很广居然包括博弈论，我虽然是学了很多博弈论的数学模型（还记得当时的考试，复习得可费劲了，得理解所有的啥完美，完全博弈啥概念，还得计算的）。在此记录一些问题吧。</p><h4 id="1，优化问题"><a href="#1，优化问题" class="headerlink" title="1，优化问题"></a>1，优化问题</h4><p>出了个问题是在给定的CTR和CVR之下，让用户尽量久的停留（停留时间长）。考虑最优化，写优化和约束和拉格朗日法。</p><p>max: t</p><p>s.t. CTR+r CVR &gt; n</p><p>CTR和CVR的计算应该也是跟用户停留时间t有关的（现象上来看，用户停留时间越长，点击率和转化率可能越高），用最优化里的有约束的凸二次规划来看的话。</p><p>构建拉格朗日函数，对不等式约束引入拉格朗日乘子, $\alpha_i \geq 0$。</p><script type="math/tex; mode=display">L(t) = t - \alpha_i (CTR+r CVR - n)</script><p>当然这里根据CTR和CVR的计算公式展开。根据拉格朗日对偶像，原始问题的对偶问题是极小极大问题。对所有实数域上的优化问题都有其对偶问题。</p><script type="math/tex; mode=display">min_{\alpha_i} max_t  L(t)</script><p>这里应该是对偶可以求一个 upper bound的。我一开始莽撞写错了不等式约束，然后后面联想SVM才改。在复习一下（图中f ,g 不要求是凸的）：</p><p><img src="/images/20200211Dual.jpg" alt="20200211Dual"></p><h4 id="2，广告拍卖模型"><a href="#2，广告拍卖模型" class="headerlink" title="2，广告拍卖模型"></a>2，广告拍卖模型</h4><p>明拍（谁出的高就收谁的）和暗拍（相互不知道对方出价），各自的影响。</p><p>为什么拍卖？揭示信息并减少代理成本。当一个物品对买者的价值比卖者更清楚时，卖者一般不愿意首先提出价格，而采用拍卖方式获得可能的最高价格。</p><p>明拍：从最低价开始举牌逐渐升高。这里面可能涉及作弊问题，拍卖客户之间串通，以低价甚至是起拍底价成交的人，其他竞买人都不举牌与之竞争，再私下得到一些好处。</p><p>暗拍，是以出价最高的投标者获得拍卖品。并支付出价给卖者。（有一级密封拍卖，出价最高；二级密封拍卖，报价中的次高价）</p><h5 id="2-1-一级拍卖"><a href="#2-1-一级拍卖" class="headerlink" title="2.1 一级拍卖"></a>2.1 一级拍卖</h5><p>两个投标人，假设$b_i \geq 0$ 是投标人i的出价，$v_i$ 是拍卖品对投标人i的价值，可见$v_i$只有i自己知道（自己根据估计的真实价值进行出价，这个函数只与自己相关）。$v_i$ 独立地取自定义在区间$[0,1]$ 上的均匀分布函数。投标人i的效用（可以理解为我的收益）是：</p><script type="math/tex; mode=display">u_{i}\left(b_{i}, b_{j} ; v_{i}\right)=\left\{\begin{array}{cl}{v_{i}-b_{i},} & {\text { 如果 } b_{i}>b_{j}} \\ {\frac{1}{2}\left(v_{i}-b_{i}\right),} & {\text { 如果 } b_{i}=b_{j}} \\ {0,} & {\text { 如果 } b_{i}<b_{j}}\end{array}\right.</script><p>假设投标人i的出价 $b_i(v_i)$ 是其价值 $v_i$ 的严格递增可微函数，肯定不会$b_i ＞1 &gt; v_i$ 因为没人付比物品价值更高的出价。考虑对称的情况下出价策略 $b = b^{\star}(v)$ ，投标人i的预期支付是：</p><script type="math/tex; mode=display">u_{i}=(v-b) \operatorname{Pr} o b\left\{b_{j}<b\right\}</script><script type="math/tex; mode=display">\operatorname{Pr} o b\left\{b_{j}<b\right\}=\operatorname{Pr} o b\left\{b^{*}\left(v_{j}\right)<b\right\} = \operatorname{Pr} o b\left\{v_{j}<b^{*-1}(b) \equiv \Phi(b)\right\}=\Phi(b)</script><p>根据均匀分布有$k \in[0,1], \quad \operatorname{Pr} o b(\theta \leq k)=k$，即这里的$\Phi(b) = b^{*-1}(b)$ </p><p>投标人面对的问题就是：</p><script type="math/tex; mode=display">\max _{b} u_{i}=(v-b) \operatorname{Pr} o b\left\{b_{j}<b\right\}=(v-b) \Phi(b)</script><p>上面这个max最优化问题的一阶条件是：$-\Phi(b)+(v-b) \Phi^{\prime}(b)=0$</p><p>如果$b^{*}(\cdot)$ 是投标者i的最优策略，$\Phi(b)=v, then, v=(v-b) \frac{\mathrm{d} v}{\mathrm{d} b}$</p><script type="math/tex; mode=display">v \mathrm{d} b+b \mathrm{d} v=v \mathrm{d} v , \frac{\mathrm{d}(v b)}{\mathrm{d} v}=v</script><p>积分$vb = \frac{1}{2}v^2$ 求得 $b^{\star}=v / 2$，即是这个博弈的贝叶斯均衡。</p><p>当有n个投标人时，每个投标人的价值$v_i$ 定义在【0，1】区间上且独立同分布。投标人i的预期支付函数是：</p><script type="math/tex; mode=display">u_{i}=(v-b) \prod_{j \neq i} \operatorname{Pr} o b\left\{b_{j}<b\right\}=(v-b) \Phi^{n-1}(b)</script><script type="math/tex; mode=display">b^{\star}(v)=\frac{n-1}{n} v</script><p><strong>投标人越多，卖者能得到的价格就越高；当投标人数趋于无穷时，卖者几乎得到拍卖品价值的全部。因此，卖者希望更多的人加入竞标 。</strong></p><h5 id="2-2-二级拍卖"><a href="#2-2-二级拍卖" class="headerlink" title="2.2 二级拍卖"></a>2.2 二级拍卖</h5><p>如果投标者想赢得投标，则他的效用是：</p><script type="math/tex; mode=display">u_{i}=v_{i}-\max _{j \neq i} b_{j}</script><script type="math/tex; mode=display">b_{i}>\max _{j \neq i} b_{j}</script><p>对每个参与人来说，自己只需要比其他人好一点点就行。即以他的估价进行投标的策略$\left(b_{i}=v_{i}\right)$ 弱优于其他策略。记$r_{i} \equiv \max _{j \neq i} b_{j}$ 即第二大出价。</p><p>$when: r_i \leq v_i $，以$v_i$投标则投标者获得效用是： $v_i - r_i$ （理解为其他所有人的出价都稍微小于自己心中对物品的估价，这样才可能获得正效用。）</p><p>当$r_i \geq b_i$ ，投标者i获得效用是0。当 <script type="math/tex">v_i < r_i < b_i</script> 则投标者i具有效用是 $v_i - r_i &lt; 0$，若此时投标$v_i$ 则效用是0。</p><p>因此<strong>在二级密封价格拍卖中，投标者会以他们的估价进行投标</strong> 。</p><p>类比到互联网的广告拍卖里，其实也有广义第一价格GFP（实收价等于出价）和广义第二价格GSP（实收价等于第二出价），还有VGG竞价机制。</p><p>广义第一价格GFP（实收价等于出价）的影响，受广告主的出价影响，可能不稳定，可能高也坑可能低。GSP更能凸显出广告的真实价格。</p><h5 id="2-3，概率生成器。"><a href="#2-3，概率生成器。" class="headerlink" title="2.3，概率生成器。"></a>2.3，概率生成器。</h5><p>给一个不均分的硬币，投的正面概率是P（不是0.5），怎么用它来得到均匀（0.5）的结果。两次正面的概率是p，两次反面概率是（1-p）^2，一正一反的概率是 2p(1-p)，这里01、10的生成概率是相同的，基于此代表0，1来生成。</p><p>2020年1月23好不容易面完了二面，技术岗说后面HR联系，然后然后就没有然后了通知说岗位不匹配，就这样记录记录吧，每次面试都是一次学习总结的机会。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，肖条军 《决策与博弈论》</p><p>2，<a href="[https://wiki.mbalib.com/wiki/%E5%B0%81%E9%97%AD%E5%BC%8F%E6%8B%8D%E5%8D%96](https://wiki.mbalib.com/wiki/封闭式拍卖">封闭式拍卖</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h3&gt;&lt;p&gt;面试官真的是很直接了，就出了道算法题。但整体来说这个面试官真的是超级好了啊，特别会引导，我觉得字节就是这点细节很好。&lt;/p&gt;&lt;p&gt;最大连续序列和。&lt;/p&gt;&lt;p&gt;如给一个Array： 1，-2，3，1，-1，5 。则是8 (3, 1, -1 , 5)&lt;/p&gt;&lt;p&gt;分析：设DP[k] 是表示以k结尾的最大的和。则递推公式为 DP[k] = max{DP[k-1] + A[k] ，A[k] }，要么是前一个连续和加上数组值（当前数组值为正），要么就是数组本身。这样最后只需要一遍遍历过去，找出以某个k结尾的最大和的那个DP值即为答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="经历" scheme="http://yoursite.com/categories/%E7%BB%8F%E5%8E%86/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>异常检测方法</title>
    <link href="http://yoursite.com/2020/02/10/20191210%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/10/20191210%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95/</id>
    <published>2020-02-10T08:24:27.000Z</published>
    <updated>2020-03-18T10:01:59.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异常检测方法综述"><a href="#异常检测方法综述" class="headerlink" title="异常检测方法综述"></a>异常检测方法综述</h3><h4 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h4><p>有基于阈值的，还有对数据的分布做出假设，并找出假设下所定义的“异常”，因此往往会使用极值分析或者假设检验，概率密度函数值小于某个阈值的点判定为异常。 还有些多元模型，如计算多个事件指标之间期望的相关性等等。</p><h5 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h5><p>频率直方图， 点分布图</p><h5 id="高斯分布的-k-sigma"><a href="#高斯分布的-k-sigma" class="headerlink" title="高斯分布的 k-sigma"></a>高斯分布的 k-sigma</h5><p>概率密度函数为 $f(x)=\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}$</p><a id="more"></a><p>当点$X \notin ( { \mu } - 3 { \sigma } ,  { \mu } + 3  { \sigma } ) $ 则为异常，因为这个点出现的概率小于 1 - 99.74%。</p><p>延伸出滑动窗高斯模型，后续s表示为异常分数score：</p><script type="math/tex; mode=display">s =1-Q\left(\frac{\left|x_-\mu \right|}{\sigma}\right)</script><p>Q函数是标准正态分布的右尾函数：$Q(x)=\int_{x}^{\infty} \frac{1}{\sqrt{2 \pi}} e^{-\frac{t^{2}}{2}} d t$，Q函数又叫（标准正态分布的）互补累计分布函数，Q ( x )是正常(高斯)随机变量获得大于x标准差的值的概率。</p><h5 id="箱型图"><a href="#箱型图" class="headerlink" title="箱型图"></a>箱型图</h5><p><img src="/images/20191211BoxPlot.jpg" alt="20191211BoxPlot"></p><p>IQR (inter quartile range) = Q3 - Q1 ； 占据中心值周围50%数量的范围</p><p>LQR (lower quartile range) = median - Q1 ； IQR的下半部分</p><p>UQR (upper quartile range) = Q3 - median ； IQR的上半部分</p><p>若按3 σ来判断异常， 3 σ = 2.1 IQR，则异常在median的2.1 IQR之外，因此在Q1或者Q3再延伸1.5 IQR (3σ 之外)的点就很可能是outlier点了。</p><p>即$P &gt; Q3+1.5IQR$ or $P&lt; Q1 - 1.5IQR$</p><h5 id="假设检验类型"><a href="#假设检验类型" class="headerlink" title="假设检验类型"></a>假设检验类型</h5><p>如extreme studentized deviate（Grubb’s Test ）</p><p>提出假设H0:没有异常点，H1：至少有一个异常点。</p><p>根据样本的均值和标准差来计算最大 bias / standard deviation 比值。</p><script type="math/tex; mode=display">G=\frac{\max _{i=1, \ldots, N}\left|X_{i}-\bar{X}\right|}{s}</script><p>基于t-student分布定检出水平$\alpha$（置信概率$P=1- \alpha$）与检测次数$n$查找表格获得临界值$G_0$。当计算的$G&gt;G_0$则判断为异常点。</p><p>其他还有卡方检验（chi-square theory），Q_test等</p><h5 id="Skyline用到的几种统计方法（单时间序列的异常检测）"><a href="#Skyline用到的几种统计方法（单时间序列的异常检测）" class="headerlink" title="Skyline用到的几种统计方法（单时间序列的异常检测）"></a>Skyline用到的几种统计方法（单时间序列的异常检测）</h5><p><strong>median absolute deviation （MAD）</strong></p><p>计算数据的中位数，偏差 = 每个值-中位数，得到偏差中位数</p><script type="math/tex; mode=display">\mathrm{MAD}=\operatorname{median}\left(\left|X_{i}-\operatorname{median}(X)\right|\right)</script><p>MAD对数据集中的异常值比标准偏差更具弹性。在标准偏差中，与均值的距离的平方，较大的异常值会影响更大。可以通过判断一个点的偏差是否过于偏离MAD来判断异常。</p><p><strong>stddev_from_average</strong></p><p>时间序列最后三个点的 $(t - series.mean) &gt; 3 * series.std$</p><p>最新的三个数据点的平均值的绝对值减去移动平均值，大于三个平均值的标准偏差。</p><p><strong>least_squares</strong></p><p>根据最小二乘模型上，将最后三个数据点的平均值投影，大于三个sigma，则时间序列是异常的。</p><p><strong>Histogram-based</strong></p><p>如果最后三个数据点的平均值落入了带有少于n个其他数据点的直方图bin中。</p><p>统计学方法是可以用在时间序列上的，取最近的一时间段来进行统计计算。</p><h4 id="基于距离distanced-based"><a href="#基于距离distanced-based" class="headerlink" title="基于距离distanced-based"></a>基于距离distanced-based</h4><h5 id="直接定义距离"><a href="#直接定义距离" class="headerlink" title="直接定义距离"></a>直接定义距离</h5><p>假设：若一个数据点和大多数数据点距离很远，则这个对象就是异常。但这个方法不太适合稀疏数据集。</p><h5 id="KNN等基于邻居"><a href="#KNN等基于邻居" class="headerlink" title="KNN等基于邻居"></a>KNN等基于邻居</h5><p>简单的定义可以是：用数据对象与最近的K个点的距离之和。很明显，与K个最近点的距离之和越小，异常分越低；与K个最近点的距离之和越大，异常分越大。</p><script type="math/tex; mode=display">N C M(o, M)=\sum_{h \in k N N(o)} d i s t(o, h)</script><h5 id="聚类clustering"><a href="#聚类clustering" class="headerlink" title="聚类clustering"></a>聚类clustering</h5><h5 id="基于密度density"><a href="#基于密度density" class="headerlink" title="基于密度density"></a>基于密度density</h5><p>LOF方法：通过局部的数据密度来检测异常。显然，异常点所在空间的数据点少，密度低。</p><p>K邻近距离，在距离数据点 p 最近的几个点中，第 k 个最近的点跟点 p 之间的距离称为点 p 的 K-邻近距离，记为 k-distance (p) 。</p><p>可达距离：可达距离的定义跟K-邻近距离是相关的，给定参数k时， 数据点 p 到 数据点 o 的可达距离 reach-dist（p, o）为数据点 o 的K-邻近距离 和 数据点p与点o之间的直接距离的最大值。</p><script type="math/tex; mode=display">reachdist_k ( p , o ) =\max \{k-\text {distance}(o), d(p, o)\}</script><p>局部可达密度：基于可达距离的，对于数据点 p，那些跟点p的距离小于等于 k-distance（p）的数据点称为它的 k-nearest-neighbor，记为$N_{k}(p)$数据点 p 的局部可达密度为它与邻近的数据点的平均可达距离的倒数：</p><script type="math/tex; mode=display">lrd_{k}(p)=\frac{1}{\frac{\sum_{o \in N_{k}(p)} reachdist_{k} ( p , o ) }{\left|N_{k}(p)\right|}}</script><p>局部异常因子：用局部相对密度来定义的。数据点 p 的局部相对密度（局部异常因子）为点p的邻居们的平均局部可达密度跟数据点p的局部可达密度的比值。</p><script type="math/tex; mode=display">L O F_{k}(p)=\frac{\sum_{o \in N_{k}(p)} \frac{l r d(o)}{l r d(p)}}{\left|N_{k}(p)\right|}=\frac{\sum_{o \in N_{k}(p)} lrd(o)}{\left|N_{k}(p)\right|} / \operatorname{lr} d(p)</script><p>如果一个数据点跟其他点比较疏远的话，那么显然它的局部可达密度就小。判断异常点就是看它跟周围邻近的数据点的相对密度。如果数据点 p 的 LOF 得分在1附近，表明数据点p的局部密度跟它的邻居们差不多；如果数据点 p 的 LOF 得分小于1，表明数据点p处在一个相对密集的区域，不像是一个异常点；如果数据点 p 的 LOF 得分远大于1，表明数据点p跟其他点比较疏远，很有可能是一个异常点。</p><h5 id="ABOD基于角度"><a href="#ABOD基于角度" class="headerlink" title="ABOD基于角度"></a>ABOD基于角度</h5><h5 id="IsolationForest"><a href="#IsolationForest" class="headerlink" title="IsolationForest"></a>IsolationForest</h5><p>划分超平面来计算“孤立”一个样本所需的超平面数量。异常点所在空间中，所需要的划分次数更少。</p><p><strong>构造itree随机二叉树</strong>：</p><p>从全量数据中抽取一批样本，然后随机选择一个特征作为起始节点（bagging），并在该特征的最大值和最小值之间随机选择一个值，将样本中小于该取值的数据划到左分支，大于等于该取值的划到右分支。异常点一般都是非常稀有的，在iTree中会很快被划分到叶子节点。</p><p>x —— 要预测的样本</p><p>T.size —— iTree 的训练样本中同样落在 x 所在叶子节点的样本数。</p><p>e —— 数据 x 从 iTree 的根节点到叶节点过程中经过的边的数目</p><p>C(T.size) —— 修正值，二叉树的平均路径长度。</p><p>h(x) —— x在 iTree 中的路径长度：</p><script type="math/tex; mode=display">h ( x ) = e + C ( T . s i z e ) , C ( n ) = 2 H ( n - 1 ) - \left( \frac { 2 ( n - 1 ) } { n } \right), H ( k ) = \ln ( k ) + \xi</script><p>ψ —— 训练一棵itree的样本数</p><p>E(h(x))—— 数据x在多棵树上的路径长度均值</p><p>x在这棵树的异常指数是：</p><script type="math/tex; mode=display">s ( x , \psi ) = 2 ^ { \left( - \frac { E( h ( x ) ) } { c ( \psi ) } \right) }%</script><p>如果h(x)越小，则s(x,ψ)越接近1；越大，则s(x,ψ)越接近0.5。</p><p><strong>构造iforest</strong>：</p><p>随机采样一部分数据集去构造每一棵树，保证不同树之间的差异性，采样数据量ψ不需要等于n，可以远远小于n。</p><p><img src="/images/20200226iForest.jpg" alt="20200226iForest"></p><p>其他树方法变形：random cut forest、iForest、SCiForest、RRCF、改进的iForestASD方法，流数据异常检测帧等等。</p><h4 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a>回归模型</h4><p>1，自回归AR</p><script type="math/tex; mode=display">X_t = c + \sum_{i=1}^P \theta_{i}X_{t-i} + \varepsilon_t</script><p>其中$c$是常数项，$\theta_i$是自相关系数，$ \varepsilon_t$是随机误差项（平均数为0，标准差为$\sigma$的随机误差值，也称白噪声）。$X_t$的当前值是前几期的线性组合。$\theta_i$的变化将使得时间序列拥有不同的特征。</p><p>对于AR(1)而言：</p><p>当$\theta_1=0$, $X_t$相当于白噪声。</p><p>当$\theta_1=1, c=0$时，$X_t$相当于随机游走模型。</p><p>当$\theta_1=1, c\neq0$时，$X_t$相当于带漂移的随机游走模型。</p><p>当$\theta_1&lt;0$, $X_t$在正负值之间上下浮动。</p><p>P阶自回归模型的要求是时序数据具有平稳性，必须有自相关性（即自相关系数大于0.5），自回归只能适用于预测与自身前期相关的经济现象。</p><p>2，移动平均模型 MA</p><script type="math/tex; mode=display">X_{t}=c+\varepsilon_{t}+\sum_{i=1}^q \theta_i\varepsilon_{t-i}</script><p>移动平均模型MA(q)更关注自回归模型中的误差项的累加。每一个值都可以被认为是一个历史预测误差的加权移动平均值。</p><p>AR(1)可以用MA($\infty$) 表示：$y_{t}=\varepsilon_{t}+\phi_{1} \varepsilon_{t-1}+\phi_{1}^{2} \varepsilon_{t-2}+\phi_{1}^{3} \varepsilon_{t-3}+\cdots$</p><p>2.1 注意移动平均法和移动模型不同</p><p>移动平均法适用于即期预测。当产品需求既不快速增长也不快速下降，且不存在季节性因素时，移动平均法能有效地消除预测中的随机波动，非常有用的。移动平均法包括简单移动平均和加权移动平均。</p><p>简单移动平均：$X_t = \frac{\sum_{i=1}^n X_{t-i}}{n}$</p><p>加权移动平均：$X_t = \sum_{i=1}^n \theta_i X_{t-i}$ , 其中$\theta_i$是权重值，对近期的趋势反映较敏感，但不适合有季节性的数据。</p><p>根据同一个移动段内不同时间的数据对预测值的影响程度，分别给予不同的权数，然后再进行平均移动以预测未来值。</p><p>指数加权移动平均EWMA，指数移动平均EMA。</p><p>3，ARIMA模型</p><script type="math/tex; mode=display">y_{t}=\mu+\sum_{i=1}^{p} \gamma_{i} y_{t-i}+\epsilon_{t}+\sum_{i=1}^{q} \theta_{i} \epsilon_{t-i}</script><p>适合有季节性的数据</p><p>4，时间序列分解</p><p>STL季节性分解</p><p>论文：Online Conditional Outlier Detection in Nonstationary Time Series</p><p>STL分解（非参数分解方法）为三个要素：季节性、趋势、残差。 分析残差的偏差，然后引入残差阈值，这样就能得到一种异常检测得算法。</p><p>移动平均、指数平滑、ARMA、ARIMA</p><h4 id="2-4-线性模型（基于子空间subspace）"><a href="#2-4-线性模型（基于子空间subspace）" class="headerlink" title="2.4 线性模型（基于子空间subspace）"></a>2.4 线性模型（基于子空间subspace）</h4><p>主成分分析PCA</p><p>因子分析Factor Analysis</p><h4 id="2-3-机器学习"><a href="#2-3-机器学习" class="headerlink" title="2.3 机器学习"></a>2.3 机器学习</h4><p>分类模型（类别不平衡问题）</p><p>决策树</p><p>支持向量SVM </p><p>延伸出来的还有OneClass SVM，Support Vector Machine (SVM) with ant colony network[4]</p><p>随机森林等</p><p>Isolation Forest方法</p><p>GBDT方法 / XgBoost / Bagging等</p><p>Bayesiannetwork </p><h4 id="2-4-神经网络"><a href="#2-4-神经网络" class="headerlink" title="2.4 神经网络"></a>2.4 神经网络</h4><p>RNN、LSTM方法</p><p>论文：Anomaly detection in ECG time signals via deep long short-term memory networks</p><p>AutoEncoder</p><p>深度信念网络等</p><p>SOM自组织地图</p><p>HTM方法</p><p>频谱残差</p><h4 id="2-5-实时序列异常检测"><a href="#2-5-实时序列异常检测" class="headerlink" title="2.5 实时序列异常检测"></a>2.5 实时序列异常检测</h4><h5 id="2-5-1-NAB库有的"><a href="#2-5-1-NAB库有的" class="headerlink" title="2.5.1 NAB库有的"></a>2.5.1 NAB库有的</h5><p>期望相似性估计</p><h5 id="2-5-2-其他"><a href="#2-5-2-其他" class="headerlink" title="2.5.2 其他"></a>2.5.2 其他</h5><p>[4]里的Support Vector Machine (SVM) with ant colony network ，pcStream algorithm（stream clustering），random cut forest, </p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, “Everything you need to know about AIOps”, from <a href="https://www.moogsoft.com/resources/aiops/guide/everything-aiops/" target="_blank" rel="noopener">https://www.moogsoft.com/resources/aiops/guide/everything-aiops/</a> (retrieved as of Feb. 12, 2019)</p><p>2，<a href="https://github.com/yzhao062/pyod#gopalan2019pidforest" target="_blank" rel="noopener">https://github.com/yzhao062/pyod#gopalan2019pidforest</a> pyod异常检测库</p><p>3，<a href="https://github.com/etsy/skyline" target="_blank" rel="noopener">https://github.com/etsy/skyline</a> Skyline，一些统计方法</p><p>4，Habeeb R A A, Nasaruddin F, Gani A, et al. Real-time big data processing for anomaly detection: A Survey[J]. International Journal of Information Management, 2019, 45: 289-307.</p><p>5，<a href="https://otexts.com/fppcn/MA.html" target="_blank" rel="noopener">https://otexts.com/fppcn/MA.html</a> 预测方法与实践</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;异常检测方法综述&quot;&gt;&lt;a href=&quot;#异常检测方法综述&quot; class=&quot;headerlink&quot; title=&quot;异常检测方法综述&quot;&gt;&lt;/a&gt;异常检测方法综述&lt;/h3&gt;&lt;h4 id=&quot;统计方法&quot;&gt;&lt;a href=&quot;#统计方法&quot; class=&quot;headerlink&quot; title=&quot;统计方法&quot;&gt;&lt;/a&gt;统计方法&lt;/h4&gt;&lt;p&gt;有基于阈值的，还有对数据的分布做出假设，并找出假设下所定义的“异常”，因此往往会使用极值分析或者假设检验，概率密度函数值小于某个阈值的点判定为异常。 还有些多元模型，如计算多个事件指标之间期望的相关性等等。&lt;/p&gt;&lt;h5 id=&quot;看图&quot;&gt;&lt;a href=&quot;#看图&quot; class=&quot;headerlink&quot; title=&quot;看图&quot;&gt;&lt;/a&gt;看图&lt;/h5&gt;&lt;p&gt;频率直方图， 点分布图&lt;/p&gt;&lt;h5 id=&quot;高斯分布的-k-sigma&quot;&gt;&lt;a href=&quot;#高斯分布的-k-sigma&quot; class=&quot;headerlink&quot; title=&quot;高斯分布的 k-sigma&quot;&gt;&lt;/a&gt;高斯分布的 k-sigma&lt;/h5&gt;&lt;p&gt;概率密度函数为 $f(x)=\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}$&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="异常检测" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
  </entry>
  
  <entry>
    <title>DP算法</title>
    <link href="http://yoursite.com/2020/02/10/20200210DP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/10/20200210DP%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-10T03:04:11.000Z</published>
    <updated>2020-02-22T13:31:40.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-经典的背包问题"><a href="#1-经典的背包问题" class="headerlink" title="1 经典的背包问题"></a>1 经典的背包问题</h3><p>有n个重量和价值分别为$w_i,v_i$ 的物品，从这些物品中挑选出总重量不超过W的物品。求所有挑选方案中价值总和的最大值。</p><p>限制条件：</p><script type="math/tex; mode=display">1 \leqslant n \leqslant 100</script><script type="math/tex; mode=display">1 \leqslant w_{i}, v_{i} \leqslant 100</script><script type="math/tex; mode=display">1 \leqslant W \leqslant 10000</script><a id="more"></a><p>样例输入： n = 4, (w,v) = {(2,3) , (1,2), (3,4) , (2,2)} ,  w = 5 则输出是 7 （选 0、1、3号物品）</p><p>分析：</p><p>记 $dp[i+1][j]$ 是从前i个物品中挑选总重不超过j 的物品时总价值的最大值。于是有如下的递推式：</p><script type="math/tex; mode=display">dp[0]\lfloor j]=0</script><script type="math/tex; mode=display">dp[i+1] [j]=\left\{\begin{array}{ll}{d p[i][j]} & {(j<w[i])} \\ {\max (d p[i][j], d p[i][j-w[i]]+v[i])} & {(其他)}\end{array}\right.</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j&lt;w[i]) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = <span class="built_in">max</span>(dp[i][j],dp[i+<span class="number">1</span>][j-w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][W]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最长公共子序列"><a href="#2-最长公共子序列" class="headerlink" title="2 最长公共子序列"></a>2 最长公共子序列</h3><p>LCS问题是经典问题。给定两个字符串 $s_1s_2s_3…s_n$ 和 $t_1t_2…t_n$ 。求出这两个字符串的最长公共子序列的长度。</p><p>输入：n=4, m=4, s=”abcd”, t=”becd”</p><p>输出：3 （“bcd”）</p><p>定义 $d p[i][j]:= s_1…s_i和t_1…t_j$ 对应的LCS的长度。</p><p>由此$s_1…s_{i+1}和t_1…t_{j+1}$ 对应的公共子序列可能是几种情况：</p><p>第一，当$s_{i+1} = t_{j+1}$ 的时候，在$s_1…s_i和t_1…t_j$ 的公共子序列末尾追加上$s_{i+1}$</p><p>不等的时候，要么是$s_1…s_i和t_1…t_{j+1}$ 的序列的公共子序列，要么就是$s_1…s_{i+1}和t_1…t_j$</p><p>故递推公式是：</p><script type="math/tex; mode=display">d p[i+1][j+1]=\left\{\begin{array}{ll}{d p[i][j]+1} & {\left(s_{i+1}=t_{j+1}\right)} \\ {\max (d p[i][j+1], d p[i+1][j])} & {其他}\end{array}\right.</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input n,m</span></span><br><span class="line"><span class="keyword">char</span> s[MAX_N],t[MAX_N];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N+<span class="number">1</span>][MAX_N+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/20200211LCS_DP.jpg" alt="20200211LCS_DP"></p><h3 id="多重部分和"><a href="#多重部分和" class="headerlink" title="多重部分和"></a>多重部分和</h3><p>leecode39里这里暂时先不考虑将所有的可以加和的结果都存起来。我们先简单考虑能够通过给定的数组里的数，将和得到。下面的代码说明了能否通过这几个数字加和为target，是返回1，不是返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP[i+1][j] 表示用前i种数字加和成j， 需要前i-1种数字加和成 j，j-a[i], j - k *a[i]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[candidates.<span class="built_in">size</span>()+<span class="number">1</span>][target+<span class="number">1</span>]; <span class="comment">// 注意声明大小</span></span><br><span class="line">    <span class="comment">//init</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; candidates.<span class="built_in">size</span>()+<span class="number">1</span>; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k * candidates[i] &lt;= j; k++) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j] = dp[i][j - k*candidates[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[candidates.<span class="built_in">size</span>()][target]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test:  vector&lt;int&gt; candidates = &#123;2,3,6,7&#125;;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;combinationSum(candidates,11)&lt;&lt;endl; 是-1</span></span><br></pre></td></tr></table></figure><h3 id="4-leecode100-10-正则表达式匹配"><a href="#4-leecode100-10-正则表达式匹配" class="headerlink" title="4 leecode100-10 正则表达式匹配"></a>4 leecode100-10 正则表达式匹配</h3><p>给你一个字符串s 和一个字符规律 p，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; 匹配任意单个字符</span><br><span class="line">&apos;*&apos; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p>这里主要是考虑到星的匹配条件。$\operatorname{dp}[i][j]$ 是表示s的前i个能否被p的前j个匹配。</p><p>当$\mathrm{p}[\mathrm{j}]=\mathrm{s}[\mathrm{i}] 或 p[j] = “.”: \mathrm{dp}[\mathrm{i}][\mathrm{j}]=\operatorname{dp}[\mathrm{i}-1][\mathrm{j}-1]$</p><p>当$p[j] = “*”$ 时考虑两种情况：</p><script type="math/tex; mode=display">p[j-1] \quad !=s[i]: \operatorname{dp}[i][j]=\operatorname{dp}[i][j-2]</script><p>如 （ab, abc*）</p><script type="math/tex; mode=display">p[j-1]=s[i] \text { or } p[j-1]="."</script><script type="math/tex; mode=display">\operatorname{dp}[i-1][j] , \operatorname{dp}[i][j-1], \operatorname{dp}[i][j-2]</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// dp[i][j] means that s 的前i个能否被p的前j个匹配</span></span><br><span class="line">    <span class="keyword">int</span> sl = s.length();</span><br><span class="line">    <span class="keyword">int</span> pl = p.length();</span><br><span class="line">    <span class="keyword">if</span>(p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">int</span> dp[sl+<span class="number">1</span>][pl+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=sl; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=pl; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=pl; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j] == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j + <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// here's y axis should be i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sl; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pl; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[j]==<span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>]!=s[i] &amp;&amp; p[j - <span class="number">1</span>] != <span class="string">'.'</span>) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]; <span class="comment">//如果前一个元素不匹配且不为任意元素</span></span><br><span class="line">                <span class="keyword">else</span> dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j] || dp[i][j + <span class="number">1</span>] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sl][pl];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"mississippi"</span>;</span><br><span class="line">    <span class="built_in">string</span> p = <span class="string">"mis*is*p*."</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;isMatch(s,p)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-最长有效括号"><a href="#5-最长有效括号" class="headerlink" title="5 最长有效括号"></a>5 最长有效括号</h3><p>leecode100题的32题，给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。其实一看子序列长度就很像是DP题，那DP怎么定义的呢？一直觉得DP的定义找准真有点难。因为有时候定义不同，解法甚至就会不同。</p><p>DP[i] 以下标为i的字符结尾的最长有效子串长度。为什么这么定义，是因为i+1的字符是不是反括号 ) 决定了能否添加在最长子串的后面，要以i+1结尾的最长有效字符串则i+1一定是 )。以 ( 结尾的子字符串对应的 dp 数组位置上的值必定为 0 。所以说我们只需要更新 ) 在 dp 数组中对应位置的值。</p><p>1，$s[i] = ) 且 s[i-1]= ($  ，可以判断字符串类似”……()” ，那么dp[i] = dp[i-2] + 2; 这里dp[i-2] 是因为后两个字符一起判断的，加2，是因为（）的字符长度是2。</p><script type="math/tex; mode=display">\mathrm{dp}[i]=\mathrm{dp}[i-2]+2</script><p>2，$s[i] = ) 且 s[i-1] = )$ , 此时字符串类似 “…. ))” ，如果 $\mathrm{s}[i-\mathrm{dp}[i-1]-1]= ($ ，则：</p><script type="math/tex; mode=display">\mathrm{dp}[i]=\mathrm{dp}[i-1]+\mathrm{dp}[i-\mathrm{dp}[i-1]-2]+2</script><p>因为这个时候要考虑到如果倒数第二个 ) 是dp[i-1] 的最长子串的一部分。对于最后个 ) ，要匹配 dp[i-1] 最长子串的前面一个 ( 才是子串增加。而dp[i-1] 最长子串的前一个 ( 跟此时 dp[i] 的 ）匹配上了的话，就还得看 dp[i-1] 的前面是否还有以前的最长子串，就是$\mathrm{dp}[i-\mathrm{dp}[i-1]-2]$。减去2 则位置就在 $here(dp[i-1]的sub)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">""</span> || s==<span class="string">"("</span> || s==<span class="string">")"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//init</span></span><br><span class="line">    <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++) dp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//begin 注意边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">'('</span> )&#123;</span><br><span class="line">                dp[i] = (i&gt;=<span class="number">2</span>? dp[i<span class="number">-2</span>]:<span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]&gt;<span class="number">0</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//update the max</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; res) &#123;</span><br><span class="line">               res = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s[i] == '(', dp[i] = 0</span></span><br><span class="line">        <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大连续序列和与接雨水"><a href="#最大连续序列和与接雨水" class="headerlink" title="最大连续序列和与接雨水"></a>最大连续序列和与接雨水</h3><p>如给一个 Array： 1，-2，3，1，-1，5 。则是 8 (3, 1, -1 , 5)</p><p>分析：设 DP [k] 是表示以 k 结尾的最大的和。则递推公式为 DP [k] = max {DP [k-1] + A [k] ，A [k] }，要么是前一个连续和加上数组值（当前数组值为正），要么就是数组本身。这样最后只需要一遍遍历过去，找出以某个 k 结尾的最大和的那个 DP 值即为答案。</p><p>leecode100-42题接雨水：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>第一个for循环找每个点的左侧最大高度 left[i] = max(left[i - 1], height[i - 1]);，</p><p>第二个for循环找每个点右侧的最大高度 right[i] = max(right[i + 1], height[i + 1]);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="built_in">min</span>(left[i], right[i]);</span><br><span class="line">  water += <span class="built_in">max</span>(<span class="number">0</span>, level - <span class="built_in">height</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，《挑战程序设计》 2.3 动态规划章节</p><p>2，leecode经典100题10题，32题，39题</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-经典的背包问题&quot;&gt;&lt;a href=&quot;#1-经典的背包问题&quot; class=&quot;headerlink&quot; title=&quot;1 经典的背包问题&quot;&gt;&lt;/a&gt;1 经典的背包问题&lt;/h3&gt;&lt;p&gt;有n个重量和价值分别为$w_i,v_i$ 的物品，从这些物品中挑选出总重量不超过W的物品。求所有挑选方案中价值总和的最大值。&lt;/p&gt;&lt;p&gt;限制条件：&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;1 \leqslant n \leqslant 100&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;1 \leqslant w_{i}, v_{i} \leqslant 100&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;1 \leqslant W \leqslant 10000&lt;/script&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>一些思考</title>
    <link href="http://yoursite.com/2020/02/07/00000000%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83%EF%BC%88%E5%B8%B8%E6%9B%B4%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/07/00000000%E6%8A%80%E6%9C%AF%E6%80%9D%E8%80%83%EF%BC%88%E5%B8%B8%E6%9B%B4%EF%BC%89/</id>
    <published>2020-02-07T13:07:25.000Z</published>
    <updated>2020-04-08T08:53:34.640Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机科学。"><a href="#计算机科学。" class="headerlink" title="计算机科学。"></a>计算机科学。</h3><p>2020-02-07</p><p>计算机可以是一个计算工具，为了实现一个计算而写一行，所以数学系的常用MATLAB进行计算。</p><p>计算机本身也是一个机器设计的科学，里面有许多的机制与策略，为了让机器更快更有效率，更稳定，更易用，更易于扩展，更简洁易懂，更开放等等，这些是一种设计的科学和精神。有些代码可以恒久经典，必然有其设计理念的先进。</p><a id="more"></a><p>但目前越深入后发现，数学和计算有趋同融合之势。</p><h3 id="数学是基础"><a href="#数学是基础" class="headerlink" title="数学是基础"></a>数学是基础</h3><p>绝大多数基于数学的，如概率统计，比如说贝叶斯分类，根据数据类别的分布去推测出新数据更可能属于哪个类别。深度学习则更多的时候是拟合非线性函数，在数学上看都是模型。看了越多论文越觉得一切皆数学，不论工科理科或管科。</p><h3 id="运筹优化领域"><a href="#运筹优化领域" class="headerlink" title="运筹优化领域"></a>运筹优化领域</h3><p>其实在管科里这个应用十分广泛，毕竟本质是数学。始于线性规划（减少物料使用，减少费用这是目标，各种限制是约束条件），发展于各种决策甚至统计学习（线性回归SVM等优化函数）与深度学习（优化损失函数），更深的数学还有组合优化，多目标优化等等。我在想是否可以考虑一些运筹启发式的策略用于学习呢？比如说模拟退火？考虑一定的概率跳出当前解，重新搜索进行梯度优化？</p><p>3，在推荐领域，推荐的根本思想在于销售，销售除了考虑产品的性质，marketing，还有环境等等，联系起来其实数据特征、特征工程还有规则策略其实不就是为了解决这样的问题吗。</p><p>4，“最好的问题”就是那些能够均分所有可能性的问题，不论如何排除掉k-1/k种可能性。在搜索排序中，如何划分更小的问题的思路。</p><p>2020-04-08</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;计算机科学。&quot;&gt;&lt;a href=&quot;#计算机科学。&quot; class=&quot;headerlink&quot; title=&quot;计算机科学。&quot;&gt;&lt;/a&gt;计算机科学。&lt;/h3&gt;&lt;p&gt;2020-02-07&lt;/p&gt;&lt;p&gt;计算机可以是一个计算工具，为了实现一个计算而写一行，所以数学系的常用MATLAB进行计算。&lt;/p&gt;&lt;p&gt;计算机本身也是一个机器设计的科学，里面有许多的机制与策略，为了让机器更快更有效率，更稳定，更易用，更易于扩展，更简洁易懂，更开放等等，这些是一种设计的科学和精神。有些代码可以恒久经典，必然有其设计理念的先进。&lt;/p&gt;
    
    </summary>
    
    
      <category term="经历" scheme="http://yoursite.com/categories/%E7%BB%8F%E5%8E%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="IT行业" scheme="http://yoursite.com/tags/IT%E8%A1%8C%E4%B8%9A/"/>
    
  </entry>
  
</feed>
