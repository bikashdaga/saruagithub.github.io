---
title: 排序算法复习
date: 2020-03-10 09:06:57
mathjax: true
tags:
- 面试
- 算法
- 排序
categories:
- 算法
---



### 排序算法

排序算法在搜索中常用，因此非常重要。排序算法里包含了重要的分治的思想，就是在划分子问题上。归并排序将数据折半划分，快速排序将数据分成大数和小数部分，基数排序则每次都会按照关键码中的一个数字划分数据。

什么是稳定的排序：如果一种排序算法不会改变关键码值相同的记录的相对顺序，则称为稳定的。

#### 三种基本的排序算法

##### 插入排序

例子：每处理一次数据就把它和前面已经排序的子序列进行比较，再将它插入到前面的正确位置。算法里的Comp类要自己写，实现关键码比较大小，如int就直接比较大小，其他类别比较大小等等。

```c++
// C++
template <typename E, typename Comp>
void inssort(E A[], int n){
	for (int i=1;i<n;i++)
		for (int j=i; (j>0)&&(Comp::prior(A[j],A[j-1])); j--)
			swap(A, j, j-1);
}
```

```python
# python
def insert_sort(array):
	for i in range(0,len(array)):
		for j in range(i,0,-1):
			if j>0 and array[j] < array[j-1]:
				array[j],array[j-1] = array[j-1],array[j] # change the elem
```

这里最差的情况是每条记录都必须移动到最前面（如 array = [3,2,1,0])，空间复杂度由于并没有用其他临时数组，所以还是 $O(1)$，此时时间复杂度：

$$\sum_{i=2}^n i \approx n^2/2 = \Theta(n^2)$$

最佳情况就是每条记录都已经是有序的了，进入内部for循环就退出，于是此时的时间代价是 $\Theta(n)$

平均情况根据逆置来判断，逆置的数值（即数组中位于一个给定值之前的比它大的值的数目）决定比较与交换的次数。平均情况下，在数组的前i-1条记录中有一半关键码值比第i条记录的关键码值大。平均情况下，时间代价是最差情况的一半 $\Theta(n^2/4)$， 是稳定排序。



##### 冒泡排序

例子：气泡冒上来的过程。从最后开始，比较相邻的，如果前面的比它大则交换。就像气泡逐渐被推到数组的顶部。

```c++
//C++
template <typename E,typename Comp>
void bubsort(E A[], int n){
	for(int i=0; i<n-1;i++)
    for(int j=n-1; j>i; j--)
      if(Comp::prior(A[j],A[j-1]))
        swap(A,j,j-1);
}
```

```python
# python
def bubble_sort(array):
	for i in range(0,len(array)-1):
		flag = 0  # trace the exchange times
		for j in range(len(array)-1,i,-1):
			if array[j] < array[j-1]:
				array[j], array[j - 1] = array[j - 1], array[j]
				flag = 1
		if(flag==0):
			return
```

内层的for循环比较次数总会是 i，因此最差时间代价是：$\sum_{i=1}^n i \approx n^2/2 = \Theta(n^2)$ ，平均也是类似插入排序$\Theta(n^2)$，它是稳定的排序。

修改冒泡排序以跟踪其执行的交换次数。 如果数组已经按排序顺序排列，并且冒泡排序不进行交换，则算法可以在经过一遍后终止。在最佳情况下复杂度是 $\Theta(n)$ 。

冒泡排序相对于大多数其他算法（甚至是快速排序，但不是插入排序）具有的唯一显着优势是，该算法内置了检测列表是否被有效排序的功能。



##### 选择排序

选择排序就是选择数组中第i小的记录，并把该记录放到数组的第i个位置上，只需一次交换。

```c++
template <typename E,typename Comp>
void selsort(E A[], int n){
	for(int i=0; i<n-1; i++){
    int lowindex = i;
    for(int j=n-1; j>i ; j--)
      if(Comp::prior(A[j], A[lowindex]))
        lowindex = j;
    swap(A,i,lowindex);
  }
}
```

```python
# python

def select_sort(array):
	for i in range(0,len(array)-1):
		lowindex = i
		for j in range(len(array)-1, i, -1):
			if array[j] < array[lowindex]:
				lowindex = j
			array[i], array[lowindex] = array[lowindex], array[i]
```

比较的次数是 $\Theta(n^2)$ ，但交换的次数比冒泡排序少很多，对于那些做交换花费时间多的问题是更好的。



### 改进的排序

#### shellsort

它在不相邻的记录之间进行比较与交换。shell排序利用了插入排序的最佳时间代价特性。他将序列分成多个子序列，然后分别对子序列进行排序，最后将子序列组合起来。由于实现了元素的跳跃式移动，使排序效率提高。如下图：图中的增量序列就是8，4，2，1。最后一轮将是一次“正常的”插入排序，因为此时序列整体基本上有序，故用插入排序的复杂度相对较小。

shellsort增量选择3的时候，效果较好，平均运行时间复杂度是$\Theta(n^{1.5})$ 。 

相同的元素可能在各自的插入排序中移动， 是不稳定排序。在中等大小规模的数据上表现良好。

![20200310shellsort](/images/20200310shellsort.jpg)

```C++
//shellsort
template <typename  E>
void insort(E A[],int n, int increment){
    for (int i=increment; i<n; i+=increment) {
        for (int j=i; (j>=increment)&&(A[j]<A[j-increment]); j-=increment) {
            E temp = A[j];
            A[j] = A[j-increment];
            A[j-increment] = temp;
        }
    }
}

template <typename  E>
void shellsort(E A[],int n){
    for (int i=n/2; i>2; i/=2) {
        for (int j=0; j<i; j++) {
            insort<E>(&A[j], n-j, i);//A[j] is the start address  偏移，巧妙
        }
    }
    insort<E>(A, n, 1);
}

int main(){
    int num[16] = {59,20,17,13,28,14,23,83,36,98,11,70,65,41,42,15};
    shellsort<int>(num, 16);
    for (auto n:num) {
        cout<<n<<endl;
    }
    return 0;
}
```

Python：

```c++
def shell_sort(array):
	n = len(array)
	gap = n // 2
	while gap > 0:
		for i in range(gap,n):
			temp = array[i]
			j = i
			while j >= gap and array[j-gap] > temp:
				array[j] = array[j-gap]
				j-=gap
			array[j] = temp
		gap //= 2
```



#### mergesort

来源于分治的思想，在排序问题上分治的思想体现在把待排序的列表分成片段，先处理片段，然后将片段重组。

伪代码的提现其思想：

```
List mergesort(List inlist){
	if(inlist.length() <= 1) return inlist;
	List L1 = half of the list;
	List L2 = other half of the list;
	return mergesort(mergesort(L1),mergesort(L2));
}
```

![20200310Merge-Sort](/images/20200310Merge-Sort.png)

当输入的待排序数据存储在链表中时，归并排序是一个很好的选择。

两个指针，最初分别为两个已经排序序列的起始位置。比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。重复直到某一指针达到序列尾，剩下的元素直接放入到合并的片段里。

```c++
#include <iostream>
using namespace std;

template <typename E>
void mergesort(E A[],E temp[], int left, int right){
    if (left == right) {
        return;
    }
    int mid = left + (right-left)/2;
    mergesort<E>(A, temp, left, mid);
    mergesort<E>(A, temp, mid+1, right);
    //then merge, temp[] is the auxiliary array
    for (int i=left; i<=right; i++) {
        temp[i] = A[i];
    }
    int i1 = left;
    int i2 = mid+1;
    for (int curr=left; curr<=right; curr++) {
        if (i1 == mid+1) A[curr] = temp[i2++]; //left all < right
        else if(i2 > right) A[curr] = temp[i1++]; //right all < left
        else if (temp[i1] < temp[i2]) A[curr] = temp[i1++];// smaller one is put into A
        else A[curr] = temp[i2++];
    }
}
int main(){
    int num[16] = {59,20,17,13,28,14,23,83,36,98,11,70,65,41,42,15};
    int temp[16] = {0};
    mergesort<int>(num, temp, 0, 15);
    for (auto n:num) {
        cout<<n<<endl;
    }
    return 0;
}
```

当被排序元素的数目是n时，递归的深度是$logn$ ，第一层递归是对长度为n的数组排序，下一层是对2个长度为n/2的子数组排序......，在所有$logn$ 层递归中，每一层都需要$\Theta(n)$ 时间代价，因此总时间代价都是$n log(n)$。

python版本代码可以参考https://www.geeksforgeeks.org/python-program-for-merge-sort/



#### quicksort

快速排序不需要额外的空间，典型应用是Unix系统调用库里的qsort函数。快速排序选定一个轴值，数组在小于轴值的放在左边，大于的放在右边。这被称为数组的一个划分 partition。快速排序最差情况是当轴值每次都不能把数组划分得很好，下一次处理子问题规模只比原来的问题规模减少1，时间代价是$\Theta(n^2)$ ，最佳和平均复杂度是$\Theta(n logn)$ 。

快排为什么这么快？

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

void swap(int A[], int i, int j)
{
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}

int partition(int A[],int l, int r, int& pivot){
    do{
        while(A[++l] > pivot); //move the index
        while((l<r) && (A[--r] < pivot));
        swap(A,l,r);
    }while(l<r);
    return l;
}

void myqsort(int A[],int i,int j){
    if (i >= j) return;
    int pivotIndex = (i+j)/2; //这里可以写一个findpivot函数，三者取中（三个随机值的中间）
    swap(A,pivotIndex,j);
    int k = partition(A,i-1,j,A[j]); //k is the start of the left half
    swap(A,k,j);// 轴值就在k位置，就是最终排序好的数组中的位置
    myqsort(A,i,k-1);
    myqsort(A,k+1,j);
}
```

这里面的改进可以从pivotIndex的设置，以及递归到一个较小的数组的时候采用插入排序（基本有序的小数组很适合）等。

Python版本：更清晰一点，把轴值设置为左边第一个。

```python
def quick_sort(array, left, right):
	if left >= right:
		return
	low = left
	high = right
	key = array[low]
	while left < right:
		while left < right and array[right] > key:
			right -= 1
		array[left] = array[right]
		while left < right and array[left] <= key:
			left += 1
		array[right] = array[left]
	array[right] = key

	quick_sort(array, low, left - 1)
	quick_sort(array, left + 1, high)
```



#### heapsort

堆是一棵完全二叉树，可以用数组来实现。参考 [数组实现堆]([https://saruagithub.github.io/2020/03/28/20200328%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86/](https://saruagithub.github.io/2020/03/28/20200328数组实现堆/))

堆可以用来排序



计数排序

桶排序

基数排序



### 内嵌算法

#### timsort

这是Python的内嵌排序算法。





![20200310Allsort](/Users/wangxue/gitpro/20191105MyBlog/saruagithub/source/images/20200310Allsort.jpg)



### Reference

1，《数据结构与算法分析》 Clifford A. Shaffer 等

2，[百度百科]([https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F](https://baike.baidu.com/item/希尔排序))

3， [机器之心 Timsort](https://www.jiqizhixin.com/articles/2018-11-20-3)

4，https://www.geeksforgeeks.org/python-program-for-merge-sort/