---
title: DP算法
date: 2020-02-10 11:04:11
mathjax: true
tags:
- 动态规划
- 算法
categories:
- 算法
---

### 1 经典的背包问题

有n个重量和价值分别为$w_i,v_i$ 的物品，从这些物品中挑选出总重量不超过W的物品。求所有挑选方案中价值总和的最大值。

限制条件：

$$1 \leqslant n \leqslant 100$$

$$1 \leqslant w_{i}, v_{i} \leqslant 100$$

$$1 \leqslant W \leqslant 10000$$

样例输入： n = 4, (w,v) = {(2,3) , (1,2), (3,4) , (2,2)} ,  w = 5 则输出是 7 （选 0、1、3号物品）

分析：

记 $dp[i+1][j]$ 是从前i个物品中挑选总重不超过j 的物品时总价值的最大值。于是有如下的递推式：

$$dp[0]\lfloor j]=0$$

$$dp[i+1] [j]=\left\{\begin{array}{ll}{d p[i][j]} & {(j<w[i])} \\ {\max (d p[i][j], d p[i][j-w[i]]+v[i])} & {(其他)}\end{array}\right.$$



```c++
void solve(){
    for (int i=0; i<n; i++) {
        for (int j=0; j<=W; j++) {
            if (j<w[i]) {
                dp[i+1][j] = dp[i][j];
            }
            else{
                dp[i+1][j] = max(dp[i][j],dp[i+1][j-w[i]] + v[i]);
            }
        }
    }
    cout<<dp[n][W]<<endl;
}
```



### 2 最长公共子序列





### 3 leecode100-10 正则表达式匹配

给你一个字符串s 和一个字符规律 p，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
```

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

这里主要是考虑到星的匹配条件。$\operatorname{dp}[i][j]$ 是表示s的前i个能否被p的前j个匹配。

当$\mathrm{p}[\mathrm{j}]=\mathrm{s}[\mathrm{i}] 或 p[j] = ".": \mathrm{dp}[\mathrm{i}][\mathrm{j}]=\operatorname{dp}[\mathrm{i}-1][\mathrm{j}-1]$

当$p[j] = "*"$ 时考虑两种情况：

$$p[j-1] \quad !=s[i]: \operatorname{dp}[i][j]=\operatorname{dp}[i][j-2]$$

如 （ab, abc*）

$$p[j-1]=s[i] \text { or } p[j-1]="."$$

$$\operatorname{dp}[i-1][j] , \operatorname{dp}[i][j-1], \operatorname{dp}[i][j-2]$$



```c++
bool isMatch(string s,string p){
    // dp[i][j] means that s 的前i个能否被p的前j个匹配
    int sl = s.length();
    int pl = p.length();
    if(p.empty()) return s.empty();
    // init
    int dp[sl+1][pl+1];
    for (int i=0; i<=sl; i++) {
        for (int j=0; j<=pl; j++) {
            dp[i][j] = 0;
        }
    }
    dp[0][0] = 1;//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配
    for (int j=1; j<=pl; j++) {
        if (p[j] == '*' && dp[0][j - 1]) {
            dp[0][j + 1] = 1; // here's y axis should be i+1
        }
    }
    for (int i=0; i<sl; i++) {
        for (int j=0; j<pl; j++) {
            if (s[i] == p[j] || p[j] == '.') {
                dp[i+1][j+1] = dp[i][j];
            }
            if(p[j]=='*'){
                if(p[j-1]!=s[i] && p[j - 1] != '.') dp[i+1][j+1] = dp[i+1][j-1]; //如果前一个元素不匹配且不为任意元素
                else dp[i + 1][j + 1] = (dp[i + 1][j] || dp[i][j + 1] || dp[i + 1][j - 1]);
            }
        }
    }
    return dp[sl][pl];
}

int main(){
    string s = "mississippi";
    string p = "mis*is*p*.";
    cout<<isMatch(s,p)<<endl;
    return 0;
}
```





### Reference

1，《挑战程序设计》 2.3 动态规划章节

2，leecode经典100题