---
title: 字节算法岗面试记录
date: 2020-02-10 17:40:59
tags:
- 面试
- 算法
categories:
- 算法
---

### 一面

面试官真的是很直接了，就出了道算法题。但整体来说这个面试官真的是超级好了啊，特别会引导，我觉得字节就是这点细节很好。

最大连续序列和。

如给一个Array： 1，-2，3，1，-1，5 。则是8 (3, 1, -1 , 5)

分析：设DP[k] 是表示以k结尾的最大的和。则递推公式为 DP[k] = max{DP[k-1] + A[k] ，A[k] }，要么是前一个连续和加上数组值（当前数组值为正），要么就是数组本身。这样最后只需要一遍遍历过去，找出以某个k结尾的最大和的那个DP值即为答案。

代入看：初始化DP[0] = 0 , DP[1] = max{1, 0} = 1 , DP[2] = max{-1, -2} = -1; ....

```c++
int maxSequenceSum(int* matrix, int length){
  if(length < 0) return -1;
  int dp[length];
  dp[0] = 0;
  for(int i=1;i<length;i++){
    dp[i] = max(dp[i-1]+matrix[i], matrix[i]);
  }
  // get the max
  int res = 0;
  for(int i=0;i<length;i++){
    if(dp[i] > res) res = dp[i];
  }
  return res;
}
```



这里的时间复杂度是O (n)，空间复杂度也是O(n)，面试官引导进行优化空间。

思路就是用变量存上一个dp[i-1] 与最大的 dp值，直接返回即可。

```c++
int maxSequenceSum(int* matrix, int length){
  if(length < 0) return -1;
  int dp[length];
  dp_max = matrix[0]; // store the max
  dp_last = matrix[0]; // store the dp[i-1]
  for(int i=1;i<length;i++){
    dp_last = max(dp_last + matrx[i], matrix[i]);
    if(dp_last > dp_max) dp_max = dp_last;
  }
  return dp_max;
}
```

真的是有意思，我也没有刷完所有题，感觉自己思路还是有些慢，得再练哦。



### 二面

二面的技术leader有点像个稍严厉的大父亲，而且涉及很广居然包括博弈论，我虽然是学了很多博弈论的数学模型（还记得当时的考试，复习得可费劲了，得理解所有的啥完美，完全博弈啥概念，还得计算的）。在此记录一些问题吧。

1，出了个问题是在给定的CTR和CVR之下，让用户尽量久的停留（停留时间长）。考虑最优化，写优化和约束和拉格朗日法。

我一开始莽撞写错了不等式约束，然后后面想了想SVM才改了。那里可能给面试官留了不好的印象

2，吃完饭更

3，给一个不均分的硬币。投的证明概率是P（不是0.5），怎么用它来得到均匀的结果。



1月23面的，好不容易面完了二面，技术岗说后面HR联系，然后然后就没有然后了通知说岗位不匹配，我我我明明那么开心的准备过了年去实习的，我觉得还挺匹配的啊。经管这套东西其实很能揭示一些用户行为的原理的，尤其是博弈论里机制设计好了是可以引导用户行为的，hhh。